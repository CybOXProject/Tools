#!/usr/bin/env python

#
# Generated Fri Jul 23 10:17:34 2010 by generateDS.py version 2.0b.
#

import sys
import getopt
from string import lower as str_lower
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    text = node.text if node.text is not None else ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class DeprecatedInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, reason=None, comment=None):
        self.version = version
        self.reason = reason
        self.comment = comment
    def factory(*args_, **kwargs_):
        if DeprecatedInfoType.subclass:
            return DeprecatedInfoType.subclass(*args_, **kwargs_)
        else:
            return DeprecatedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='win-def:', name_='DeprecatedInfoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DeprecatedInfoType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='DeprecatedInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='DeprecatedInfoType'):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('<%sversion>%s</%sversion>\n' % (namespace_, self.format_string(quote_xml(self.version).encode(ExternalEncoding), input_name='version'), namespace_))
        if self.reason is not None:
            showIndent(outfile, level)
            outfile.write('<%sreason>%s</%sreason>\n' % (namespace_, self.format_string(quote_xml(self.reason).encode(ExternalEncoding), input_name='reason'), namespace_))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('<%scomment>%s</%scomment>\n' % (namespace_, self.format_string(quote_xml(self.comment).encode(ExternalEncoding), input_name='comment'), namespace_))
    def hasContent_(self):
        if (
            self.version is not None or
            self.reason is not None or
            self.comment is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DeprecatedInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=%s,\n' % quote_python(self.version).encode(ExternalEncoding))
        if self.reason is not None:
            showIndent(outfile, level)
            outfile.write('reason=%s,\n' % quote_python(self.reason).encode(ExternalEncoding))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment=%s,\n' % quote_python(self.comment).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'version':
            version_ = child_.text
            self.version = version_
        elif nodeName_ == 'reason':
            reason_ = child_.text
            self.reason = reason_
        elif nodeName_ == 'comment':
            comment_ = child_.text
            self.comment = comment_
# end class DeprecatedInfoType


class GeneratorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, product_name=None, product_version=None, schema_version=None, timestamp=None):
        self.product_name = product_name
        self.product_version = product_version
        self.schema_version = schema_version
        self.timestamp = timestamp
    def factory(*args_, **kwargs_):
        if GeneratorType.subclass:
            return GeneratorType.subclass(*args_, **kwargs_)
        else:
            return GeneratorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_product_name(self): return self.product_name
    def set_product_name(self, product_name): self.product_name = product_name
    def get_product_version(self): return self.product_version
    def set_product_version(self, product_version): self.product_version = product_version
    def get_schema_version(self): return self.schema_version
    def set_schema_version(self, schema_version): self.schema_version = schema_version
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def export(self, outfile, level, namespace_='win-def:', name_='GeneratorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='GeneratorType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='GeneratorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='oval:', name_='GeneratorType'):
        if self.product_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sproduct_name>%s</%sproduct_name>\n' % ('oval:', self.format_string(quote_xml(self.product_name).encode(ExternalEncoding), input_name='product_name'), 'oval:'))
        if self.product_version is not None:
            showIndent(outfile, level)
            outfile.write('<%sproduct_version>%s</%sproduct_version>\n' % ('oval:', self.format_string(quote_xml(self.product_version).encode(ExternalEncoding), input_name='product_version'), 'oval:'))
        if self.schema_version is not None:
            showIndent(outfile, level)
            outfile.write('<%sschema_version>%s</%sschema_version>\n' % ('oval:', self.format_string(quote_xml(self.schema_version).encode(ExternalEncoding), input_name='schema_version'), 'oval:'))
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('<%stimestamp>%s</%stimestamp>\n' % ('oval:', self.format_string(quote_xml(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), 'oval:'))
    def hasContent_(self):
        if (
            self.product_name is not None or
            self.product_version is not None or
            self.schema_version is not None or
            self.timestamp is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GeneratorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.product_name is not None:
            showIndent(outfile, level)
            outfile.write('product_name=%s,\n' % quote_python(self.product_name).encode(ExternalEncoding))
        if self.product_version is not None:
            showIndent(outfile, level)
            outfile.write('product_version=%s,\n' % quote_python(self.product_version).encode(ExternalEncoding))
        if self.schema_version is not None:
            showIndent(outfile, level)
            outfile.write('schema_version=%s,\n' % quote_python(self.schema_version).encode(ExternalEncoding))
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp=%s,\n' % quote_python(self.timestamp).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'product_name':
            product_name_ = child_.text
            self.product_name = product_name_
        elif nodeName_ == 'product_version':
            product_version_ = child_.text
            self.product_version = product_version_
        elif nodeName_ == 'schema_version':
            schema_version_ = child_.text
            self.schema_version = schema_version_
        elif nodeName_ == 'timestamp':
            timestamp_ = child_.text
            self.timestamp = timestamp_
# end class GeneratorType


class MessageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, level='info', valueOf_=None):
        self.level = _cast(None, level)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MessageType.subclass:
            return MessageType.subclass(*args_, **kwargs_)
        else:
            return MessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='MessageType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='MessageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='MessageType'):
        if self.level is not None:
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='MessageType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MessageType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.level is not None:
            showIndent(outfile, level)
            outfile.write('level = %s,\n' % (self.level,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('level')
        if value is not None:
            self.level = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class MessageType


class SignatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignedInfo=None, SignatureValue=None, KeyInfo=None, Object=None):
        self.Id = _cast(None, Id)
        self.SignedInfo = SignedInfo
        self.SignatureValue = SignatureValue
        self.KeyInfo = KeyInfo
        if Object is None:
            self.Object = []
        else:
            self.Object = Object
    def factory(*args_, **kwargs_):
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SignedInfo(self): return self.SignedInfo
    def set_SignedInfo(self, SignedInfo): self.SignedInfo = SignedInfo
    def get_SignatureValue(self): return self.SignatureValue
    def set_SignatureValue(self, SignatureValue): self.SignatureValue = SignatureValue
    def get_KeyInfo(self): return self.KeyInfo
    def set_KeyInfo(self, KeyInfo): self.KeyInfo = KeyInfo
    def get_Object(self): return self.Object
    def set_Object(self, Object): self.Object = Object
    def add_Object(self, value): self.Object.append(value)
    def insert_Object(self, index, value): self.Object[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def export(self, outfile, level, namespace_='win-def:', name_='SignatureType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SignatureType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SignatureType'):
        if self.Id is not None:
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='SignatureType'):
        if self.SignedInfo:
            self.SignedInfo.export(outfile, level, namespace_, name_='SignedInfo', )
        if self.SignatureValue:
            self.SignatureValue.export(outfile, level, namespace_, name_='SignatureValue', )
        if self.KeyInfo:
            self.KeyInfo.export(outfile, level, namespace_, name_='KeyInfo')
        for Object_ in self.Object:
            Object_.export(outfile, level, namespace_, name_='Object')
    def hasContent_(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None or
            self.Object
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SignatureType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id = %s,\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SignedInfo is not None:
            showIndent(outfile, level)
            outfile.write('SignedInfo=model_.SignedInfo(\n')
            self.SignedInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SignatureValue is not None:
            showIndent(outfile, level)
            outfile.write('SignatureValue=model_.SignatureValue(\n')
            self.SignatureValue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.KeyInfo is not None:
            showIndent(outfile, level)
            outfile.write('KeyInfo=model_.KeyInfo(\n')
            self.KeyInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Object=[\n')
        level += 1
        for Object_ in self.Object:
            showIndent(outfile, level)
            outfile.write('model_.Object(\n')
            Object_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Id')
        if value is not None:
            self.Id = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'SignedInfo': 
            obj_ = SignedInfoType.factory()
            obj_.build(child_)
            self.set_SignedInfo(obj_)
        elif nodeName_ == 'SignatureValue': 
            obj_ = SignatureValueType.factory()
            obj_.build(child_)
            self.set_SignatureValue(obj_)
        elif nodeName_ == 'KeyInfo': 
            obj_ = KeyInfoType.factory()
            obj_.build(child_)
            self.set_KeyInfo(obj_)
        elif nodeName_ == 'Object': 
            obj_ = ObjectType.factory()
            obj_.build(child_)
            self.Object.append(obj_)
# end class SignatureType


class SignatureValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, valueOf_=None):
        self.Id = _cast(None, Id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SignatureValueType.subclass:
            return SignatureValueType.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='SignatureValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SignatureValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SignatureValueType'):
        super(SignatureValueType, self).exportAttributes(outfile, level, namespace_, name_='SignatureValueType')
        if self.Id is not None:
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='SignatureValueType'):
        super(SignatureValueType, self).exportChildren(outfile, level, namespace_, name_)
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SignatureValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id = %s,\n' % (self.Id,))
        super(SignatureValueType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SignatureValueType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Id')
        if value is not None:
            self.Id = value
        super(SignatureValueType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        pass
# end class SignatureValueType


class SignedInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, CanonicalizationMethod=None, SignatureMethod=None, Reference=None):
        self.Id = _cast(None, Id)
        self.CanonicalizationMethod = CanonicalizationMethod
        self.SignatureMethod = SignatureMethod
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CanonicalizationMethod(self): return self.CanonicalizationMethod
    def set_CanonicalizationMethod(self, CanonicalizationMethod): self.CanonicalizationMethod = CanonicalizationMethod
    def get_SignatureMethod(self): return self.SignatureMethod
    def set_SignatureMethod(self, SignatureMethod): self.SignatureMethod = SignatureMethod
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference(self, index, value): self.Reference[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def export(self, outfile, level, namespace_='win-def:', name_='SignedInfoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SignedInfoType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SignedInfoType'):
        if self.Id is not None:
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='SignedInfoType'):
        if self.CanonicalizationMethod:
            self.CanonicalizationMethod.export(outfile, level, namespace_, name_='CanonicalizationMethod', )
        if self.SignatureMethod:
            self.SignatureMethod.export(outfile, level, namespace_, name_='SignatureMethod', )
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference')
    def hasContent_(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SignedInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id = %s,\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CanonicalizationMethod is not None:
            showIndent(outfile, level)
            outfile.write('CanonicalizationMethod=model_.CanonicalizationMethod(\n')
            self.CanonicalizationMethod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SignatureMethod is not None:
            showIndent(outfile, level)
            outfile.write('SignatureMethod=model_.SignatureMethod(\n')
            self.SignatureMethod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.Reference(\n')
            Reference_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Id')
        if value is not None:
            self.Id = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'CanonicalizationMethod': 
            obj_ = CanonicalizationMethodType.factory()
            obj_.build(child_)
            self.set_CanonicalizationMethod(obj_)
        elif nodeName_ == 'SignatureMethod': 
            obj_ = SignatureMethodType.factory()
            obj_.build(child_)
            self.set_SignatureMethod(obj_)
        elif nodeName_ == 'Reference': 
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
# end class SignedInfoType


class CanonicalizationMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, valueOf_=None, mixedclass_=None, content_=None):
        self.Algorithm = _cast(None, Algorithm)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='CanonicalizationMethodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CanonicalizationMethodType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='CanonicalizationMethodType'):
        outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
   #def exportChildren(self, outfile, level, namespace_='win-def:', name_='CanonicalizationMethodType'):
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CanonicalizationMethodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Algorithm is not None:
            showIndent(outfile, level)
            outfile.write('Algorithm = %s,\n' % (self.Algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Algorithm')
        if value is not None:
            self.Algorithm = value
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, HMACOutputLength=None, valueOf_=None, mixedclass_=None, content_=None):
        self.Algorithm = _cast(None, Algorithm)
        self.HMACOutputLength = HMACOutputLength
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HMACOutputLength(self): return self.HMACOutputLength
    def set_HMACOutputLength(self, HMACOutputLength): self.HMACOutputLength = HMACOutputLength
    def validate_HMACOutputLength(self, value):
        # validate type HMACOutputLength
        pass
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='SignatureMethodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SignatureMethodType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SignatureMethodType'):
        outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='SignatureMethodType'):
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.HMACOutputLength is not None or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SignatureMethodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Algorithm is not None:
            showIndent(outfile, level)
            outfile.write('Algorithm = %s,\n' % (self.Algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Algorithm')
        if value is not None:
            self.Algorithm = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'HMACOutputLength' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'HMACOutputLength', valuestr_)
            self.content_.append(obj_)
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class SignatureMethodType


class ReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, Id=None, URI=None, Transforms=None, DigestMethod=None, DigestValue=None):
        self.Type = _cast(None, Type)
        self.Id = _cast(None, Id)
        self.URI = _cast(None, URI)
        self.Transforms = Transforms
        self.DigestMethod = DigestMethod
        self.DigestValue = DigestValue
    def factory(*args_, **kwargs_):
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transforms(self): return self.Transforms
    def set_Transforms(self, Transforms): self.Transforms = Transforms
    def get_DigestMethod(self): return self.DigestMethod
    def set_DigestMethod(self, DigestMethod): self.DigestMethod = DigestMethod
    def get_DigestValue(self): return self.DigestValue
    def set_DigestValue(self, DigestValue): self.DigestValue = DigestValue
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def export(self, outfile, level, namespace_='win-def:', name_='ReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='ReferenceType'):
        if self.Type is not None:
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.Id is not None:
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None:
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='ReferenceType'):
        if self.Transforms:
            self.Transforms.export(outfile, level, namespace_, name_='Transforms')
        if self.DigestMethod:
            self.DigestMethod.export(outfile, level, namespace_, name_='DigestMethod', )
        if self.DigestValue is not None:
            showIndent(outfile, level)
            outfile.write('<%sDigestValue>%s</%sDigestValue>\n' % (namespace_, self.format_string(quote_xml(self.DigestValue).encode(ExternalEncoding), input_name='DigestValue'), namespace_))
    def hasContent_(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id = %s,\n' % (self.Id,))
        if self.URI is not None:
            showIndent(outfile, level)
            outfile.write('URI = %s,\n' % (self.URI,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Transforms is not None:
            showIndent(outfile, level)
            outfile.write('Transforms=model_.Transforms(\n')
            self.Transforms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DigestMethod is not None:
            showIndent(outfile, level)
            outfile.write('DigestMethod=model_.DigestMethod(\n')
            self.DigestMethod.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DigestValue is not None:
            showIndent(outfile, level)
            outfile.write('DigestValue=%s,\n' % quote_python(self.DigestValue).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Type')
        if value is not None:
            self.Type = value
        value = attrs.get('Id')
        if value is not None:
            self.Id = value
        value = attrs.get('URI')
        if value is not None:
            self.URI = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'Transforms': 
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.set_Transforms(obj_)
        elif nodeName_ == 'DigestMethod': 
            obj_ = DigestMethodType.factory()
            obj_.build(child_)
            self.set_DigestMethod(obj_)
        elif nodeName_ == 'DigestValue':
            DigestValue_ = child_.text
            self.DigestValue = DigestValue_
# end class ReferenceType


class TransformsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Transform=None):
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform
    def factory(*args_, **kwargs_):
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transform(self): return self.Transform
    def set_Transform(self, Transform): self.Transform = Transform
    def add_Transform(self, value): self.Transform.append(value)
    def insert_Transform(self, index, value): self.Transform[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='TransformsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TransformsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='TransformsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='TransformsType'):
        for Transform_ in self.Transform:
            Transform_.export(outfile, level, namespace_, name_='Transform')
    def hasContent_(self):
        if (
            self.Transform
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TransformsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Transform=[\n')
        level += 1
        for Transform_ in self.Transform:
            showIndent(outfile, level)
            outfile.write('model_.Transform(\n')
            Transform_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'Transform': 
            obj_ = TransformType.factory()
            obj_.build(child_)
            self.Transform.append(obj_)
# end class TransformsType


class TransformType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, XPath=None, valueOf_=None, mixedclass_=None, content_=None):
        self.Algorithm = _cast(None, Algorithm)
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XPath(self): return self.XPath
    def set_XPath(self, XPath): self.XPath = XPath
    def add_XPath(self, value): self.XPath.append(value)
    def insert_XPath(self, index, value): self.XPath[index] = value
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='TransformType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TransformType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='TransformType'):
        outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='TransformType'):
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.XPath or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TransformType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Algorithm is not None:
            showIndent(outfile, level)
            outfile.write('Algorithm = %s,\n' % (self.Algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Algorithm')
        if value is not None:
            self.Algorithm = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'XPath' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'XPath', valuestr_)
            self.content_.append(obj_)
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class TransformType


class DigestMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, valueOf_=None, mixedclass_=None, content_=None):
        self.Algorithm = _cast(None, Algorithm)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='DigestMethodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DigestMethodType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='DigestMethodType'):
        outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='DigestMethodType'):
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DigestMethodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Algorithm is not None:
            showIndent(outfile, level)
            outfile.write('Algorithm = %s,\n' % (self.Algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Algorithm')
        if value is not None:
            self.Algorithm = value
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class DigestMethodType


class KeyInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, KeyName=None, KeyValue=None, RetrievalMethod=None, X509Data=None, PGPData=None, SPKIData=None, MgmtData=None, valueOf_=None, mixedclass_=None, content_=None):
        self.Id = _cast(None, Id)
        if KeyName is None:
            self.KeyName = []
        else:
            self.KeyName = KeyName
        if KeyValue is None:
            self.KeyValue = []
        else:
            self.KeyValue = KeyValue
        if RetrievalMethod is None:
            self.RetrievalMethod = []
        else:
            self.RetrievalMethod = RetrievalMethod
        if X509Data is None:
            self.X509Data = []
        else:
            self.X509Data = X509Data
        if PGPData is None:
            self.PGPData = []
        else:
            self.PGPData = PGPData
        if SPKIData is None:
            self.SPKIData = []
        else:
            self.SPKIData = SPKIData
        if MgmtData is None:
            self.MgmtData = []
        else:
            self.MgmtData = MgmtData
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeyName(self): return self.KeyName
    def set_KeyName(self, KeyName): self.KeyName = KeyName
    def add_KeyName(self, value): self.KeyName.append(value)
    def insert_KeyName(self, index, value): self.KeyName[index] = value
    def get_KeyValue(self): return self.KeyValue
    def set_KeyValue(self, KeyValue): self.KeyValue = KeyValue
    def add_KeyValue(self, value): self.KeyValue.append(value)
    def insert_KeyValue(self, index, value): self.KeyValue[index] = value
    def get_RetrievalMethod(self): return self.RetrievalMethod
    def set_RetrievalMethod(self, RetrievalMethod): self.RetrievalMethod = RetrievalMethod
    def add_RetrievalMethod(self, value): self.RetrievalMethod.append(value)
    def insert_RetrievalMethod(self, index, value): self.RetrievalMethod[index] = value
    def get_X509Data(self): return self.X509Data
    def set_X509Data(self, X509Data): self.X509Data = X509Data
    def add_X509Data(self, value): self.X509Data.append(value)
    def insert_X509Data(self, index, value): self.X509Data[index] = value
    def get_PGPData(self): return self.PGPData
    def set_PGPData(self, PGPData): self.PGPData = PGPData
    def add_PGPData(self, value): self.PGPData.append(value)
    def insert_PGPData(self, index, value): self.PGPData[index] = value
    def get_SPKIData(self): return self.SPKIData
    def set_SPKIData(self, SPKIData): self.SPKIData = SPKIData
    def add_SPKIData(self, value): self.SPKIData.append(value)
    def insert_SPKIData(self, index, value): self.SPKIData[index] = value
    def get_MgmtData(self): return self.MgmtData
    def set_MgmtData(self, MgmtData): self.MgmtData = MgmtData
    def add_MgmtData(self, value): self.MgmtData.append(value)
    def insert_MgmtData(self, index, value): self.MgmtData[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='KeyInfoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='KeyInfoType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='KeyInfoType'):
        if self.Id is not None:
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='KeyInfoType'):
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.KeyName or
            self.KeyValue or
            self.RetrievalMethod or
            self.X509Data or
            self.PGPData or
            self.SPKIData or
            self.MgmtData or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KeyInfoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id = %s,\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Id')
        if value is not None:
            self.Id = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'KeyName' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'KeyName', valuestr_)
            self.content_.append(obj_)
        elif nodeName_ == 'KeyValue':
            childobj_ = KeyValue.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'KeyValue', childobj_)
            self.content_.append(obj_)
        elif nodeName_ == 'RetrievalMethod':
            childobj_ = RetrievalMethod.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'RetrievalMethod', childobj_)
            self.content_.append(obj_)
        elif nodeName_ == 'X509Data':
            childobj_ = X509Data.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'X509Data', childobj_)
            self.content_.append(obj_)
        elif nodeName_ == 'PGPData':
            childobj_ = PGPData.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'PGPData', childobj_)
            self.content_.append(obj_)
        elif nodeName_ == 'SPKIData':
            childobj_ = SPKIData.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'SPKIData', childobj_)
            self.content_.append(obj_)
        elif nodeName_ == 'MgmtData' and child_.text is not None:
            valuestr_ = child_.text
            obj_ = self.mixedclass_(MixedContainer.CategorySimple,
                MixedContainer.TypeString, 'MgmtData', valuestr_)
            self.content_.append(obj_)
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class KeyInfoType


class KeyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DSAKeyValue=None, RSAKeyValue=None, valueOf_=None, mixedclass_=None, content_=None):
        self.DSAKeyValue = DSAKeyValue
        self.RSAKeyValue = RSAKeyValue
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if KeyValueType.subclass:
            return KeyValueType.subclass(*args_, **kwargs_)
        else:
            return KeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DSAKeyValue(self): return self.DSAKeyValue
    def set_DSAKeyValue(self, DSAKeyValue): self.DSAKeyValue = DSAKeyValue
    def get_RSAKeyValue(self): return self.RSAKeyValue
    def set_RSAKeyValue(self, RSAKeyValue): self.RSAKeyValue = RSAKeyValue
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='KeyValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='KeyValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='KeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='KeyValueType'):
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.DSAKeyValue is not None or
            self.RSAKeyValue is not None or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='KeyValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'DSAKeyValue':
            childobj_ = DSAKeyValue.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'DSAKeyValue', childobj_)
            self.content_.append(obj_)
        elif nodeName_ == 'RSAKeyValue':
            childobj_ = RSAKeyValue.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'RSAKeyValue', childobj_)
            self.content_.append(obj_)
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class KeyValueType


class RetrievalMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Type=None, URI=None, Transforms=None):
        self.Type = _cast(None, Type)
        self.URI = _cast(None, URI)
        self.Transforms = Transforms
    def factory(*args_, **kwargs_):
        if RetrievalMethodType.subclass:
            return RetrievalMethodType.subclass(*args_, **kwargs_)
        else:
            return RetrievalMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transforms(self): return self.Transforms
    def set_Transforms(self, Transforms): self.Transforms = Transforms
    def get_Type(self): return self.Type
    def set_Type(self, Type): self.Type = Type
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def export(self, outfile, level, namespace_='win-def:', name_='RetrievalMethodType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RetrievalMethodType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='RetrievalMethodType'):
        if self.Type is not None:
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
        if self.URI is not None:
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='RetrievalMethodType'):
        if self.Transforms:
            self.Transforms.export(outfile, level, namespace_, name_='Transforms')
    def hasContent_(self):
        if (
            self.Transforms is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RetrievalMethodType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Type is not None:
            showIndent(outfile, level)
            outfile.write('Type = %s,\n' % (self.Type,))
        if self.URI is not None:
            showIndent(outfile, level)
            outfile.write('URI = %s,\n' % (self.URI,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Transforms is not None:
            showIndent(outfile, level)
            outfile.write('Transforms=model_.Transforms(\n')
            self.Transforms.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Type')
        if value is not None:
            self.Type = value
        value = attrs.get('URI')
        if value is not None:
            self.URI = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'Transforms': 
            obj_ = TransformsType.factory()
            obj_.build(child_)
            self.set_Transforms(obj_)
# end class RetrievalMethodType


class X509DataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X509IssuerSerial=None, X509SKI=None, X509SubjectName=None, X509Certificate=None, X509CRL=None):
        self.X509IssuerSerial = X509IssuerSerial
        self.X509SKI = X509SKI
        self.X509SubjectName = X509SubjectName
        self.X509Certificate = X509Certificate
        self.X509CRL = X509CRL
    def factory(*args_, **kwargs_):
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509IssuerSerial(self): return self.X509IssuerSerial
    def set_X509IssuerSerial(self, X509IssuerSerial): self.X509IssuerSerial = X509IssuerSerial
    def get_X509SKI(self): return self.X509SKI
    def set_X509SKI(self, X509SKI): self.X509SKI = X509SKI
    def get_X509SubjectName(self): return self.X509SubjectName
    def set_X509SubjectName(self, X509SubjectName): self.X509SubjectName = X509SubjectName
    def get_X509Certificate(self): return self.X509Certificate
    def set_X509Certificate(self, X509Certificate): self.X509Certificate = X509Certificate
    def get_X509CRL(self): return self.X509CRL
    def set_X509CRL(self, X509CRL): self.X509CRL = X509CRL
    def export(self, outfile, level, namespace_='win-def:', name_='X509DataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='X509DataType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='X509DataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='X509DataType'):
        if self.X509IssuerSerial:
            self.X509IssuerSerial.export(outfile, level, namespace_, name_='X509IssuerSerial', )
        if self.X509SKI is not None:
            showIndent(outfile, level)
            outfile.write('<%sX509SKI>%s</%sX509SKI>\n' % (namespace_, self.format_string(quote_xml(self.X509SKI).encode(ExternalEncoding), input_name='X509SKI'), namespace_))
        if self.X509SubjectName is not None:
            showIndent(outfile, level)
            outfile.write('<%sX509SubjectName>%s</%sX509SubjectName>\n' % (namespace_, self.format_string(quote_xml(self.X509SubjectName).encode(ExternalEncoding), input_name='X509SubjectName'), namespace_))
        if self.X509Certificate is not None:
            showIndent(outfile, level)
            outfile.write('<%sX509Certificate>%s</%sX509Certificate>\n' % (namespace_, self.format_string(quote_xml(self.X509Certificate).encode(ExternalEncoding), input_name='X509Certificate'), namespace_))
        if self.X509CRL is not None:
            showIndent(outfile, level)
            outfile.write('<%sX509CRL>%s</%sX509CRL>\n' % (namespace_, self.format_string(quote_xml(self.X509CRL).encode(ExternalEncoding), input_name='X509CRL'), namespace_))
    def hasContent_(self):
        if (
            self.X509IssuerSerial is not None or
            self.X509SKI is not None or
            self.X509SubjectName is not None or
            self.X509Certificate is not None or
            self.X509CRL is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='X509DataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.X509IssuerSerial is not None:
            showIndent(outfile, level)
            outfile.write('X509IssuerSerial=model_.X509IssuerSerialType(\n')
            self.X509IssuerSerial.exportLiteral(outfile, level, name_='X509IssuerSerial')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.X509SKI is not None:
            showIndent(outfile, level)
            outfile.write('X509SKI=%s,\n' % quote_python(self.X509SKI).encode(ExternalEncoding))
        if self.X509SubjectName is not None:
            showIndent(outfile, level)
            outfile.write('X509SubjectName=%s,\n' % quote_python(self.X509SubjectName).encode(ExternalEncoding))
        if self.X509Certificate is not None:
            showIndent(outfile, level)
            outfile.write('X509Certificate=%s,\n' % quote_python(self.X509Certificate).encode(ExternalEncoding))
        if self.X509CRL is not None:
            showIndent(outfile, level)
            outfile.write('X509CRL=%s,\n' % quote_python(self.X509CRL).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'X509IssuerSerial': 
            obj_ = X509IssuerSerialType.factory()
            obj_.build(child_)
            self.set_X509IssuerSerial(obj_)
        elif nodeName_ == 'X509SKI':
            X509SKI_ = child_.text
            self.X509SKI = X509SKI_
        elif nodeName_ == 'X509SubjectName':
            X509SubjectName_ = child_.text
            self.X509SubjectName = X509SubjectName_
        elif nodeName_ == 'X509Certificate':
            X509Certificate_ = child_.text
            self.X509Certificate = X509Certificate_
        elif nodeName_ == 'X509CRL':
            X509CRL_ = child_.text
            self.X509CRL = X509CRL_
# end class X509DataType


class X509IssuerSerialType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X509IssuerName=None, X509SerialNumber=None):
        self.X509IssuerName = X509IssuerName
        self.X509SerialNumber = X509SerialNumber
    def factory(*args_, **kwargs_):
        if X509IssuerSerialType.subclass:
            return X509IssuerSerialType.subclass(*args_, **kwargs_)
        else:
            return X509IssuerSerialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509IssuerName(self): return self.X509IssuerName
    def set_X509IssuerName(self, X509IssuerName): self.X509IssuerName = X509IssuerName
    def get_X509SerialNumber(self): return self.X509SerialNumber
    def set_X509SerialNumber(self, X509SerialNumber): self.X509SerialNumber = X509SerialNumber
    def export(self, outfile, level, namespace_='win-def:', name_='X509IssuerSerialType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='X509IssuerSerialType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='X509IssuerSerialType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='X509IssuerSerialType'):
        if self.X509IssuerName is not None:
            showIndent(outfile, level)
            outfile.write('<%sX509IssuerName>%s</%sX509IssuerName>\n' % (namespace_, self.format_string(quote_xml(self.X509IssuerName).encode(ExternalEncoding), input_name='X509IssuerName'), namespace_))
        if self.X509SerialNumber is not None:
            showIndent(outfile, level)
            outfile.write('<%sX509SerialNumber>%s</%sX509SerialNumber>\n' % (namespace_, self.format_string(quote_xml(self.X509SerialNumber).encode(ExternalEncoding), input_name='X509SerialNumber'), namespace_))
    def hasContent_(self):
        if (
            self.X509IssuerName is not None or
            self.X509SerialNumber is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='X509IssuerSerialType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.X509IssuerName is not None:
            showIndent(outfile, level)
            outfile.write('X509IssuerName=%s,\n' % quote_python(self.X509IssuerName).encode(ExternalEncoding))
        if self.X509SerialNumber is not None:
            showIndent(outfile, level)
            outfile.write('X509SerialNumber=%s,\n' % quote_python(self.X509SerialNumber).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'X509IssuerName':
            X509IssuerName_ = child_.text
            self.X509IssuerName = X509IssuerName_
        elif nodeName_ == 'X509SerialNumber':
            X509SerialNumber_ = child_.text
            self.X509SerialNumber = X509SerialNumber_
# end class X509IssuerSerialType


class PGPDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PGPKeyID=None, PGPKeyPacket=None):
        self.PGPKeyID = PGPKeyID
        self.PGPKeyPacket = PGPKeyPacket
        self.PGPKeyPacket = PGPKeyPacket
    def factory(*args_, **kwargs_):
        if PGPDataType.subclass:
            return PGPDataType.subclass(*args_, **kwargs_)
        else:
            return PGPDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PGPKeyID(self): return self.PGPKeyID
    def set_PGPKeyID(self, PGPKeyID): self.PGPKeyID = PGPKeyID
    def get_PGPKeyPacket(self): return self.PGPKeyPacket
    def set_PGPKeyPacket(self, PGPKeyPacket): self.PGPKeyPacket = PGPKeyPacket
    def get_PGPKeyPacket(self): return self.PGPKeyPacket
    def set_PGPKeyPacket(self, PGPKeyPacket): self.PGPKeyPacket = PGPKeyPacket
    def export(self, outfile, level, namespace_='win-def:', name_='PGPDataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='PGPDataType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='PGPDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='PGPDataType'):
        if self.PGPKeyID is not None:
            showIndent(outfile, level)
            outfile.write('<%sPGPKeyID>%s</%sPGPKeyID>\n' % (namespace_, self.format_string(quote_xml(self.PGPKeyID).encode(ExternalEncoding), input_name='PGPKeyID'), namespace_))
        if self.PGPKeyPacket is not None:
            showIndent(outfile, level)
            outfile.write('<%sPGPKeyPacket>%s</%sPGPKeyPacket>\n' % (namespace_, self.format_string(quote_xml(self.PGPKeyPacket).encode(ExternalEncoding), input_name='PGPKeyPacket'), namespace_))
        if self.PGPKeyPacket is not None:
            showIndent(outfile, level)
            outfile.write('<%sPGPKeyPacket>%s</%sPGPKeyPacket>\n' % (namespace_, self.format_string(quote_xml(self.PGPKeyPacket).encode(ExternalEncoding), input_name='PGPKeyPacket'), namespace_))
    def hasContent_(self):
        if (
            self.PGPKeyID is not None or
            self.PGPKeyPacket is not None or
            self.PGPKeyPacket is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PGPDataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PGPKeyID is not None:
            showIndent(outfile, level)
            outfile.write('PGPKeyID=%s,\n' % quote_python(self.PGPKeyID).encode(ExternalEncoding))
        if self.PGPKeyPacket is not None:
            showIndent(outfile, level)
            outfile.write('PGPKeyPacket=%s,\n' % quote_python(self.PGPKeyPacket).encode(ExternalEncoding))
        if self.PGPKeyPacket is not None:
            showIndent(outfile, level)
            outfile.write('PGPKeyPacket=%s,\n' % quote_python(self.PGPKeyPacket).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'PGPKeyID':
            PGPKeyID_ = child_.text
            self.PGPKeyID = PGPKeyID_
        elif nodeName_ == 'PGPKeyPacket':
            PGPKeyPacket_ = child_.text
            self.PGPKeyPacket = PGPKeyPacket_
        elif nodeName_ == 'PGPKeyPacket':
            PGPKeyPacket_ = child_.text
            self.PGPKeyPacket = PGPKeyPacket_
# end class PGPDataType


class SPKIDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SPKISexp=None):
        self.SPKISexp = SPKISexp
    def factory(*args_, **kwargs_):
        if SPKIDataType.subclass:
            return SPKIDataType.subclass(*args_, **kwargs_)
        else:
            return SPKIDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SPKISexp(self): return self.SPKISexp
    def set_SPKISexp(self, SPKISexp): self.SPKISexp = SPKISexp
    def export(self, outfile, level, namespace_='win-def:', name_='SPKIDataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SPKIDataType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SPKIDataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='SPKIDataType'):
        if self.SPKISexp is not None:
            showIndent(outfile, level)
            outfile.write('<%sSPKISexp>%s</%sSPKISexp>\n' % (namespace_, self.format_string(quote_xml(self.SPKISexp).encode(ExternalEncoding), input_name='SPKISexp'), namespace_))
    def hasContent_(self):
        if (
            self.SPKISexp is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SPKIDataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SPKISexp is not None:
            showIndent(outfile, level)
            outfile.write('SPKISexp=%s,\n' % quote_python(self.SPKISexp).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'SPKISexp':
            SPKISexp_ = child_.text
            self.SPKISexp = SPKISexp_
# end class SPKIDataType


class ObjectType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, comment=None, deprecated=None, version=None, id=None,  ):
        self.comment = _cast(None, comment)
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.deprecated = deprecated
    def factory(*args_, **kwargs_):
        if ObjectType.subclass:
            return ObjectType.subclass(*args_, **kwargs_)
        else:
            return ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def export(self, outfile, level, namespace_='win-def:', name_='ObjectType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ObjectType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='ObjectType'):
        if self.version is not None:
            outfile.write(' version=%s' % (quote_attrib(self.version), ))
        if self.id is not None:
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.deprecated is not None:
            outfile.write(' deprecated=%s' % (quote_attrib(self.deprecated), ))
        if self.comment is not None:
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='ObjectType'):
    def hasContent_(self):
        if (
            self.version
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %s,\n' % (self.version,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.deprecated is not None:
            showIndent(outfile, level)
            outfile.write('deprecated = %s,\n' % (self.deprecated,))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('version')
        if value is not None:
            self.version = value
        value = attrs.get('id')
        if value is not None:
            self.id = value
        value = attrs.get('deprecated')
        if value is not None:
            self.deprecated = value
        value = attrs.get('comment')
        if value is not None:
            self.comment = value
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class ObjectType


class ManifestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, Reference=None):
        self.Id = _cast(None, Id)
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if ManifestType.subclass:
            return ManifestType.subclass(*args_, **kwargs_)
        else:
            return ManifestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference(self, index, value): self.Reference[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def export(self, outfile, level, namespace_='win-def:', name_='ManifestType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ManifestType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='ManifestType'):
        if self.Id is not None:
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='ManifestType'):
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference')
    def hasContent_(self):
        if (
            self.Reference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ManifestType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id = %s,\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.Reference(\n')
            Reference_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Id')
        if value is not None:
            self.Id = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'Reference': 
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
# end class ManifestType


class SignaturePropertiesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignatureProperty=None):
        self.Id = _cast(None, Id)
        if SignatureProperty is None:
            self.SignatureProperty = []
        else:
            self.SignatureProperty = SignatureProperty
    def factory(*args_, **kwargs_):
        if SignaturePropertiesType.subclass:
            return SignaturePropertiesType.subclass(*args_, **kwargs_)
        else:
            return SignaturePropertiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SignatureProperty(self): return self.SignatureProperty
    def set_SignatureProperty(self, SignatureProperty): self.SignatureProperty = SignatureProperty
    def add_SignatureProperty(self, value): self.SignatureProperty.append(value)
    def insert_SignatureProperty(self, index, value): self.SignatureProperty[index] = value
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def export(self, outfile, level, namespace_='win-def:', name_='SignaturePropertiesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SignaturePropertiesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SignaturePropertiesType'):
        if self.Id is not None:
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='SignaturePropertiesType'):
        for SignatureProperty_ in self.SignatureProperty:
            SignatureProperty_.export(outfile, level, namespace_, name_='SignatureProperty')
    def hasContent_(self):
        if (
            self.SignatureProperty
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SignaturePropertiesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id = %s,\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SignatureProperty=[\n')
        level += 1
        for SignatureProperty_ in self.SignatureProperty:
            showIndent(outfile, level)
            outfile.write('model_.SignatureProperty(\n')
            SignatureProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Id')
        if value is not None:
            self.Id = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'SignatureProperty': 
            obj_ = SignaturePropertyType.factory()
            obj_.build(child_)
            self.SignatureProperty.append(obj_)
# end class SignaturePropertiesType


class SignaturePropertyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Target=None, Id=None, valueOf_=None, mixedclass_=None, content_=None):
        self.Target = _cast(None, Target)
        self.Id = _cast(None, Id)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SignaturePropertyType.subclass:
            return SignaturePropertyType.subclass(*args_, **kwargs_)
        else:
            return SignaturePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Target(self): return self.Target
    def set_Target(self, Target): self.Target = Target
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='SignaturePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SignaturePropertyType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SignaturePropertyType'):
        outfile.write(' Target=%s' % (quote_attrib(self.Target), ))
        if self.Id is not None:
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='SignaturePropertyType'):
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SignaturePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.Target is not None:
            showIndent(outfile, level)
            outfile.write('Target = %s,\n' % (self.Target,))
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id = %s,\n' % (self.Id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('Target')
        if value is not None:
            self.Target = value
        value = attrs.get('Id')
        if value is not None:
            self.Id = value
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class SignaturePropertyType


class DSAKeyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, P=None, Q=None, G=None, Y=None, J=None, Seed=None, PgenCounter=None):
        self.P = P
        self.Q = Q
        self.G = G
        self.Y = Y
        self.J = J
        self.Seed = Seed
        self.PgenCounter = PgenCounter
    def factory(*args_, **kwargs_):
        if DSAKeyValueType.subclass:
            return DSAKeyValueType.subclass(*args_, **kwargs_)
        else:
            return DSAKeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_P(self): return self.P
    def set_P(self, P): self.P = P
    def validate_P(self, value):
        # validate type P
        pass
    def get_Q(self): return self.Q
    def set_Q(self, Q): self.Q = Q
    def validate_Q(self, value):
        # validate type Q
        pass
    def get_G(self): return self.G
    def set_G(self, G): self.G = G
    def validate_G(self, value):
        # validate type G
        pass
    def get_Y(self): return self.Y
    def set_Y(self, Y): self.Y = Y
    def validate_Y(self, value):
        # validate type Y
        pass
    def get_J(self): return self.J
    def set_J(self, J): self.J = J
    def validate_J(self, value):
        # validate type J
        pass
    def get_Seed(self): return self.Seed
    def set_Seed(self, Seed): self.Seed = Seed
    def validate_Seed(self, value):
        # validate type Seed
        pass
    def get_PgenCounter(self): return self.PgenCounter
    def set_PgenCounter(self, PgenCounter): self.PgenCounter = PgenCounter
    def validate_PgenCounter(self, value):
        # validate type PgenCounter
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='DSAKeyValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DSAKeyValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='DSAKeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='DSAKeyValueType'):
        if self.P is not None:
            showIndent(outfile, level)
            outfile.write('<%sP>%s</%sP>\n' % (namespace_, self.format_string(quote_xml(self.P).encode(ExternalEncoding), input_name='P'), namespace_))
        if self.Q is not None:
            showIndent(outfile, level)
            outfile.write('<%sQ>%s</%sQ>\n' % (namespace_, self.format_string(quote_xml(self.Q).encode(ExternalEncoding), input_name='Q'), namespace_))
        if self.G is not None:
            showIndent(outfile, level)
            outfile.write('<%sG>%s</%sG>\n' % (namespace_, self.format_string(quote_xml(self.G).encode(ExternalEncoding), input_name='G'), namespace_))
        if self.Y is not None:
            showIndent(outfile, level)
            outfile.write('<%sY>%s</%sY>\n' % (namespace_, self.format_string(quote_xml(self.Y).encode(ExternalEncoding), input_name='Y'), namespace_))
        if self.J is not None:
            showIndent(outfile, level)
            outfile.write('<%sJ>%s</%sJ>\n' % (namespace_, self.format_string(quote_xml(self.J).encode(ExternalEncoding), input_name='J'), namespace_))
        if self.Seed is not None:
            showIndent(outfile, level)
            outfile.write('<%sSeed>%s</%sSeed>\n' % (namespace_, self.format_string(quote_xml(self.Seed).encode(ExternalEncoding), input_name='Seed'), namespace_))
        if self.PgenCounter is not None:
            showIndent(outfile, level)
            outfile.write('<%sPgenCounter>%s</%sPgenCounter>\n' % (namespace_, self.format_string(quote_xml(self.PgenCounter).encode(ExternalEncoding), input_name='PgenCounter'), namespace_))
    def hasContent_(self):
        if (
            self.P is not None or
            self.Q is not None or
            self.G is not None or
            self.Y is not None or
            self.J is not None or
            self.Seed is not None or
            self.PgenCounter is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DSAKeyValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.P is not None:
            showIndent(outfile, level)
            outfile.write('P=%s,\n' % quote_python(self.P).encode(ExternalEncoding))
        if self.Q is not None:
            showIndent(outfile, level)
            outfile.write('Q=%s,\n' % quote_python(self.Q).encode(ExternalEncoding))
        if self.G is not None:
            showIndent(outfile, level)
            outfile.write('G=%s,\n' % quote_python(self.G).encode(ExternalEncoding))
        if self.Y is not None:
            showIndent(outfile, level)
            outfile.write('Y=%s,\n' % quote_python(self.Y).encode(ExternalEncoding))
        if self.J is not None:
            showIndent(outfile, level)
            outfile.write('J=%s,\n' % quote_python(self.J).encode(ExternalEncoding))
        if self.Seed is not None:
            showIndent(outfile, level)
            outfile.write('Seed=%s,\n' % quote_python(self.Seed).encode(ExternalEncoding))
        if self.PgenCounter is not None:
            showIndent(outfile, level)
            outfile.write('PgenCounter=%s,\n' % quote_python(self.PgenCounter).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'P':
            P_ = child_.text
            self.P = P_
            self.validate_P(self.P)    # validate type P
        elif nodeName_ == 'Q':
            Q_ = child_.text
            self.Q = Q_
            self.validate_Q(self.Q)    # validate type Q
        elif nodeName_ == 'G':
            G_ = child_.text
            self.G = G_
            self.validate_G(self.G)    # validate type G
        elif nodeName_ == 'Y':
            Y_ = child_.text
            self.Y = Y_
            self.validate_Y(self.Y)    # validate type Y
        elif nodeName_ == 'J':
            J_ = child_.text
            self.J = J_
            self.validate_J(self.J)    # validate type J
        elif nodeName_ == 'Seed':
            Seed_ = child_.text
            self.Seed = Seed_
            self.validate_Seed(self.Seed)    # validate type Seed
        elif nodeName_ == 'PgenCounter':
            PgenCounter_ = child_.text
            self.PgenCounter = PgenCounter_
            self.validate_PgenCounter(self.PgenCounter)    # validate type PgenCounter
# end class DSAKeyValueType


class RSAKeyValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Modulus=None, Exponent=None):
        self.Modulus = Modulus
        self.Exponent = Exponent
    def factory(*args_, **kwargs_):
        if RSAKeyValueType.subclass:
            return RSAKeyValueType.subclass(*args_, **kwargs_)
        else:
            return RSAKeyValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Modulus(self): return self.Modulus
    def set_Modulus(self, Modulus): self.Modulus = Modulus
    def validate_Modulus(self, value):
        # validate type Modulus
        pass
    def get_Exponent(self): return self.Exponent
    def set_Exponent(self, Exponent): self.Exponent = Exponent
    def validate_Exponent(self, value):
        # validate type Exponent
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='RSAKeyValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RSAKeyValueType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='RSAKeyValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='RSAKeyValueType'):
        if self.Modulus is not None:
            showIndent(outfile, level)
            outfile.write('<%sModulus>%s</%sModulus>\n' % (namespace_, self.format_string(quote_xml(self.Modulus).encode(ExternalEncoding), input_name='Modulus'), namespace_))
        if self.Exponent is not None:
            showIndent(outfile, level)
            outfile.write('<%sExponent>%s</%sExponent>\n' % (namespace_, self.format_string(quote_xml(self.Exponent).encode(ExternalEncoding), input_name='Exponent'), namespace_))
    def hasContent_(self):
        if (
            self.Modulus is not None or
            self.Exponent is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RSAKeyValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Modulus is not None:
            showIndent(outfile, level)
            outfile.write('Modulus=%s,\n' % quote_python(self.Modulus).encode(ExternalEncoding))
        if self.Exponent is not None:
            showIndent(outfile, level)
            outfile.write('Exponent=%s,\n' % quote_python(self.Exponent).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'Modulus':
            Modulus_ = child_.text
            self.Modulus = Modulus_
            self.validate_Modulus(self.Modulus)    # validate type Modulus
        elif nodeName_ == 'Exponent':
            Exponent_ = child_.text
            self.Exponent = Exponent_
            self.validate_Exponent(self.Exponent)    # validate type Exponent
# end class RSAKeyValueType


class oval_definitions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, generator=None, definitions=None, tests=None, objects=None, states=None, variables=None, Signature=None):
        self.generator = generator
        self.definitions = definitions
        self.tests = tests
        self.objects = objects
        self.states = states
        self.variables = variables
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if oval_definitions.subclass:
            return oval_definitions.subclass(*args_, **kwargs_)
        else:
            return oval_definitions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_generator(self): return self.generator
    def set_generator(self, generator): self.generator = generator
    def get_definitions(self): return self.definitions
    def set_definitions(self, definitions): self.definitions = definitions
    def get_tests(self): return self.tests
    def set_tests(self, tests): self.tests = tests
    def get_objects(self): return self.objects
    def set_objects(self, objects): self.objects = objects
    def get_states(self): return self.states
    def set_states(self, states): self.states = states
    def get_variables(self): return self.variables
    def set_variables(self, variables): self.variables = variables
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def export(self, outfile, level, namespace_='', name_='oval_definitions', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='oval_definitions')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='oval_definitions'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='oval_definitions'):
        if self.generator:
            self.generator.export(outfile, level, namespace_, name_='generator', )
        if self.definitions:
            self.definitions.export(outfile, level, namespace_, name_='definitions')
        if self.tests:
            self.tests.export(outfile, level, namespace_, name_='tests')
        if self.objects:
            self.objects.export(outfile, level, namespace_, name_='objects')
        if self.states:
            self.states.export(outfile, level, namespace_, name_='states')
        if self.variables:
            self.variables.export(outfile, level, namespace_, name_='variables')
        if self.Signature:
            self.Signature.export(outfile, level, namespace_, name_='Signature')
    def hasContent_(self):
        if (
            self.generator is not None or
            self.definitions is not None or
            self.tests is not None or
            self.objects is not None or
            self.states is not None or
            self.variables is not None or
            self.Signature is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='oval_definitions'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('generator=model_.GeneratorType(\n')
            self.generator.exportLiteral(outfile, level, name_='generator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.definitions is not None:
            showIndent(outfile, level)
            outfile.write('definitions=model_.DefinitionsType(\n')
            self.definitions.exportLiteral(outfile, level, name_='definitions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tests is not None:
            showIndent(outfile, level)
            outfile.write('tests=model_.TestsType(\n')
            self.tests.exportLiteral(outfile, level, name_='tests')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.objects is not None:
            showIndent(outfile, level)
            outfile.write('objects=model_.ObjectsType(\n')
            self.objects.exportLiteral(outfile, level, name_='objects')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.states is not None:
            showIndent(outfile, level)
            outfile.write('states=model_.StatesType(\n')
            self.states.exportLiteral(outfile, level, name_='states')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variables is not None:
            showIndent(outfile, level)
            outfile.write('variables=model_.VariablesType(\n')
            self.variables.exportLiteral(outfile, level, name_='variables')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'generator': 
            obj_ = GeneratorType.factory()
            obj_.build(child_)
            self.set_generator(obj_)
        elif nodeName_ == 'definitions': 
            obj_ = DefinitionsType.factory()
            obj_.build(child_)
            self.set_definitions(obj_)
        elif nodeName_ == 'tests': 
            obj_ = TestsType.factory()
            obj_.build(child_)
            self.set_tests(obj_)
        elif nodeName_ == 'objects': 
            obj_ = ObjectsType.factory()
            obj_.build(child_)
            self.set_objects(obj_)
        elif nodeName_ == 'states': 
            obj_ = StatesType.factory()
            obj_.build(child_)
            self.set_states(obj_)
        elif nodeName_ == 'variables': 
            obj_ = VariablesType.factory()
            obj_.build(child_)
            self.set_variables(obj_)
        elif nodeName_ == 'Signature': 
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
# end class oval_definitions


class DefinitionsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, definition=None):
        if definition is None:
            self.definition = []
        else:
            self.definition = definition
    def factory(*args_, **kwargs_):
        if DefinitionsType.subclass:
            return DefinitionsType.subclass(*args_, **kwargs_)
        else:
            return DefinitionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_definition(self): return self.definition
    def set_definition(self, definition): self.definition = definition
    def add_definition(self, value): self.definition.append(value)
    def insert_definition(self, index, value): self.definition[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='DefinitionsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DefinitionsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='DefinitionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='DefinitionsType'):
        for definition_ in self.definition:
            definition_.export(outfile, level, namespace_, name_='definition')
    def hasContent_(self):
        if (
            self.definition
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefinitionsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('definition=[\n')
        level += 1
        for definition_ in self.definition:
            showIndent(outfile, level)
            outfile.write('model_.DefinitionType(\n')
            definition_.exportLiteral(outfile, level, name_='DefinitionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'definition': 
            obj_ = DefinitionType.factory()
            obj_.build(child_)
            self.definition.append(obj_)
# end class DefinitionsType


class DefinitionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, deprecated=False, version=None, id=None, classxx=None, Signature=None, metadata=None, notes=None, criteria=None):
        self.deprecated = _cast(bool, deprecated)
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.classxx = _cast(None, classxx)
        self.Signature = Signature
        self.metadata = metadata
        self.notes = notes
        self.criteria = criteria
    def factory(*args_, **kwargs_):
        if DefinitionType.subclass:
            return DefinitionType.subclass(*args_, **kwargs_)
        else:
            return DefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_criteria(self): return self.criteria
    def set_criteria(self, criteria): self.criteria = criteria
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_class(self): return self.classxx
    def set_class(self, classxx): self.classxx = classxx
    def export(self, outfile, level, namespace_='win-def:', name_='DefinitionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='DefinitionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='DefinitionType'):
        if self.deprecated is not None:
            outfile.write(' deprecated="%s"' % self.format_boolean(str_lower(str(self.deprecated)), input_name='deprecated'))
        outfile.write(' version="%s"' % self.format_integer(self.version, input_name='version'))
        outfile.write(' id=%s' % (quote_attrib(self.id), ))
        outfile.write(' class=%s' % (quote_attrib(self.classxx), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='DefinitionType'):
        if self.Signature:
            self.Signature.export(outfile, level, namespace_, name_='Signature')
        if self.metadata:
            self.metadata.export(outfile, level, namespace_, name_='metadata', )
        if self.notes:
            self.notes.export(outfile, level, namespace_, name_='notes')
        if self.criteria:
            self.criteria.export(outfile, level, namespace_, name_='criteria')
    def hasContent_(self):
        if (
            self.Signature is not None or
            self.metadata is not None or
            self.notes is not None or
            self.criteria is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DefinitionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.deprecated is not None:
            showIndent(outfile, level)
            outfile.write('deprecated = %s,\n' % (self.deprecated,))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %d,\n' % (self.version,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.classxx is not None:
            showIndent(outfile, level)
            outfile.write('classxx = %s,\n' % (self.classxx,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.MetadataType(\n')
            self.metadata.exportLiteral(outfile, level, name_='metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=model_.NotesType(\n')
            self.notes.exportLiteral(outfile, level, name_='notes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.criteria is not None:
            showIndent(outfile, level)
            outfile.write('criteria=model_.CriteriaType(\n')
            self.criteria.exportLiteral(outfile, level, name_='criteria')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('deprecated')
        if value is not None:
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('version')
        if value is not None:
            try:
                self.version = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.version < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = attrs.get('id')
        if value is not None:
            self.id = value
        value = attrs.get('class')
        if value is not None:
            self.classxx = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'Signature': 
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
        elif nodeName_ == 'metadata': 
            obj_ = MetadataType.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
        elif nodeName_ == 'notes': 
            obj_ = NotesType.factory()
            obj_.build(child_)
            self.set_notes(obj_)
        elif nodeName_ == 'criteria': 
            obj_ = CriteriaType.factory()
            obj_.build(child_)
            self.set_criteria(obj_)
# end class DefinitionType


class MetadataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, title=None, affected=None, reference=None, description=None):
        self.title = title
        if affected is None:
            self.affected = []
        else:
            self.affected = affected
        if reference is None:
            self.reference = []
        else:
            self.reference = reference
        self.description = description
    def factory(*args_, **kwargs_):
        if MetadataType.subclass:
            return MetadataType.subclass(*args_, **kwargs_)
        else:
            return MetadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_affected(self): return self.affected
    def set_affected(self, affected): self.affected = affected
    def add_affected(self, value): self.affected.append(value)
    def insert_affected(self, index, value): self.affected[index] = value
    def get_reference(self): return self.reference
    def set_reference(self, reference): self.reference = reference
    def add_reference(self, value): self.reference.append(value)
    def insert_reference(self, index, value): self.reference[index] = value
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def export(self, outfile, level, namespace_='win-def:', name_='MetadataType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='MetadataType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='MetadataType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='MetadataType'):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('<%stitle>%s</%stitle>\n' % (namespace_, self.format_string(quote_xml(self.title).encode(ExternalEncoding), input_name='title'), namespace_))
        for affected_ in self.affected:
            affected_.export(outfile, level, namespace_, name_='affected')
        for reference_ in self.reference:
            reference_.export(outfile, level, namespace_, name_='reference')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('<%sdescription>%s</%sdescription>\n' % (namespace_, self.format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_))
    def hasContent_(self):
        if (
            self.title is not None or
            self.affected or
            self.reference or
            self.description is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MetadataType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=%s,\n' % quote_python(self.title).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('affected=[\n')
        level += 1
        for affected_ in self.affected:
            showIndent(outfile, level)
            outfile.write('model_.AffectedType(\n')
            affected_.exportLiteral(outfile, level, name_='AffectedType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('reference=[\n')
        level += 1
        for reference_ in self.reference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            reference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'title':
            title_ = child_.text
            self.title = title_
        elif nodeName_ == 'affected': 
            obj_ = AffectedType.factory()
            obj_.build(child_)
            self.affected.append(obj_)
        elif nodeName_ == 'reference': 
            obj_ = ReferenceType.factory()
            obj_.build(child_)
            self.reference.append(obj_)
        elif nodeName_ == 'description':
            description_ = child_.text
            self.description = description_
# end class MetadataType


class AffectedType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, family=None, platform=None, product=None):
        self.family = _cast(None, family)
        if platform is None:
            self.platform = []
        else:
            self.platform = platform
        if product is None:
            self.product = []
        else:
            self.product = product
    def factory(*args_, **kwargs_):
        if AffectedType.subclass:
            return AffectedType.subclass(*args_, **kwargs_)
        else:
            return AffectedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_platform(self): return self.platform
    def set_platform(self, platform): self.platform = platform
    def add_platform(self, value): self.platform.append(value)
    def insert_platform(self, index, value): self.platform[index] = value
    def get_product(self): return self.product
    def set_product(self, product): self.product = product
    def add_product(self, value): self.product.append(value)
    def insert_product(self, index, value): self.product[index] = value
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def export(self, outfile, level, namespace_='win-def:', name_='AffectedType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AffectedType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='AffectedType'):
        outfile.write(' family=%s' % (quote_attrib(self.family), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='AffectedType'):
        for platform_ in self.platform:
            showIndent(outfile, level)
            outfile.write('<%splatform>%s</%splatform>\n' % (namespace_, self.format_string(quote_xml(platform_).encode(ExternalEncoding), input_name='platform'), namespace_))
        for product_ in self.product:
            showIndent(outfile, level)
            outfile.write('<%sproduct>%s</%sproduct>\n' % (namespace_, self.format_string(quote_xml(product_).encode(ExternalEncoding), input_name='product'), namespace_))
    def hasContent_(self):
        if (
            self.platform or
            self.product
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AffectedType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.family is not None:
            showIndent(outfile, level)
            outfile.write('family = %s,\n' % (self.family,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('platform=[\n')
        level += 1
        for platform_ in self.platform:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(platform_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('product=[\n')
        level += 1
        for product_ in self.product:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(product_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('family')
        if value is not None:
            self.family = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'platform':
            platform_ = child_.text
            self.platform.append(platform_)
        elif nodeName_ == 'product':
            product_ = child_.text
            self.product.append(product_)
# end class AffectedType


class NotesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, note=None):
        if note is None:
            self.note = []
        else:
            self.note = note
    def factory(*args_, **kwargs_):
        if NotesType.subclass:
            return NotesType.subclass(*args_, **kwargs_)
        else:
            return NotesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_note(self): return self.note
    def set_note(self, note): self.note = note
    def add_note(self, value): self.note.append(value)
    def insert_note(self, index, value): self.note[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='NotesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='NotesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='NotesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='NotesType'):
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('<%snote>%s</%snote>\n' % (namespace_, self.format_string(quote_xml(note_).encode(ExternalEncoding), input_name='note'), namespace_))
    def hasContent_(self):
        if (
            self.note
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NotesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('note=[\n')
        level += 1
        for note_ in self.note:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(note_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'note':
            note_ = child_.text
            self.note.append(note_)
# end class NotesType


class CriteriaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, operator='AND', negate=False, comment=None, criteria=None, criterion=None, extend_definition=None):
        self.operator = _cast(None, operator)
        self.negate = _cast(bool, negate)
        self.comment = _cast(None, comment)
        if criteria is None:
            self.criteria = []
        else:
            self.criteria = criteria
        if criterion is None:
            self.criterion = []
        else:
            self.criterion = criterion
        if extend_definition is None:
            self.extend_definition = []
        else:
            self.extend_definition = extend_definition
    def factory(*args_, **kwargs_):
        if CriteriaType.subclass:
            return CriteriaType.subclass(*args_, **kwargs_)
        else:
            return CriteriaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_criteria(self): return self.criteria
    def set_criteria(self, criteria): self.criteria = criteria
    def add_criteria(self, value): self.criteria.append(value)
    def insert_criteria(self, index, value): self.criteria[index] = value
    def get_criterion(self): return self.criterion
    def set_criterion(self, criterion): self.criterion = criterion
    def add_criterion(self, value): self.criterion.append(value)
    def insert_criterion(self, index, value): self.criterion[index] = value
    def get_extend_definition(self): return self.extend_definition
    def set_extend_definition(self, extend_definition): self.extend_definition = extend_definition
    def add_extend_definition(self, value): self.extend_definition.append(value)
    def insert_extend_definition(self, index, value): self.extend_definition[index] = value
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def get_negate(self): return self.negate
    def set_negate(self, negate): self.negate = negate
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def export(self, outfile, level, namespace_='win-def:', name_='CriteriaType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CriteriaType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='CriteriaType'):
        if self.operator is not None:
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.negate is not None:
            outfile.write(' negate="%s"' % self.format_boolean(str_lower(str(self.negate)), input_name='negate'))
        if self.comment is not None:
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='CriteriaType'):
        for criteria_ in self.criteria:
            criteria_.export(outfile, level, namespace_, name_='criteria')
        for criterion_ in self.criterion:
            criterion_.export(outfile, level, namespace_, name_='criterion')
        for extend_definition_ in self.extend_definition:
            extend_definition_.export(outfile, level, namespace_, name_='extend_definition')
    def hasContent_(self):
        if (
            self.criteria or
            self.criterion or
            self.extend_definition
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CriteriaType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.operator is not None:
            showIndent(outfile, level)
            outfile.write('operator = %s,\n' % (self.operator,))
        if self.negate is not None:
            showIndent(outfile, level)
            outfile.write('negate = %s,\n' % (self.negate,))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('criteria=[\n')
        level += 1
        for criteria_ in self.criteria:
            showIndent(outfile, level)
            outfile.write('model_.CriteriaType(\n')
            criteria_.exportLiteral(outfile, level, name_='CriteriaType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('criterion=[\n')
        level += 1
        for criterion_ in self.criterion:
            showIndent(outfile, level)
            outfile.write('model_.CriterionType(\n')
            criterion_.exportLiteral(outfile, level, name_='CriterionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('extend_definition=[\n')
        level += 1
        for extend_definition_ in self.extend_definition:
            showIndent(outfile, level)
            outfile.write('model_.ExtendDefinitionType(\n')
            extend_definition_.exportLiteral(outfile, level, name_='ExtendDefinitionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('operator')
        if value is not None:
            self.operator = value
        value = attrs.get('negate')
        if value is not None:
            if value in ('true', '1'):
                self.negate = True
            elif value in ('false', '0'):
                self.negate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('comment')
        if value is not None:
            self.comment = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'criteria': 
            obj_ = CriteriaType.factory()
            obj_.build(child_)
            self.criteria.append(obj_)
        elif nodeName_ == 'criterion': 
            obj_ = CriterionType.factory()
            obj_.build(child_)
            self.criterion.append(obj_)
        elif nodeName_ == 'extend_definition': 
            obj_ = ExtendDefinitionType.factory()
            obj_.build(child_)
            self.extend_definition.append(obj_)
# end class CriteriaType


class CriterionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, negate=False, comment=None, test_ref=None, valueOf_=None):
        self.negate = _cast(bool, negate)
        self.comment = _cast(None, comment)
        self.test_ref = _cast(None, test_ref)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CriterionType.subclass:
            return CriterionType.subclass(*args_, **kwargs_)
        else:
            return CriterionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_negate(self): return self.negate
    def set_negate(self, negate): self.negate = negate
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_test_ref(self): return self.test_ref
    def set_test_ref(self, test_ref): self.test_ref = test_ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='CriterionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='CriterionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='CriterionType'):
        if self.negate is not None:
            outfile.write(' negate="%s"' % self.format_boolean(str_lower(str(self.negate)), input_name='negate'))
        if self.comment is not None:
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        outfile.write(' test_ref=%s' % (quote_attrib(self.test_ref), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='CriterionType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CriterionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.negate is not None:
            showIndent(outfile, level)
            outfile.write('negate = %s,\n' % (self.negate,))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.test_ref is not None:
            showIndent(outfile, level)
            outfile.write('test_ref = %s,\n' % (self.test_ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('negate')
        if value is not None:
            if value in ('true', '1'):
                self.negate = True
            elif value in ('false', '0'):
                self.negate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('comment')
        if value is not None:
            self.comment = value
        value = attrs.get('test_ref')
        if value is not None:
            self.test_ref = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class CriterionType


class ExtendDefinitionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, negate=False, comment=None, definition_ref=None, valueOf_=None):
        self.negate = _cast(bool, negate)
        self.comment = _cast(None, comment)
        self.definition_ref = _cast(None, definition_ref)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ExtendDefinitionType.subclass:
            return ExtendDefinitionType.subclass(*args_, **kwargs_)
        else:
            return ExtendDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_negate(self): return self.negate
    def set_negate(self, negate): self.negate = negate
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_definition_ref(self): return self.definition_ref
    def set_definition_ref(self, definition_ref): self.definition_ref = definition_ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='ExtendDefinitionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ExtendDefinitionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='ExtendDefinitionType'):
        if self.negate is not None:
            outfile.write(' negate="%s"' % self.format_boolean(str_lower(str(self.negate)), input_name='negate'))
        if self.comment is not None:
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        outfile.write(' definition_ref=%s' % (quote_attrib(self.definition_ref), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='ExtendDefinitionType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExtendDefinitionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.negate is not None:
            showIndent(outfile, level)
            outfile.write('negate = %s,\n' % (self.negate,))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.definition_ref is not None:
            showIndent(outfile, level)
            outfile.write('definition_ref = %s,\n' % (self.definition_ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('negate')
        if value is not None:
            if value in ('true', '1'):
                self.negate = True
            elif value in ('false', '0'):
                self.negate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('comment')
        if value is not None:
            self.comment = value
        value = attrs.get('definition_ref')
        if value is not None:
            self.definition_ref = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class ExtendDefinitionType


class TestsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, test=None):
        if test is None:
            self.test = []
        else:
            self.test = test
    def factory(*args_, **kwargs_):
        if TestsType.subclass:
            return TestsType.subclass(*args_, **kwargs_)
        else:
            return TestsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_test(self): return self.test
    def set_test(self, test): self.test = test
    def add_test(self, value): self.test.append(value)
    def insert_test(self, index, value): self.test[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='TestsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TestsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='TestsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='TestsType'):
        for test_ in self.get_test():
            test_.export(outfile, level, namespace_, name_='test')
    def hasContent_(self):
        if (
            self.test
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TestsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('test=[\n')
        level += 1
        for test_ in self.test:
            showIndent(outfile, level)
            outfile.write('model_.test(\n')
            test_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'test': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <test> element')
            self.test.append(obj_)
# end class TestsType


class TestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, comment=None, state_operator='AND', deprecated=False, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None):
        self.comment = _cast(None, comment)
        self.state_operator = _cast(None, state_operator)
        self.deprecated = _cast(bool, deprecated)
        self.check = _cast(None, check)
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.check_existence = _cast(None, check_existence)
        self.Signature = Signature
        self.notes = notes
    def factory(*args_, **kwargs_):
        if TestType.subclass:
            return TestType.subclass(*args_, **kwargs_)
        else:
            return TestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_state_operator(self): return self.state_operator
    def set_state_operator(self, state_operator): self.state_operator = state_operator
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def get_check(self): return self.check
    def set_check(self, check): self.check = check
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_check_existence(self): return self.check_existence
    def set_check_existence(self, check_existence): self.check_existence = check_existence
    def export(self, outfile, level, namespace_='win-def:', name_='TestType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TestType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='TestType'):
        outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        if self.state_operator is not None:
            outfile.write(' state_operator=%s' % (quote_attrib(self.state_operator), ))
        if self.deprecated is not None:
            outfile.write(' deprecated="%s"' % self.format_boolean(str_lower(str(self.deprecated)), input_name='deprecated'))
        outfile.write(' check=%s' % (quote_attrib(self.check), ))
        outfile.write(' version="%s"' % self.format_integer(self.version, input_name='version'))
        outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.check_existence is not None:
            outfile.write(' check_existence=%s' % (quote_attrib(self.check_existence), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='TestType'):
        if self.Signature:
            self.Signature.export(outfile, level, namespace_, name_='Signature')
        if self.notes:
            self.notes.export(outfile, level, namespace_, name_='notes')
    def hasContent_(self):
        if (
            self.Signature is not None or
            self.notes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TestType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.state_operator is not None:
            showIndent(outfile, level)
            outfile.write('state_operator = %s,\n' % (self.state_operator,))
        if self.deprecated is not None:
            showIndent(outfile, level)
            outfile.write('deprecated = %s,\n' % (self.deprecated,))
        if self.check is not None:
            showIndent(outfile, level)
            outfile.write('check = %s,\n' % (self.check,))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %d,\n' % (self.version,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.check_existence is not None:
            showIndent(outfile, level)
            outfile.write('check_existence = %s,\n' % (self.check_existence,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=model_.NotesType(\n')
            self.notes.exportLiteral(outfile, level, name_='notes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('comment')
        if value is not None:
            self.comment = value
        value = attrs.get('state_operator')
        if value is not None:
            self.state_operator = value
        value = attrs.get('deprecated')
        if value is not None:
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('check')
        if value is not None:
            self.check = value
        value = attrs.get('version')
        if value is not None:
            try:
                self.version = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.version < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = attrs.get('id')
        if value is not None:
            self.id = value
        value = attrs.get('check_existence')
        if value is not None:
            self.check_existence = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'Signature': 
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
        elif nodeName_ == 'notes': 
            obj_ = NotesType.factory()
            obj_.build(child_)
            self.set_notes(obj_)
# end class TestType


class ObjectRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, object_ref=None, valueOf_=None):
        self.object_ref = _cast(None, object_ref)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ObjectRefType.subclass:
            return ObjectRefType.subclass(*args_, **kwargs_)
        else:
            return ObjectRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_ref(self): return self.object_ref
    def set_object_ref(self, object_ref): self.object_ref = object_ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='ObjectRefType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ObjectRefType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='ObjectRefType'):
        outfile.write(' object_ref=%s' % (quote_attrib(self.object_ref), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='ObjectRefType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectRefType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.object_ref is not None:
            showIndent(outfile, level)
            outfile.write('object_ref = %s,\n' % (self.object_ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('object_ref')
        if value is not None:
            self.object_ref = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class ObjectRefType


class StateRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, state_ref=None, valueOf_=None):
        self.state_ref = _cast(None, state_ref)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if StateRefType.subclass:
            return StateRefType.subclass(*args_, **kwargs_)
        else:
            return StateRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state_ref(self): return self.state_ref
    def set_state_ref(self, state_ref): self.state_ref = state_ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='StateRefType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StateRefType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='StateRefType'):
        outfile.write(' state_ref=%s' % (quote_attrib(self.state_ref), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='StateRefType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StateRefType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.state_ref is not None:
            showIndent(outfile, level)
            outfile.write('state_ref = %s,\n' % (self.state_ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('state_ref')
        if value is not None:
            self.state_ref = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class StateRefType


class ObjectsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, object=None):
        if object is None:
            self.object = []
        else:
            self.object = object
    def factory(*args_, **kwargs_):
        if ObjectsType.subclass:
            return ObjectsType.subclass(*args_, **kwargs_)
        else:
            return ObjectsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def add_object(self, value): self.object.append(value)
    def insert_object(self, index, value): self.object[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='ObjectsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ObjectsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='ObjectsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='ObjectsType'):
        for object_ in self.get_object():
            object_.export(outfile, level, namespace_, name_='object')
    def hasContent_(self):
        if (
            self.object
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('object=[\n')
        level += 1
        for object_ in self.object:
            showIndent(outfile, level)
            outfile.write('model_.object(\n')
            object_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <object> element')
            self.object.append(obj_)
# end class ObjectsType


class set(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, set_operator='UNION', set=None, object_reference=None, filter=None):
        self.set_operator = _cast(None, set_operator)
        if set is None:
            self.set = []
        else:
            self.set = set
        if object_reference is None:
            self.object_reference = []
        else:
            self.object_reference = object_reference
        if filter is None:
            self.filter = []
        else:
            self.filter = filter
    def factory(*args_, **kwargs_):
        if set.subclass:
            return set.subclass(*args_, **kwargs_)
        else:
            return set(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def add_set(self, value): self.set.append(value)
    def insert_set(self, index, value): self.set[index] = value
    def get_object_reference(self): return self.object_reference
    def set_object_reference(self, object_reference): self.object_reference = object_reference
    def add_object_reference(self, value): self.object_reference.append(value)
    def insert_object_reference(self, index, value): self.object_reference[index] = value
    def validate_object_reference(self, value):
        # validate type object_reference
        pass
    def get_filter(self): return self.filter
    def set_filter(self, filter): self.filter = filter
    def add_filter(self, value): self.filter.append(value)
    def insert_filter(self, index, value): self.filter[index] = value
    def get_set_operator(self): return self.set_operator
    def set_set_operator(self, set_operator): self.set_operator = set_operator
    def export(self, outfile, level, namespace_='win-def:', name_='set', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='set')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='set'):
        if self.set_operator is not None:
            outfile.write(' set_operator=%s' % (quote_attrib(self.set_operator), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='set'):
        for set_ in self.set:
            set_.export(outfile, level, namespace_, name_='set')
        for object_reference_ in self.object_reference:
            showIndent(outfile, level)
            outfile.write('<%sobject_reference>%s</%sobject_reference>\n' % (namespace_, self.format_string(quote_xml(object_reference_).encode(ExternalEncoding), input_name='object_reference'), namespace_))
        for filter_ in self.filter:
            filter_.export(outfile, level, namespace_, name_='filter')
    def hasContent_(self):
        if (
            self.set or
            self.object_reference or
            self.filter
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='set'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.set_operator is not None:
            showIndent(outfile, level)
            outfile.write('set_operator = %s,\n' % (self.set_operator,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('set=[\n')
        level += 1
        for set_ in self.set:
            showIndent(outfile, level)
            outfile.write('model_.set(\n')
            set_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('object_reference=[\n')
        level += 1
        for object_reference_ in self.object_reference:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(object_reference_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('filter=[\n')
        level += 1
        for filter_ in self.filter:
            showIndent(outfile, level)
            outfile.write('model_.FilterType(\n')
            filter_.exportLiteral(outfile, level, name_='FilterType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('set_operator')
        if value is not None:
            self.set_operator = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set.append(obj_)
        elif nodeName_ == 'object_reference':
            object_reference_ = child_.text
            self.object_reference.append(object_reference_)
            self.validate_object_reference(self.object_reference)    # validate type object_reference
        elif nodeName_ == 'filter': 
            obj_ = FilterType.factory()
            obj_.build(child_)
            self.filter.append(obj_)
# end class set


class FilterType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, action='exclude', valueOf_=None):
        self.action = _cast(None, action)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FilterType.subclass:
            return FilterType.subclass(*args_, **kwargs_)
        else:
            return FilterType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='FilterType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='FilterType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='FilterType'):
        if self.action is not None:
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='FilterType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FilterType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.action is not None:
            showIndent(outfile, level)
            outfile.write('action = %s,\n' % (self.action,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('action')
        if value is not None:
            self.action = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class FilterType


class StatesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, state=None):
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if StatesType.subclass:
            return StatesType.subclass(*args_, **kwargs_)
        else:
            return StatesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='StatesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StatesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='StatesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='StatesType'):
        for state_ in self.get_state():
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.state
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StatesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.state(\n')
            state_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'state': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <state> element')
            self.state.append(obj_)
# end class StatesType


class StateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=False, Signature=None, notes=None):
        self.operator = _cast(None, operator)
        self.comment = _cast(None, comment)
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.deprecated = _cast(bool, deprecated)
        self.Signature = Signature
        self.notes = notes
    def factory(*args_, **kwargs_):
        if StateType.subclass:
            return StateType.subclass(*args_, **kwargs_)
        else:
            return StateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_notes(self): return self.notes
    def set_notes(self, notes): self.notes = notes
    def get_operator(self): return self.operator
    def set_operator(self, operator): self.operator = operator
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def export(self, outfile, level, namespace_='win-def:', name_='StateType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='StateType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='StateType'):
        if self.operator is not None:
            outfile.write(' operator=%s' % (quote_attrib(self.operator), ))
        if self.comment is not None:
            outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        outfile.write(' version="%s"' % self.format_integer(self.version, input_name='version'))
        outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.deprecated is not None:
            outfile.write(' deprecated="%s"' % self.format_boolean(str_lower(str(self.deprecated)), input_name='deprecated'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='StateType'):
        if self.Signature:
            self.Signature.export(outfile, level, namespace_, name_='Signature')
        if self.notes:
            self.notes.export(outfile, level, namespace_, name_='notes')
    def hasContent_(self):
        if (
            self.Signature is not None or
            self.notes is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StateType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.operator is not None:
            showIndent(outfile, level)
            outfile.write('operator = %s,\n' % (self.operator,))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %d,\n' % (self.version,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.deprecated is not None:
            showIndent(outfile, level)
            outfile.write('deprecated = %s,\n' % (self.deprecated,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.notes is not None:
            showIndent(outfile, level)
            outfile.write('notes=model_.NotesType(\n')
            self.notes.exportLiteral(outfile, level, name_='notes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('operator')
        if value is not None:
            self.operator = value
        value = attrs.get('comment')
        if value is not None:
            self.comment = value
        value = attrs.get('version')
        if value is not None:
            try:
                self.version = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.version < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = attrs.get('id')
        if value is not None:
            self.id = value
        value = attrs.get('deprecated')
        if value is not None:
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'Signature': 
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
        elif nodeName_ == 'notes': 
            obj_ = NotesType.factory()
            obj_.build(child_)
            self.set_notes(obj_)
# end class StateType


class VariablesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, variable=None):
        if variable is None:
            self.variable = []
        else:
            self.variable = variable
    def factory(*args_, **kwargs_):
        if VariablesType.subclass:
            return VariablesType.subclass(*args_, **kwargs_)
        else:
            return VariablesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_variable(self): return self.variable
    def set_variable(self, variable): self.variable = variable
    def add_variable(self, value): self.variable.append(value)
    def insert_variable(self, index, value): self.variable[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='VariablesType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='VariablesType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='VariablesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='VariablesType'):
        for variable_ in self.get_variable():
            variable_.export(outfile, level, namespace_, name_='variable')
    def hasContent_(self):
        if (
            self.variable
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariablesType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('variable=[\n')
        level += 1
        for variable_ in self.variable:
            showIndent(outfile, level)
            outfile.write('model_.variable(\n')
            variable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'variable': 
            type_name = child_.attrib.get('type')
            if type_name is not None:
                class_ = globals()[type_name]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <variable> element')
            self.variable.append(obj_)
# end class VariablesType


class VariableType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, datatype=None, comment=None, version=None, id=None, deprecated=False, Signature=None):
        self.datatype = _cast(None, datatype)
        self.comment = _cast(None, comment)
        self.version = _cast(int, version)
        self.id = _cast(None, id)
        self.deprecated = _cast(bool, deprecated)
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if VariableType.subclass:
            return VariableType.subclass(*args_, **kwargs_)
        else:
            return VariableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Signature(self): return self.Signature
    def set_Signature(self, Signature): self.Signature = Signature
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_comment(self): return self.comment
    def set_comment(self, comment): self.comment = comment
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_deprecated(self): return self.deprecated
    def set_deprecated(self, deprecated): self.deprecated = deprecated
    def export(self, outfile, level, namespace_='win-def:', name_='VariableType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='VariableType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='VariableType'):
        outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        outfile.write(' comment=%s' % (quote_attrib(self.comment), ))
        outfile.write(' version="%s"' % self.format_integer(self.version, input_name='version'))
        outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.deprecated is not None:
            outfile.write(' deprecated="%s"' % self.format_boolean(str_lower(str(self.deprecated)), input_name='deprecated'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='VariableType'):
        if self.Signature:
            self.Signature.export(outfile, level, namespace_, name_='Signature')
    def hasContent_(self):
        if (
            self.Signature is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariableType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.datatype is not None:
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        if self.comment is not None:
            showIndent(outfile, level)
            outfile.write('comment = %s,\n' % (self.comment,))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = %d,\n' % (self.version,))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = %s,\n' % (self.id,))
        if self.deprecated is not None:
            showIndent(outfile, level)
            outfile.write('deprecated = %s,\n' % (self.deprecated,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Signature is not None:
            showIndent(outfile, level)
            outfile.write('Signature=model_.Signature(\n')
            self.Signature.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('datatype')
        if value is not None:
            self.datatype = value
        value = attrs.get('comment')
        if value is not None:
            self.comment = value
        value = attrs.get('version')
        if value is not None:
            try:
                self.version = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.version < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = attrs.get('id')
        if value is not None:
            self.id = value
        value = attrs.get('deprecated')
        if value is not None:
            if value in ('true', '1'):
                self.deprecated = True
            elif value in ('false', '0'):
                self.deprecated = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'Signature': 
            obj_ = SignatureType.factory()
            obj_.build(child_)
            self.set_Signature(obj_)
# end class VariableType


class external_variable(VariableType):
    subclass = None
    superclass = VariableType
    def __init__(self, datatype=None, comment=None, version=None, id=None, deprecated=False, Signature=None, possible_value=None, possible_restriction=None):
        super(external_variable, self).__init__(datatype, comment, version, id, deprecated, Signature, )
        if possible_value is None:
            self.possible_value = []
        else:
            self.possible_value = possible_value
        if possible_restriction is None:
            self.possible_restriction = []
        else:
            self.possible_restriction = possible_restriction
    def factory(*args_, **kwargs_):
        if external_variable.subclass:
            return external_variable.subclass(*args_, **kwargs_)
        else:
            return external_variable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_possible_value(self): return self.possible_value
    def set_possible_value(self, possible_value): self.possible_value = possible_value
    def add_possible_value(self, value): self.possible_value.append(value)
    def insert_possible_value(self, index, value): self.possible_value[index] = value
    def get_possible_restriction(self): return self.possible_restriction
    def set_possible_restriction(self, possible_restriction): self.possible_restriction = possible_restriction
    def add_possible_restriction(self, value): self.possible_restriction.append(value)
    def insert_possible_restriction(self, index, value): self.possible_restriction[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='external_variable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='external_variable')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="external_variable"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='external_variable'):
        super(external_variable, self).exportAttributes(outfile, level, namespace_, name_='external_variable')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='external_variable'):
        super(external_variable, self).exportChildren(outfile, level, namespace_, name_)
        for possible_value_ in self.possible_value:
            possible_value_.export(outfile, level, namespace_, name_='possible_value')
        for possible_restriction_ in self.possible_restriction:
            possible_restriction_.export(outfile, level, namespace_, name_='possible_restriction')
    def hasContent_(self):
        if (
            self.possible_value or
            self.possible_restriction or
            super(external_variable, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='external_variable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(external_variable, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(external_variable, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('possible_value=[\n')
        level += 1
        for possible_value_ in self.possible_value:
            showIndent(outfile, level)
            outfile.write('model_.PossibleValueType(\n')
            possible_value_.exportLiteral(outfile, level, name_='PossibleValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('possible_restriction=[\n')
        level += 1
        for possible_restriction_ in self.possible_restriction:
            showIndent(outfile, level)
            outfile.write('model_.PossibleRestrictionType(\n')
            possible_restriction_.exportLiteral(outfile, level, name_='PossibleRestrictionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(external_variable, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'possible_value': 
            obj_ = PossibleValueType.factory()
            obj_.build(child_)
            self.possible_value.append(obj_)
        elif nodeName_ == 'possible_restriction': 
            obj_ = PossibleRestrictionType.factory()
            obj_.build(child_)
            self.possible_restriction.append(obj_)
        super(external_variable, self).buildChildren(child_, nodeName_)
# end class external_variable


class PossibleValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hint=None, valueOf_=None):
        self.hint = _cast(None, hint)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PossibleValueType.subclass:
            return PossibleValueType.subclass(*args_, **kwargs_)
        else:
            return PossibleValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hint(self): return self.hint
    def set_hint(self, hint): self.hint = hint
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='PossibleValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='PossibleValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='PossibleValueType'):
        outfile.write(' hint=%s' % (self.format_string(quote_attrib(self.hint).encode(ExternalEncoding), input_name='hint'), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='PossibleValueType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PossibleValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.hint is not None:
            showIndent(outfile, level)
            outfile.write('hint = "%s",\n' % (self.hint,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('hint')
        if value is not None:
            self.hint = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class PossibleValueType


class PossibleRestrictionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hint=None, restriction=None):
        self.hint = _cast(None, hint)
        if restriction is None:
            self.restriction = []
        else:
            self.restriction = restriction
    def factory(*args_, **kwargs_):
        if PossibleRestrictionType.subclass:
            return PossibleRestrictionType.subclass(*args_, **kwargs_)
        else:
            return PossibleRestrictionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_restriction(self): return self.restriction
    def set_restriction(self, restriction): self.restriction = restriction
    def add_restriction(self, value): self.restriction.append(value)
    def insert_restriction(self, index, value): self.restriction[index] = value
    def get_hint(self): return self.hint
    def set_hint(self, hint): self.hint = hint
    def export(self, outfile, level, namespace_='win-def:', name_='PossibleRestrictionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='PossibleRestrictionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='PossibleRestrictionType'):
        outfile.write(' hint=%s' % (self.format_string(quote_attrib(self.hint).encode(ExternalEncoding), input_name='hint'), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='PossibleRestrictionType'):
        for restriction_ in self.restriction:
            restriction_.export(outfile, level, namespace_, name_='restriction')
    def hasContent_(self):
        if (
            self.restriction
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PossibleRestrictionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.hint is not None:
            showIndent(outfile, level)
            outfile.write('hint = "%s",\n' % (self.hint,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('restriction=[\n')
        level += 1
        for restriction_ in self.restriction:
            showIndent(outfile, level)
            outfile.write('model_.RestrictionType(\n')
            restriction_.exportLiteral(outfile, level, name_='RestrictionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('hint')
        if value is not None:
            self.hint = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'restriction': 
            obj_ = RestrictionType.factory()
            obj_.build(child_)
            self.restriction.append(obj_)
# end class PossibleRestrictionType


class RestrictionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, operation=None, valueOf_=None):
        self.operation = _cast(None, operation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RestrictionType.subclass:
            return RestrictionType.subclass(*args_, **kwargs_)
        else:
            return RestrictionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='RestrictionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RestrictionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='RestrictionType'):
        outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='RestrictionType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RestrictionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.operation is not None:
            showIndent(outfile, level)
            outfile.write('operation = %s,\n' % (self.operation,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('operation')
        if value is not None:
            self.operation = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class RestrictionType


class constant_variable(VariableType):
    subclass = None
    superclass = VariableType
    def __init__(self, datatype=None, comment=None, version=None, id=None, deprecated=False, Signature=None, value=None):
        super(constant_variable, self).__init__(datatype, comment, version, id, deprecated, Signature, )
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if constant_variable.subclass:
            return constant_variable.subclass(*args_, **kwargs_)
        else:
            return constant_variable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='constant_variable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='constant_variable')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="constant_variable"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='constant_variable'):
        super(constant_variable, self).exportAttributes(outfile, level, namespace_, name_='constant_variable')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='constant_variable'):
        super(constant_variable, self).exportChildren(outfile, level, namespace_, name_)
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value')
    def hasContent_(self):
        if (
            self.value or
            super(constant_variable, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='constant_variable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(constant_variable, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(constant_variable, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.ValueType(\n')
            value_.exportLiteral(outfile, level, name_='ValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(constant_variable, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'value': 
            obj_ = ValueType.factory()
            obj_.build(child_)
            self.value.append(obj_)
        super(constant_variable, self).buildChildren(child_, nodeName_)
# end class constant_variable


class ValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ValueType.subclass:
            return ValueType.subclass(*args_, **kwargs_)
        else:
            return ValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='ValueType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='ValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='ValueType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ValueType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        pass
# end class ValueType


class local_variable(VariableType):
    subclass = None
    superclass = VariableType
    def __init__(self, datatype=None, comment=None, version=None, id=None, deprecated=False, Signature=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None):
        super(local_variable, self).__init__(datatype, comment, version, id, deprecated, Signature, )
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
    def factory(*args_, **kwargs_):
        if local_variable.subclass:
            return local_variable.subclass(*args_, **kwargs_)
        else:
            return local_variable(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def export(self, outfile, level, namespace_='win-def:', name_='local_variable', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='local_variable')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="local_variable"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='local_variable'):
        super(local_variable, self).exportAttributes(outfile, level, namespace_, name_='local_variable')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='local_variable'):
        super(local_variable, self).exportChildren(outfile, level, namespace_, name_)
        if self.object_component:
            self.object_component.export(outfile, level, namespace_, name_='object_component', )
        if self.variable_component:
            self.variable_component.export(outfile, level, namespace_, name_='variable_component', )
        if self.literal_component:
            self.literal_component.export(outfile, level, namespace_, name_='literal_component', )
        if self.arithmetic:
            self.arithmetic.export(outfile, level, namespace_, name_='arithmetic', )
        if self.begin:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.concat:
            self.concat.export(outfile, level, namespace_, name_='concat', )
        if self.end:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.escape_regex:
            self.escape_regex.export(outfile, level, namespace_, name_='escape_regex', )
        if self.split:
            self.split.export(outfile, level, namespace_, name_='split', )
        if self.substring:
            self.substring.export(outfile, level, namespace_, name_='substring', )
        if self.time_difference:
            self.time_difference.export(outfile, level, namespace_, name_='time_difference', )
        if self.regex_capture:
            self.regex_capture.export(outfile, level, namespace_, name_='regex_capture', )
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None or
            super(local_variable, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='local_variable'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(local_variable, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(local_variable, self).exportLiteralChildren(outfile, level, name_)
        if self.object_component is not None:
            showIndent(outfile, level)
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable_component is not None:
            showIndent(outfile, level)
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.literal_component is not None:
            showIndent(outfile, level)
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.arithmetic is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concat is not None:
            showIndent(outfile, level)
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.escape_regex is not None:
            showIndent(outfile, level)
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.split is not None:
            showIndent(outfile, level)
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.substring is not None:
            showIndent(outfile, level)
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.time_difference is not None:
            showIndent(outfile, level)
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.regex_capture is not None:
            showIndent(outfile, level)
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(local_variable, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object_component': 
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component': 
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component': 
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic': 
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin': 
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat': 
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end': 
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex': 
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split': 
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring': 
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference': 
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture': 
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
        super(local_variable, self).buildChildren(child_, nodeName_)
# end class local_variable


class LiteralComponentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, datatype='string', valueOf_=None):
        self.datatype = _cast(None, datatype)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LiteralComponentType.subclass:
            return LiteralComponentType.subclass(*args_, **kwargs_)
        else:
            return LiteralComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='LiteralComponentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='LiteralComponentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='LiteralComponentType'):
        if self.datatype is not None:
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='LiteralComponentType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LiteralComponentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.datatype is not None:
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('datatype')
        if value is not None:
            self.datatype = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class LiteralComponentType


class ObjectComponentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, record_field=None, object_ref=None, item_field=None, valueOf_=None):
        self.record_field = _cast(None, record_field)
        self.object_ref = _cast(None, object_ref)
        self.item_field = _cast(None, item_field)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ObjectComponentType.subclass:
            return ObjectComponentType.subclass(*args_, **kwargs_)
        else:
            return ObjectComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_record_field(self): return self.record_field
    def set_record_field(self, record_field): self.record_field = record_field
    def get_object_ref(self): return self.object_ref
    def set_object_ref(self, object_ref): self.object_ref = object_ref
    def get_item_field(self): return self.item_field
    def set_item_field(self, item_field): self.item_field = item_field
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='ObjectComponentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ObjectComponentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='ObjectComponentType'):
        if self.record_field is not None:
            outfile.write(' record_field=%s' % (quote_attrib(self.record_field), ))
        outfile.write(' object_ref=%s' % (quote_attrib(self.object_ref), ))
        outfile.write(' item_field=%s' % (quote_attrib(self.item_field), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='ObjectComponentType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ObjectComponentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.record_field is not None:
            showIndent(outfile, level)
            outfile.write('record_field = %s,\n' % (self.record_field,))
        if self.object_ref is not None:
            showIndent(outfile, level)
            outfile.write('object_ref = %s,\n' % (self.object_ref,))
        if self.item_field is not None:
            showIndent(outfile, level)
            outfile.write('item_field = %s,\n' % (self.item_field,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('record_field')
        if value is not None:
            self.record_field = value
        value = attrs.get('object_ref')
        if value is not None:
            self.object_ref = value
        value = attrs.get('item_field')
        if value is not None:
            self.item_field = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class ObjectComponentType


class VariableComponentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, var_ref=None, valueOf_=None):
        self.var_ref = _cast(None, var_ref)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if VariableComponentType.subclass:
            return VariableComponentType.subclass(*args_, **kwargs_)
        else:
            return VariableComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_var_ref(self): return self.var_ref
    def set_var_ref(self, var_ref): self.var_ref = var_ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='VariableComponentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='VariableComponentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='VariableComponentType'):
        outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='VariableComponentType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariableComponentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.var_ref is not None:
            showIndent(outfile, level)
            outfile.write('var_ref = %s,\n' % (self.var_ref,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('var_ref')
        if value is not None:
            self.var_ref = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class VariableComponentType


class ArithmeticFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, arithmetic_operation=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None):
        self.arithmetic_operation = _cast(None, arithmetic_operation)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
    def factory(*args_, **kwargs_):
        if ArithmeticFunctionType.subclass:
            return ArithmeticFunctionType.subclass(*args_, **kwargs_)
        else:
            return ArithmeticFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_arithmetic_operation(self): return self.arithmetic_operation
    def set_arithmetic_operation(self, arithmetic_operation): self.arithmetic_operation = arithmetic_operation
    def export(self, outfile, level, namespace_='win-def:', name_='ArithmeticFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ArithmeticFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='ArithmeticFunctionType'):
        outfile.write(' arithmetic_operation=%s' % (quote_attrib(self.arithmetic_operation), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='ArithmeticFunctionType'):
        if self.object_component:
            self.object_component.export(outfile, level, namespace_, name_='object_component', )
        if self.variable_component:
            self.variable_component.export(outfile, level, namespace_, name_='variable_component', )
        if self.literal_component:
            self.literal_component.export(outfile, level, namespace_, name_='literal_component', )
        if self.arithmetic:
            self.arithmetic.export(outfile, level, namespace_, name_='arithmetic', )
        if self.begin:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.concat:
            self.concat.export(outfile, level, namespace_, name_='concat', )
        if self.end:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.escape_regex:
            self.escape_regex.export(outfile, level, namespace_, name_='escape_regex', )
        if self.split:
            self.split.export(outfile, level, namespace_, name_='split', )
        if self.substring:
            self.substring.export(outfile, level, namespace_, name_='substring', )
        if self.time_difference:
            self.time_difference.export(outfile, level, namespace_, name_='time_difference', )
        if self.regex_capture:
            self.regex_capture.export(outfile, level, namespace_, name_='regex_capture', )
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArithmeticFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.arithmetic_operation is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic_operation = %s,\n' % (self.arithmetic_operation,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            showIndent(outfile, level)
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable_component is not None:
            showIndent(outfile, level)
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.literal_component is not None:
            showIndent(outfile, level)
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.arithmetic is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concat is not None:
            showIndent(outfile, level)
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.escape_regex is not None:
            showIndent(outfile, level)
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.split is not None:
            showIndent(outfile, level)
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.substring is not None:
            showIndent(outfile, level)
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.time_difference is not None:
            showIndent(outfile, level)
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.regex_capture is not None:
            showIndent(outfile, level)
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('arithmetic_operation')
        if value is not None:
            self.arithmetic_operation = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object_component': 
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component': 
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component': 
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic': 
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin': 
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat': 
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end': 
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex': 
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split': 
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring': 
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference': 
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture': 
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
# end class ArithmeticFunctionType


class BeginFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, character=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None):
        self.character = _cast(None, character)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
    def factory(*args_, **kwargs_):
        if BeginFunctionType.subclass:
            return BeginFunctionType.subclass(*args_, **kwargs_)
        else:
            return BeginFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_character(self): return self.character
    def set_character(self, character): self.character = character
    def export(self, outfile, level, namespace_='win-def:', name_='BeginFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='BeginFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='BeginFunctionType'):
        outfile.write(' character=%s' % (self.format_string(quote_attrib(self.character).encode(ExternalEncoding), input_name='character'), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='BeginFunctionType'):
        if self.object_component:
            self.object_component.export(outfile, level, namespace_, name_='object_component', )
        if self.variable_component:
            self.variable_component.export(outfile, level, namespace_, name_='variable_component', )
        if self.literal_component:
            self.literal_component.export(outfile, level, namespace_, name_='literal_component', )
        if self.arithmetic:
            self.arithmetic.export(outfile, level, namespace_, name_='arithmetic', )
        if self.begin:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.concat:
            self.concat.export(outfile, level, namespace_, name_='concat', )
        if self.end:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.escape_regex:
            self.escape_regex.export(outfile, level, namespace_, name_='escape_regex', )
        if self.split:
            self.split.export(outfile, level, namespace_, name_='split', )
        if self.substring:
            self.substring.export(outfile, level, namespace_, name_='substring', )
        if self.time_difference:
            self.time_difference.export(outfile, level, namespace_, name_='time_difference', )
        if self.regex_capture:
            self.regex_capture.export(outfile, level, namespace_, name_='regex_capture', )
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BeginFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.character is not None:
            showIndent(outfile, level)
            outfile.write('character = "%s",\n' % (self.character,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            showIndent(outfile, level)
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable_component is not None:
            showIndent(outfile, level)
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.literal_component is not None:
            showIndent(outfile, level)
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.arithmetic is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concat is not None:
            showIndent(outfile, level)
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.escape_regex is not None:
            showIndent(outfile, level)
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.split is not None:
            showIndent(outfile, level)
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.substring is not None:
            showIndent(outfile, level)
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.time_difference is not None:
            showIndent(outfile, level)
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.regex_capture is not None:
            showIndent(outfile, level)
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('character')
        if value is not None:
            self.character = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object_component': 
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component': 
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component': 
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic': 
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin': 
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat': 
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end': 
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex': 
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split': 
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring': 
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference': 
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture': 
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
# end class BeginFunctionType


class ConcatFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None):
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
    def factory(*args_, **kwargs_):
        if ConcatFunctionType.subclass:
            return ConcatFunctionType.subclass(*args_, **kwargs_)
        else:
            return ConcatFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def export(self, outfile, level, namespace_='win-def:', name_='ConcatFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ConcatFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='ConcatFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='ConcatFunctionType'):
        if self.object_component:
            self.object_component.export(outfile, level, namespace_, name_='object_component', )
        if self.variable_component:
            self.variable_component.export(outfile, level, namespace_, name_='variable_component', )
        if self.literal_component:
            self.literal_component.export(outfile, level, namespace_, name_='literal_component', )
        if self.arithmetic:
            self.arithmetic.export(outfile, level, namespace_, name_='arithmetic', )
        if self.begin:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.concat:
            self.concat.export(outfile, level, namespace_, name_='concat', )
        if self.end:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.escape_regex:
            self.escape_regex.export(outfile, level, namespace_, name_='escape_regex', )
        if self.split:
            self.split.export(outfile, level, namespace_, name_='split', )
        if self.substring:
            self.substring.export(outfile, level, namespace_, name_='substring', )
        if self.time_difference:
            self.time_difference.export(outfile, level, namespace_, name_='time_difference', )
        if self.regex_capture:
            self.regex_capture.export(outfile, level, namespace_, name_='regex_capture', )
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConcatFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            showIndent(outfile, level)
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable_component is not None:
            showIndent(outfile, level)
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.literal_component is not None:
            showIndent(outfile, level)
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.arithmetic is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concat is not None:
            showIndent(outfile, level)
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.escape_regex is not None:
            showIndent(outfile, level)
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.split is not None:
            showIndent(outfile, level)
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.substring is not None:
            showIndent(outfile, level)
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.time_difference is not None:
            showIndent(outfile, level)
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.regex_capture is not None:
            showIndent(outfile, level)
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object_component': 
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component': 
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component': 
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic': 
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin': 
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat': 
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end': 
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex': 
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split': 
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring': 
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference': 
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture': 
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
# end class ConcatFunctionType


class EndFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, character=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None):
        self.character = _cast(None, character)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
    def factory(*args_, **kwargs_):
        if EndFunctionType.subclass:
            return EndFunctionType.subclass(*args_, **kwargs_)
        else:
            return EndFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_character(self): return self.character
    def set_character(self, character): self.character = character
    def export(self, outfile, level, namespace_='win-def:', name_='EndFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EndFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EndFunctionType'):
        outfile.write(' character=%s' % (self.format_string(quote_attrib(self.character).encode(ExternalEncoding), input_name='character'), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EndFunctionType'):
        if self.object_component:
            self.object_component.export(outfile, level, namespace_, name_='object_component', )
        if self.variable_component:
            self.variable_component.export(outfile, level, namespace_, name_='variable_component', )
        if self.literal_component:
            self.literal_component.export(outfile, level, namespace_, name_='literal_component', )
        if self.arithmetic:
            self.arithmetic.export(outfile, level, namespace_, name_='arithmetic', )
        if self.begin:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.concat:
            self.concat.export(outfile, level, namespace_, name_='concat', )
        if self.end:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.escape_regex:
            self.escape_regex.export(outfile, level, namespace_, name_='escape_regex', )
        if self.split:
            self.split.export(outfile, level, namespace_, name_='split', )
        if self.substring:
            self.substring.export(outfile, level, namespace_, name_='substring', )
        if self.time_difference:
            self.time_difference.export(outfile, level, namespace_, name_='time_difference', )
        if self.regex_capture:
            self.regex_capture.export(outfile, level, namespace_, name_='regex_capture', )
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.character is not None:
            showIndent(outfile, level)
            outfile.write('character = "%s",\n' % (self.character,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            showIndent(outfile, level)
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable_component is not None:
            showIndent(outfile, level)
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.literal_component is not None:
            showIndent(outfile, level)
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.arithmetic is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concat is not None:
            showIndent(outfile, level)
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.escape_regex is not None:
            showIndent(outfile, level)
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.split is not None:
            showIndent(outfile, level)
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.substring is not None:
            showIndent(outfile, level)
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.time_difference is not None:
            showIndent(outfile, level)
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.regex_capture is not None:
            showIndent(outfile, level)
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('character')
        if value is not None:
            self.character = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object_component': 
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component': 
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component': 
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic': 
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin': 
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat': 
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end': 
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex': 
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split': 
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring': 
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference': 
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture': 
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
# end class EndFunctionType


class EscapeRegexFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None):
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
    def factory(*args_, **kwargs_):
        if EscapeRegexFunctionType.subclass:
            return EscapeRegexFunctionType.subclass(*args_, **kwargs_)
        else:
            return EscapeRegexFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def export(self, outfile, level, namespace_='win-def:', name_='EscapeRegexFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EscapeRegexFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EscapeRegexFunctionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EscapeRegexFunctionType'):
        if self.object_component:
            self.object_component.export(outfile, level, namespace_, name_='object_component', )
        if self.variable_component:
            self.variable_component.export(outfile, level, namespace_, name_='variable_component', )
        if self.literal_component:
            self.literal_component.export(outfile, level, namespace_, name_='literal_component', )
        if self.arithmetic:
            self.arithmetic.export(outfile, level, namespace_, name_='arithmetic', )
        if self.begin:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.concat:
            self.concat.export(outfile, level, namespace_, name_='concat', )
        if self.end:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.escape_regex:
            self.escape_regex.export(outfile, level, namespace_, name_='escape_regex', )
        if self.split:
            self.split.export(outfile, level, namespace_, name_='split', )
        if self.substring:
            self.substring.export(outfile, level, namespace_, name_='substring', )
        if self.time_difference:
            self.time_difference.export(outfile, level, namespace_, name_='time_difference', )
        if self.regex_capture:
            self.regex_capture.export(outfile, level, namespace_, name_='regex_capture', )
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EscapeRegexFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            showIndent(outfile, level)
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable_component is not None:
            showIndent(outfile, level)
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.literal_component is not None:
            showIndent(outfile, level)
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.arithmetic is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concat is not None:
            showIndent(outfile, level)
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.escape_regex is not None:
            showIndent(outfile, level)
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.split is not None:
            showIndent(outfile, level)
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.substring is not None:
            showIndent(outfile, level)
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.time_difference is not None:
            showIndent(outfile, level)
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.regex_capture is not None:
            showIndent(outfile, level)
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object_component': 
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component': 
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component': 
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic': 
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin': 
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat': 
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end': 
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex': 
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split': 
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring': 
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference': 
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture': 
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
# end class EscapeRegexFunctionType


class SplitFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, delimiter=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None):
        self.delimiter = _cast(None, delimiter)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
    def factory(*args_, **kwargs_):
        if SplitFunctionType.subclass:
            return SplitFunctionType.subclass(*args_, **kwargs_)
        else:
            return SplitFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_delimiter(self): return self.delimiter
    def set_delimiter(self, delimiter): self.delimiter = delimiter
    def export(self, outfile, level, namespace_='win-def:', name_='SplitFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SplitFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SplitFunctionType'):
        outfile.write(' delimiter=%s' % (self.format_string(quote_attrib(self.delimiter).encode(ExternalEncoding), input_name='delimiter'), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='SplitFunctionType'):
        if self.object_component:
            self.object_component.export(outfile, level, namespace_, name_='object_component', )
        if self.variable_component:
            self.variable_component.export(outfile, level, namespace_, name_='variable_component', )
        if self.literal_component:
            self.literal_component.export(outfile, level, namespace_, name_='literal_component', )
        if self.arithmetic:
            self.arithmetic.export(outfile, level, namespace_, name_='arithmetic', )
        if self.begin:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.concat:
            self.concat.export(outfile, level, namespace_, name_='concat', )
        if self.end:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.escape_regex:
            self.escape_regex.export(outfile, level, namespace_, name_='escape_regex', )
        if self.split:
            self.split.export(outfile, level, namespace_, name_='split', )
        if self.substring:
            self.substring.export(outfile, level, namespace_, name_='substring', )
        if self.time_difference:
            self.time_difference.export(outfile, level, namespace_, name_='time_difference', )
        if self.regex_capture:
            self.regex_capture.export(outfile, level, namespace_, name_='regex_capture', )
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SplitFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.delimiter is not None:
            showIndent(outfile, level)
            outfile.write('delimiter = "%s",\n' % (self.delimiter,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            showIndent(outfile, level)
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable_component is not None:
            showIndent(outfile, level)
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.literal_component is not None:
            showIndent(outfile, level)
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.arithmetic is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concat is not None:
            showIndent(outfile, level)
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.escape_regex is not None:
            showIndent(outfile, level)
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.split is not None:
            showIndent(outfile, level)
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.substring is not None:
            showIndent(outfile, level)
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.time_difference is not None:
            showIndent(outfile, level)
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.regex_capture is not None:
            showIndent(outfile, level)
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('delimiter')
        if value is not None:
            self.delimiter = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object_component': 
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component': 
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component': 
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic': 
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin': 
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat': 
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end': 
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex': 
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split': 
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring': 
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference': 
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture': 
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
# end class SplitFunctionType


class SubstringFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, substring_length=None, substring_start=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None):
        self.substring_length = _cast(int, substring_length)
        self.substring_start = _cast(int, substring_start)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
    def factory(*args_, **kwargs_):
        if SubstringFunctionType.subclass:
            return SubstringFunctionType.subclass(*args_, **kwargs_)
        else:
            return SubstringFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_substring_length(self): return self.substring_length
    def set_substring_length(self, substring_length): self.substring_length = substring_length
    def get_substring_start(self): return self.substring_start
    def set_substring_start(self, substring_start): self.substring_start = substring_start
    def export(self, outfile, level, namespace_='win-def:', name_='SubstringFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SubstringFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SubstringFunctionType'):
        outfile.write(' substring_length="%s"' % self.format_integer(self.substring_length, input_name='substring_length'))
        outfile.write(' substring_start="%s"' % self.format_integer(self.substring_start, input_name='substring_start'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='SubstringFunctionType'):
        if self.object_component:
            self.object_component.export(outfile, level, namespace_, name_='object_component', )
        if self.variable_component:
            self.variable_component.export(outfile, level, namespace_, name_='variable_component', )
        if self.literal_component:
            self.literal_component.export(outfile, level, namespace_, name_='literal_component', )
        if self.arithmetic:
            self.arithmetic.export(outfile, level, namespace_, name_='arithmetic', )
        if self.begin:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.concat:
            self.concat.export(outfile, level, namespace_, name_='concat', )
        if self.end:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.escape_regex:
            self.escape_regex.export(outfile, level, namespace_, name_='escape_regex', )
        if self.split:
            self.split.export(outfile, level, namespace_, name_='split', )
        if self.substring:
            self.substring.export(outfile, level, namespace_, name_='substring', )
        if self.time_difference:
            self.time_difference.export(outfile, level, namespace_, name_='time_difference', )
        if self.regex_capture:
            self.regex_capture.export(outfile, level, namespace_, name_='regex_capture', )
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubstringFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.substring_length is not None:
            showIndent(outfile, level)
            outfile.write('substring_length = %d,\n' % (self.substring_length,))
        if self.substring_start is not None:
            showIndent(outfile, level)
            outfile.write('substring_start = %d,\n' % (self.substring_start,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            showIndent(outfile, level)
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable_component is not None:
            showIndent(outfile, level)
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.literal_component is not None:
            showIndent(outfile, level)
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.arithmetic is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concat is not None:
            showIndent(outfile, level)
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.escape_regex is not None:
            showIndent(outfile, level)
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.split is not None:
            showIndent(outfile, level)
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.substring is not None:
            showIndent(outfile, level)
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.time_difference is not None:
            showIndent(outfile, level)
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.regex_capture is not None:
            showIndent(outfile, level)
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('substring_length')
        if value is not None:
            try:
                self.substring_length = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('substring_start')
        if value is not None:
            try:
                self.substring_start = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object_component': 
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component': 
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component': 
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic': 
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin': 
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat': 
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end': 
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex': 
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split': 
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring': 
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference': 
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture': 
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
# end class SubstringFunctionType


class TimeDifferenceFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, format_1='year_month_day', format_2='year_month_day', object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None):
        self.format_1 = _cast(None, format_1)
        self.format_2 = _cast(None, format_2)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
    def factory(*args_, **kwargs_):
        if TimeDifferenceFunctionType.subclass:
            return TimeDifferenceFunctionType.subclass(*args_, **kwargs_)
        else:
            return TimeDifferenceFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_format_1(self): return self.format_1
    def set_format_1(self, format_1): self.format_1 = format_1
    def get_format_2(self): return self.format_2
    def set_format_2(self, format_2): self.format_2 = format_2
    def export(self, outfile, level, namespace_='win-def:', name_='TimeDifferenceFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='TimeDifferenceFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='TimeDifferenceFunctionType'):
        if self.format_1 is not None:
            outfile.write(' format_1=%s' % (quote_attrib(self.format_1), ))
        if self.format_2 is not None:
            outfile.write(' format_2=%s' % (quote_attrib(self.format_2), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='TimeDifferenceFunctionType'):
        if self.object_component:
            self.object_component.export(outfile, level, namespace_, name_='object_component', )
        if self.variable_component:
            self.variable_component.export(outfile, level, namespace_, name_='variable_component', )
        if self.literal_component:
            self.literal_component.export(outfile, level, namespace_, name_='literal_component', )
        if self.arithmetic:
            self.arithmetic.export(outfile, level, namespace_, name_='arithmetic', )
        if self.begin:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.concat:
            self.concat.export(outfile, level, namespace_, name_='concat', )
        if self.end:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.escape_regex:
            self.escape_regex.export(outfile, level, namespace_, name_='escape_regex', )
        if self.split:
            self.split.export(outfile, level, namespace_, name_='split', )
        if self.substring:
            self.substring.export(outfile, level, namespace_, name_='substring', )
        if self.time_difference:
            self.time_difference.export(outfile, level, namespace_, name_='time_difference', )
        if self.regex_capture:
            self.regex_capture.export(outfile, level, namespace_, name_='regex_capture', )
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='TimeDifferenceFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.format_1 is not None:
            showIndent(outfile, level)
            outfile.write('format_1 = %s,\n' % (self.format_1,))
        if self.format_2 is not None:
            showIndent(outfile, level)
            outfile.write('format_2 = %s,\n' % (self.format_2,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            showIndent(outfile, level)
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable_component is not None:
            showIndent(outfile, level)
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.literal_component is not None:
            showIndent(outfile, level)
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.arithmetic is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concat is not None:
            showIndent(outfile, level)
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.escape_regex is not None:
            showIndent(outfile, level)
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.split is not None:
            showIndent(outfile, level)
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.substring is not None:
            showIndent(outfile, level)
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.time_difference is not None:
            showIndent(outfile, level)
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.regex_capture is not None:
            showIndent(outfile, level)
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('format_1')
        if value is not None:
            self.format_1 = value
        value = attrs.get('format_2')
        if value is not None:
            self.format_2 = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object_component': 
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component': 
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component': 
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic': 
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin': 
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat': 
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end': 
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex': 
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split': 
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring': 
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference': 
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture': 
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
# end class TimeDifferenceFunctionType


class RegexCaptureFunctionType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pattern=None, object_component=None, variable_component=None, literal_component=None, arithmetic=None, begin=None, concat=None, end=None, escape_regex=None, split=None, substring=None, time_difference=None, regex_capture=None):
        self.pattern = _cast(None, pattern)
        self.object_component = object_component
        self.variable_component = variable_component
        self.literal_component = literal_component
        self.arithmetic = arithmetic
        self.begin = begin
        self.concat = concat
        self.end = end
        self.escape_regex = escape_regex
        self.split = split
        self.substring = substring
        self.time_difference = time_difference
        self.regex_capture = regex_capture
    def factory(*args_, **kwargs_):
        if RegexCaptureFunctionType.subclass:
            return RegexCaptureFunctionType.subclass(*args_, **kwargs_)
        else:
            return RegexCaptureFunctionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object_component(self): return self.object_component
    def set_object_component(self, object_component): self.object_component = object_component
    def get_variable_component(self): return self.variable_component
    def set_variable_component(self, variable_component): self.variable_component = variable_component
    def get_literal_component(self): return self.literal_component
    def set_literal_component(self, literal_component): self.literal_component = literal_component
    def get_arithmetic(self): return self.arithmetic
    def set_arithmetic(self, arithmetic): self.arithmetic = arithmetic
    def get_begin(self): return self.begin
    def set_begin(self, begin): self.begin = begin
    def get_concat(self): return self.concat
    def set_concat(self, concat): self.concat = concat
    def get_end(self): return self.end
    def set_end(self, end): self.end = end
    def get_escape_regex(self): return self.escape_regex
    def set_escape_regex(self, escape_regex): self.escape_regex = escape_regex
    def get_split(self): return self.split
    def set_split(self, split): self.split = split
    def get_substring(self): return self.substring
    def set_substring(self, substring): self.substring = substring
    def get_time_difference(self): return self.time_difference
    def set_time_difference(self, time_difference): self.time_difference = time_difference
    def get_regex_capture(self): return self.regex_capture
    def set_regex_capture(self, regex_capture): self.regex_capture = regex_capture
    def get_pattern(self): return self.pattern
    def set_pattern(self, pattern): self.pattern = pattern
    def export(self, outfile, level, namespace_='win-def:', name_='RegexCaptureFunctionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RegexCaptureFunctionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='RegexCaptureFunctionType'):
        if self.pattern is not None:
            outfile.write(' pattern=%s' % (self.format_string(quote_attrib(self.pattern).encode(ExternalEncoding), input_name='pattern'), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='RegexCaptureFunctionType'):
        if self.object_component:
            self.object_component.export(outfile, level, namespace_, name_='object_component', )
        if self.variable_component:
            self.variable_component.export(outfile, level, namespace_, name_='variable_component', )
        if self.literal_component:
            self.literal_component.export(outfile, level, namespace_, name_='literal_component', )
        if self.arithmetic:
            self.arithmetic.export(outfile, level, namespace_, name_='arithmetic', )
        if self.begin:
            self.begin.export(outfile, level, namespace_, name_='begin', )
        if self.concat:
            self.concat.export(outfile, level, namespace_, name_='concat', )
        if self.end:
            self.end.export(outfile, level, namespace_, name_='end', )
        if self.escape_regex:
            self.escape_regex.export(outfile, level, namespace_, name_='escape_regex', )
        if self.split:
            self.split.export(outfile, level, namespace_, name_='split', )
        if self.substring:
            self.substring.export(outfile, level, namespace_, name_='substring', )
        if self.time_difference:
            self.time_difference.export(outfile, level, namespace_, name_='time_difference', )
        if self.regex_capture:
            self.regex_capture.export(outfile, level, namespace_, name_='regex_capture', )
    def hasContent_(self):
        if (
            self.object_component is not None or
            self.variable_component is not None or
            self.literal_component is not None or
            self.arithmetic is not None or
            self.begin is not None or
            self.concat is not None or
            self.end is not None or
            self.escape_regex is not None or
            self.split is not None or
            self.substring is not None or
            self.time_difference is not None or
            self.regex_capture is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegexCaptureFunctionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.pattern is not None:
            showIndent(outfile, level)
            outfile.write('pattern = "%s",\n' % (self.pattern,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.object_component is not None:
            showIndent(outfile, level)
            outfile.write('object_component=model_.ObjectComponentType(\n')
            self.object_component.exportLiteral(outfile, level, name_='object_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.variable_component is not None:
            showIndent(outfile, level)
            outfile.write('variable_component=model_.VariableComponentType(\n')
            self.variable_component.exportLiteral(outfile, level, name_='variable_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.literal_component is not None:
            showIndent(outfile, level)
            outfile.write('literal_component=model_.LiteralComponentType(\n')
            self.literal_component.exportLiteral(outfile, level, name_='literal_component')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.arithmetic is not None:
            showIndent(outfile, level)
            outfile.write('arithmetic=model_.ArithmeticFunctionType(\n')
            self.arithmetic.exportLiteral(outfile, level, name_='arithmetic')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.begin is not None:
            showIndent(outfile, level)
            outfile.write('begin=model_.BeginFunctionType(\n')
            self.begin.exportLiteral(outfile, level, name_='begin')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.concat is not None:
            showIndent(outfile, level)
            outfile.write('concat=model_.ConcatFunctionType(\n')
            self.concat.exportLiteral(outfile, level, name_='concat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.end is not None:
            showIndent(outfile, level)
            outfile.write('end=model_.EndFunctionType(\n')
            self.end.exportLiteral(outfile, level, name_='end')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.escape_regex is not None:
            showIndent(outfile, level)
            outfile.write('escape_regex=model_.EscapeRegexFunctionType(\n')
            self.escape_regex.exportLiteral(outfile, level, name_='escape_regex')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.split is not None:
            showIndent(outfile, level)
            outfile.write('split=model_.SplitFunctionType(\n')
            self.split.exportLiteral(outfile, level, name_='split')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.substring is not None:
            showIndent(outfile, level)
            outfile.write('substring=model_.SubstringFunctionType(\n')
            self.substring.exportLiteral(outfile, level, name_='substring')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.time_difference is not None:
            showIndent(outfile, level)
            outfile.write('time_difference=model_.TimeDifferenceFunctionType(\n')
            self.time_difference.exportLiteral(outfile, level, name_='time_difference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.regex_capture is not None:
            showIndent(outfile, level)
            outfile.write('regex_capture=model_.RegexCaptureFunctionType(\n')
            self.regex_capture.exportLiteral(outfile, level, name_='regex_capture')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('pattern')
        if value is not None:
            self.pattern = value
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object_component': 
            obj_ = ObjectComponentType.factory()
            obj_.build(child_)
            self.set_object_component(obj_)
        elif nodeName_ == 'variable_component': 
            obj_ = VariableComponentType.factory()
            obj_.build(child_)
            self.set_variable_component(obj_)
        elif nodeName_ == 'literal_component': 
            obj_ = LiteralComponentType.factory()
            obj_.build(child_)
            self.set_literal_component(obj_)
        elif nodeName_ == 'arithmetic': 
            obj_ = ArithmeticFunctionType.factory()
            obj_.build(child_)
            self.set_arithmetic(obj_)
        elif nodeName_ == 'begin': 
            obj_ = BeginFunctionType.factory()
            obj_.build(child_)
            self.set_begin(obj_)
        elif nodeName_ == 'concat': 
            obj_ = ConcatFunctionType.factory()
            obj_.build(child_)
            self.set_concat(obj_)
        elif nodeName_ == 'end': 
            obj_ = EndFunctionType.factory()
            obj_.build(child_)
            self.set_end(obj_)
        elif nodeName_ == 'escape_regex': 
            obj_ = EscapeRegexFunctionType.factory()
            obj_.build(child_)
            self.set_escape_regex(obj_)
        elif nodeName_ == 'split': 
            obj_ = SplitFunctionType.factory()
            obj_.build(child_)
            self.set_split(obj_)
        elif nodeName_ == 'substring': 
            obj_ = SubstringFunctionType.factory()
            obj_.build(child_)
            self.set_substring(obj_)
        elif nodeName_ == 'time_difference': 
            obj_ = TimeDifferenceFunctionType.factory()
            obj_.build(child_)
            self.set_time_difference(obj_)
        elif nodeName_ == 'regex_capture': 
            obj_ = RegexCaptureFunctionType.factory()
            obj_.build(child_)
            self.set_regex_capture(obj_)
# end class RegexCaptureFunctionType


class EntityBaseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, valueOf_=None, mixedclass_=None, content_=None):
        self.datatype = _cast(None, datatype)
        self.operation = _cast(None, operation)
        self.mask = _cast(bool, mask)
        self.var_ref = _cast(None, var_ref)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityBaseType.subclass:
            return EntityBaseType.subclass(*args_, **kwargs_)
        else:
            return EntityBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def get_mask(self): return self.mask
    def set_mask(self, mask): self.mask = mask
    def get_var_ref(self): return self.var_ref
    def set_var_ref(self, var_ref): self.var_ref = var_ref
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityBaseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityBaseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityBaseType'):
        #super(EntityBaseType, self).exportAttributes(outfile, level, namespace_, name_='EntityBaseType')
        if self.datatype is not None:
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.operation is not None:
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
        if self.mask is not None:
            outfile.write(' mask="%s"' % self.format_boolean(str_lower(str(self.mask)), input_name='mask'))
        if self.var_ref is not None:
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityBaseType'):
        #super(EntityBaseType, self).exportChildren(outfile, level, namespace_, name_)
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityBaseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.datatype is not None:
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        if self.operation is not None:
            showIndent(outfile, level)
            outfile.write('operation = %s,\n' % (self.operation,))
        if self.mask is not None:
            showIndent(outfile, level)
            outfile.write('mask = %s,\n' % (self.mask,))
        if self.var_ref is not None:
            showIndent(outfile, level)
            outfile.write('var_ref = %s,\n' % (self.var_ref,))
        super(EntityBaseType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityBaseType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('datatype')
        if value is not None:
            self.datatype = value
        value = attrs.get('operation')
        if value is not None:
            self.operation = value
        value = attrs.get('mask')
        if value is not None:
            if value in ('true', '1'):
                self.mask = True
            elif value in ('false', '0'):
                self.mask = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('var_ref')
        if value is not None:
            self.var_ref = value
        super(EntityBaseType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityBaseType


class EntityObjectBaseType(EntityBaseType):
    subclass = None
    superclass = EntityBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityObjectBaseType, self).__init__(valueOf_, mixedclass_, content_, )
        self.var_check = _cast(None, var_check)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectBaseType.subclass:
            return EntityObjectBaseType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_var_check(self): return self.var_check
    def set_var_check(self, var_check): self.var_check = var_check
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityObjectBaseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityObjectBaseType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityObjectBaseType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityObjectBaseType'):
        super(EntityObjectBaseType, self).exportAttributes(outfile, level, namespace_, name_='EntityObjectBaseType')
        if self.var_check is not None:
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityObjectBaseType'):
        super(EntityObjectBaseType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectBaseType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityObjectBaseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.var_check is not None:
            showIndent(outfile, level)
            outfile.write('var_check = %s,\n' % (self.var_check,))
        super(EntityObjectBaseType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectBaseType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('var_check')
        if value is not None:
            self.var_check = value
        super(EntityObjectBaseType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityObjectBaseType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityObjectBaseType


class EntityObjectAnySimpleType(EntityObjectBaseType):
    subclass = None
    superclass = EntityObjectBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityObjectAnySimpleType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectAnySimpleType.subclass:
            return EntityObjectAnySimpleType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectAnySimpleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityObjectAnySimpleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityObjectAnySimpleType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityObjectAnySimpleType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityObjectAnySimpleType'):
        super(EntityObjectAnySimpleType, self).exportAttributes(outfile, level, namespace_, name_='EntityObjectAnySimpleType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityObjectAnySimpleType'):
        super(EntityObjectAnySimpleType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectAnySimpleType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityObjectAnySimpleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityObjectAnySimpleType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectAnySimpleType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityObjectAnySimpleType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityObjectAnySimpleType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityObjectAnySimpleType


class EntityObjectBinaryType(EntityObjectBaseType):
    subclass = None
    superclass = EntityObjectBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityObjectBinaryType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectBinaryType.subclass:
            return EntityObjectBinaryType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectBinaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityObjectBinaryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityObjectBinaryType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityObjectBinaryType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityObjectBinaryType'):
        super(EntityObjectBinaryType, self).exportAttributes(outfile, level, namespace_, name_='EntityObjectBinaryType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityObjectBinaryType'):
        super(EntityObjectBinaryType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectBinaryType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityObjectBinaryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityObjectBinaryType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectBinaryType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityObjectBinaryType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityObjectBinaryType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityObjectBinaryType


class EntityObjectBoolType(EntityObjectBaseType):
    subclass = None
    superclass = EntityObjectBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityObjectBoolType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectBoolType.subclass:
            return EntityObjectBoolType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectBoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityObjectBoolType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityObjectBoolType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityObjectBoolType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityObjectBoolType'):
        super(EntityObjectBoolType, self).exportAttributes(outfile, level, namespace_, name_='EntityObjectBoolType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityObjectBoolType'):
        super(EntityObjectBoolType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectBoolType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityObjectBoolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityObjectBoolType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectBoolType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityObjectBoolType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityObjectBoolType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityObjectBoolType


class EntityObjectFloatType(EntityObjectBaseType):
    subclass = None
    superclass = EntityObjectBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityObjectFloatType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectFloatType.subclass:
            return EntityObjectFloatType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectFloatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityObjectFloatType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityObjectFloatType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityObjectFloatType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityObjectFloatType'):
        super(EntityObjectFloatType, self).exportAttributes(outfile, level, namespace_, name_='EntityObjectFloatType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityObjectFloatType'):
        super(EntityObjectFloatType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectFloatType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityObjectFloatType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityObjectFloatType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectFloatType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityObjectFloatType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityObjectFloatType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityObjectFloatType


class EntityObjectIntType(EntityObjectBaseType):
    subclass = None
    superclass = EntityObjectBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityObjectIntType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectIntType.subclass:
            return EntityObjectIntType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectIntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityObjectIntType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityObjectIntType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityObjectIntType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityObjectIntType'):
        super(EntityObjectIntType, self).exportAttributes(outfile, level, namespace_, name_='EntityObjectIntType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityObjectIntType'):
        super(EntityObjectIntType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectIntType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityObjectIntType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityObjectIntType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectIntType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityObjectIntType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityObjectIntType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityObjectIntType


class EntityObjectStringType(EntityObjectBaseType):
    subclass = None
    superclass = EntityObjectBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityObjectStringType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectStringType.subclass:
            return EntityObjectStringType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityObjectStringType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityObjectStringType')
        #outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        #outfile.write(' xsi:type="EntityObjectStringType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityObjectStringType'):
        super(EntityObjectStringType, self).exportAttributes(outfile, level, namespace_, name_='EntityObjectStringType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityObjectStringType'):
        super(EntityObjectStringType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectStringType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityObjectStringType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityObjectStringType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityObjectStringType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityObjectStringType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityObjectStringType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityObjectStringType


class EntityStateBaseType(EntityBaseType):
    subclass = None
    superclass = EntityBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateBaseType, self).__init__(valueOf_, mixedclass_, content_, )
        self.entity_check = _cast(None, entity_check)
        self.var_check = _cast(None, var_check)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateBaseType.subclass:
            return EntityStateBaseType.subclass(*args_, **kwargs_)
        else:
            return EntityStateBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_entity_check(self): return self.entity_check
    def set_entity_check(self, entity_check): self.entity_check = entity_check
    def get_var_check(self): return self.var_check
    def set_var_check(self, var_check): self.var_check = var_check
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateBaseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateBaseType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateBaseType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateBaseType'):
        super(EntityStateBaseType, self).exportAttributes(outfile, level, namespace_, name_='EntityStateBaseType')
        if self.entity_check is not None:
            outfile.write(' entity_check=%s' % (quote_attrib(self.entity_check), ))
        if self.var_check is not None:
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateBaseType'):
        super(EntityStateBaseType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateBaseType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateBaseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.entity_check is not None:
            showIndent(outfile, level)
            outfile.write('entity_check = %s,\n' % (self.entity_check,))
        if self.var_check is not None:
            showIndent(outfile, level)
            outfile.write('var_check = %s,\n' % (self.var_check,))
        super(EntityStateBaseType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateBaseType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('entity_check')
        if value is not None:
            self.entity_check = value
        value = attrs.get('var_check')
        if value is not None:
            self.var_check = value
        super(EntityStateBaseType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityStateBaseType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityStateBaseType


class EntityStateAnySimpleType(EntityStateBaseType):
    subclass = None
    superclass = EntityStateBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateAnySimpleType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateAnySimpleType.subclass:
            return EntityStateAnySimpleType.subclass(*args_, **kwargs_)
        else:
            return EntityStateAnySimpleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateAnySimpleType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateAnySimpleType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateAnySimpleType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateAnySimpleType'):
        super(EntityStateAnySimpleType, self).exportAttributes(outfile, level, namespace_, name_='EntityStateAnySimpleType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateAnySimpleType'):
        super(EntityStateAnySimpleType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateAnySimpleType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateAnySimpleType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityStateAnySimpleType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateAnySimpleType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityStateAnySimpleType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityStateAnySimpleType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityStateAnySimpleType


class EntityStateBinaryType(EntityStateBaseType):
    subclass = None
    superclass = EntityStateBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateBinaryType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateBinaryType.subclass:
            return EntityStateBinaryType.subclass(*args_, **kwargs_)
        else:
            return EntityStateBinaryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateBinaryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateBinaryType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateBinaryType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateBinaryType'):
        super(EntityStateBinaryType, self).exportAttributes(outfile, level, namespace_, name_='EntityStateBinaryType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateBinaryType'):
        super(EntityStateBinaryType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateBinaryType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateBinaryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityStateBinaryType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateBinaryType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityStateBinaryType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityStateBinaryType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityStateBinaryType


class EntityStateBoolType(EntityStateBaseType):
    subclass = None
    superclass = EntityStateBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateBoolType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateBoolType.subclass:
            return EntityStateBoolType.subclass(*args_, **kwargs_)
        else:
            return EntityStateBoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateBoolType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateBoolType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateBoolType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateBoolType'):
        super(EntityStateBoolType, self).exportAttributes(outfile, level, namespace_, name_='EntityStateBoolType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateBoolType'):
        super(EntityStateBoolType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateBoolType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateBoolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityStateBoolType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateBoolType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityStateBoolType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityStateBoolType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityStateBoolType


class EntityStateFloatType(EntityStateBaseType):
    subclass = None
    superclass = EntityStateBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateFloatType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateFloatType.subclass:
            return EntityStateFloatType.subclass(*args_, **kwargs_)
        else:
            return EntityStateFloatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateFloatType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateFloatType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateFloatType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateFloatType'):
        super(EntityStateFloatType, self).exportAttributes(outfile, level, namespace_, name_='EntityStateFloatType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateFloatType'):
        super(EntityStateFloatType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateFloatType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateFloatType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityStateFloatType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateFloatType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityStateFloatType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityStateFloatType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityStateFloatType


class EntityStateIntType(EntityStateBaseType):
    subclass = None
    superclass = EntityStateBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateIntType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateIntType.subclass:
            return EntityStateIntType.subclass(*args_, **kwargs_)
        else:
            return EntityStateIntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateIntType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateIntType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateIntType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateIntType'):
        super(EntityStateIntType, self).exportAttributes(outfile, level, namespace_, name_='EntityStateIntType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateIntType'):
        super(EntityStateIntType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateIntType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateIntType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityStateIntType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateIntType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityStateIntType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityStateIntType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityStateIntType


class EntityStateStringType(EntityStateBaseType):
    subclass = None
    superclass = EntityStateBaseType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateStringType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateStringType.subclass:
            return EntityStateStringType.subclass(*args_, **kwargs_)
        else:
            return EntityStateStringType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateStringType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateStringType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateStringType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateStringType'):
        super(EntityStateStringType, self).exportAttributes(outfile, level, namespace_, name_='EntityStateStringType')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateStringType'):
        super(EntityStateStringType, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateStringType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateStringType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(EntityStateStringType, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityStateStringType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(EntityStateStringType, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(EntityStateStringType, self).buildChildren(child_, nodeName_)
        pass
# end class EntityStateStringType


class EntityStateRecordType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, field=None, valueOf_=None, mixedclass_=None, content_=None):
        if field is None:
            self.field = []
        else:
            self.field = field
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateRecordType.subclass:
            return EntityStateRecordType.subclass(*args_, **kwargs_)
        else:
            return EntityStateRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_field(self): return self.field
    def set_field(self, field): self.field = field
    def add_field(self, value): self.field.append(value)
    def insert_field(self, index, value): self.field[index] = value
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateRecordType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateRecordType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateRecordType'):
        pass
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateRecordType'):
        for item_ in self.content_:
            item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.field or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateRecordType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'field':
            childobj_ = EntityStateFieldType.factory()
            childobj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, 'field', childobj_)
            self.content_.append(obj_)
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class EntityStateRecordType


class EntityStateFieldType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, var_ref=None, var_check='all', datatype='string', mask=False, entity_check='all', operation='equals', valueOf_=None):
        self.name = _cast(None, name)
        self.var_ref = _cast(None, var_ref)
        self.var_check = _cast(None, var_check)
        self.datatype = _cast(None, datatype)
        self.mask = _cast(bool, mask)
        self.entity_check = _cast(None, entity_check)
        self.operation = _cast(None, operation)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateFieldType.subclass:
            return EntityStateFieldType.subclass(*args_, **kwargs_)
        else:
            return EntityStateFieldType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_var_ref(self): return self.var_ref
    def set_var_ref(self, var_ref): self.var_ref = var_ref
    def get_var_check(self): return self.var_check
    def set_var_check(self, var_check): self.var_check = var_check
    def get_datatype(self): return self.datatype
    def set_datatype(self, datatype): self.datatype = datatype
    def get_mask(self): return self.mask
    def set_mask(self, mask): self.mask = mask
    def get_entity_check(self): return self.entity_check
    def set_entity_check(self, entity_check): self.entity_check = entity_check
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateFieldType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateFieldType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateFieldType'):
        outfile.write(' name=%s' % (self.format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.var_ref is not None:
            outfile.write(' var_ref=%s' % (quote_attrib(self.var_ref), ))
        if self.var_check is not None:
            outfile.write(' var_check=%s' % (quote_attrib(self.var_check), ))
        if self.datatype is not None:
            outfile.write(' datatype=%s' % (quote_attrib(self.datatype), ))
        if self.mask is not None:
            outfile.write(' mask="%s"' % self.format_boolean(str_lower(str(self.mask)), input_name='mask'))
        if self.entity_check is not None:
            outfile.write(' entity_check=%s' % (quote_attrib(self.entity_check), ))
        if self.operation is not None:
            outfile.write(' operation=%s' % (quote_attrib(self.operation), ))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateFieldType'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateFieldType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.var_ref is not None:
            showIndent(outfile, level)
            outfile.write('var_ref = %s,\n' % (self.var_ref,))
        if self.var_check is not None:
            showIndent(outfile, level)
            outfile.write('var_check = %s,\n' % (self.var_check,))
        if self.datatype is not None:
            showIndent(outfile, level)
            outfile.write('datatype = %s,\n' % (self.datatype,))
        if self.mask is not None:
            showIndent(outfile, level)
            outfile.write('mask = %s,\n' % (self.mask,))
        if self.entity_check is not None:
            showIndent(outfile, level)
            outfile.write('entity_check = %s,\n' % (self.entity_check,))
        if self.operation is not None:
            showIndent(outfile, level)
            outfile.write('operation = %s,\n' % (self.operation,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('name')
        if value is not None:
            self.name = value
        value = attrs.get('var_ref')
        if value is not None:
            self.var_ref = value
        value = attrs.get('var_check')
        if value is not None:
            self.var_check = value
        value = attrs.get('datatype')
        if value is not None:
            self.datatype = value
        value = attrs.get('mask')
        if value is not None:
            if value in ('true', '1'):
                self.mask = True
            elif value in ('false', '0'):
                self.mask = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('entity_check')
        if value is not None:
            self.entity_check = value
        value = attrs.get('operation')
        if value is not None:
            self.operation = value
    def buildChildren(self, child_, nodeName_):
        pass
# end class EntityStateFieldType


class accesstoken_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=False, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(accesstoken_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if accesstoken_test.subclass:
            return accesstoken_test.subclass(*args_, **kwargs_)
        else:
            return accesstoken_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='accesstoken_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='accesstoken_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="accesstoken_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='accesstoken_test'):
        super(accesstoken_test, self).exportAttributes(outfile, level, namespace_, name_='accesstoken_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='accesstoken_test'):
        super(accesstoken_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(accesstoken_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='accesstoken_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(accesstoken_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(accesstoken_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(accesstoken_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(accesstoken_test, self).buildChildren(child_, nodeName_)
# end class accesstoken_test


class accesstoken_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=False, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, security_principle=None):
        super(accesstoken_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.security_principle = security_principle
    def factory(*args_, **kwargs_):
        if accesstoken_object.subclass:
            return accesstoken_object.subclass(*args_, **kwargs_)
        else:
            return accesstoken_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_security_principle(self): return self.security_principle
    def set_security_principle(self, security_principle): self.security_principle = security_principle
    def validate_security_principle(self, value):
        # validate type security_principle
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='accesstoken_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='accesstoken_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="accesstoken_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='accesstoken_object'):
        super(accesstoken_object, self).exportAttributes(outfile, level, namespace_, name_='accesstoken_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='accesstoken_object'):
        super(accesstoken_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set', )
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.security_principle is not None:
            showIndent(outfile, level)
            outfile.write('<%ssecurity_principle>%s</%ssecurity_principle>\n' % (namespace_, self.format_string(quote_xml(self.security_principle).encode(ExternalEncoding), input_name='security_principle'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.security_principle is not None or
            super(accesstoken_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='accesstoken_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(accesstoken_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(accesstoken_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.AccesstokenBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.security_principle is not None:
            showIndent(outfile, level)
            outfile.write('security_principle=%s,\n' % quote_python(self.security_principle).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(accesstoken_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = AccesstokenBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'security_principle':
            security_principle_ = child_.text
            self.security_principle = security_principle_
            self.validate_security_principle(self.security_principle)    # validate type security_principle
        super(accesstoken_object, self).buildChildren(child_, nodeName_)
# end class accesstoken_object


class accesstoken_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=False, Signature=None, notes=None, security_principle=None, seassignprimarytokenprivilege=None, seauditprivilege=None, sebackupprivilege=None, sechangenotifyprivilege=None, secreateglobalprivilege=None, secreatepagefileprivilege=None, secreatepermanentprivilege=None, secreatesymboliclinkprivilege=None, secreatetokenprivilege=None, sedebugprivilege=None, seenabledelegationprivilege=None, seimpersonateprivilege=None, seincreasebasepriorityprivilege=None, seincreasequotaprivilege=None, seincreaseworkingsetprivilege=None, seloaddriverprivilege=None, selockmemoryprivilege=None, semachineaccountprivilege=None, semanagevolumeprivilege=None, seprofilesingleprocessprivilege=None, serelabelprivilege=None, seremoteshutdownprivilege=None, serestoreprivilege=None, sesecurityprivilege=None, seshutdownprivilege=None, sesyncagentprivilege=None, sesystemenvironmentprivilege=None, sesystemprofileprivilege=None, sesystemtimeprivilege=None, setakeownershipprivilege=None, setcbprivilege=None, setimezoneprivilege=None, seundockprivilege=None, seunsolicitedinputprivilege=None, sebatchlogonright=None, seinteractivelogonright=None, senetworklogonright=None, seremoteinteractivelogonright=None, seservicelogonright=None, sedenybatchLogonright=None, sedenyinteractivelogonright=None, sedenynetworklogonright=None, sedenyremoteInteractivelogonright=None, sedenyservicelogonright=None):
        super(accesstoken_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.security_principle = security_principle
        self.seassignprimarytokenprivilege = seassignprimarytokenprivilege
        self.seauditprivilege = seauditprivilege
        self.sebackupprivilege = sebackupprivilege
        self.sechangenotifyprivilege = sechangenotifyprivilege
        self.secreateglobalprivilege = secreateglobalprivilege
        self.secreatepagefileprivilege = secreatepagefileprivilege
        self.secreatepermanentprivilege = secreatepermanentprivilege
        self.secreatesymboliclinkprivilege = secreatesymboliclinkprivilege
        self.secreatetokenprivilege = secreatetokenprivilege
        self.sedebugprivilege = sedebugprivilege
        self.seenabledelegationprivilege = seenabledelegationprivilege
        self.seimpersonateprivilege = seimpersonateprivilege
        self.seincreasebasepriorityprivilege = seincreasebasepriorityprivilege
        self.seincreasequotaprivilege = seincreasequotaprivilege
        self.seincreaseworkingsetprivilege = seincreaseworkingsetprivilege
        self.seloaddriverprivilege = seloaddriverprivilege
        self.selockmemoryprivilege = selockmemoryprivilege
        self.semachineaccountprivilege = semachineaccountprivilege
        self.semanagevolumeprivilege = semanagevolumeprivilege
        self.seprofilesingleprocessprivilege = seprofilesingleprocessprivilege
        self.serelabelprivilege = serelabelprivilege
        self.seremoteshutdownprivilege = seremoteshutdownprivilege
        self.serestoreprivilege = serestoreprivilege
        self.sesecurityprivilege = sesecurityprivilege
        self.seshutdownprivilege = seshutdownprivilege
        self.sesyncagentprivilege = sesyncagentprivilege
        self.sesystemenvironmentprivilege = sesystemenvironmentprivilege
        self.sesystemprofileprivilege = sesystemprofileprivilege
        self.sesystemtimeprivilege = sesystemtimeprivilege
        self.setakeownershipprivilege = setakeownershipprivilege
        self.setcbprivilege = setcbprivilege
        self.setimezoneprivilege = setimezoneprivilege
        self.seundockprivilege = seundockprivilege
        self.seunsolicitedinputprivilege = seunsolicitedinputprivilege
        self.sebatchlogonright = sebatchlogonright
        self.seinteractivelogonright = seinteractivelogonright
        self.senetworklogonright = senetworklogonright
        self.seremoteinteractivelogonright = seremoteinteractivelogonright
        self.seservicelogonright = seservicelogonright
        self.sedenybatchLogonright = sedenybatchLogonright
        self.sedenyinteractivelogonright = sedenyinteractivelogonright
        self.sedenynetworklogonright = sedenynetworklogonright
        self.sedenyremoteInteractivelogonright = sedenyremoteInteractivelogonright
        self.sedenyservicelogonright = sedenyservicelogonright
    def factory(*args_, **kwargs_):
        if accesstoken_state.subclass:
            return accesstoken_state.subclass(*args_, **kwargs_)
        else:
            return accesstoken_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_security_principle(self): return self.security_principle
    def set_security_principle(self, security_principle): self.security_principle = security_principle
    def validate_security_principle(self, value):
        # validate type security_principle
        pass
    def get_seassignprimarytokenprivilege(self): return self.seassignprimarytokenprivilege
    def set_seassignprimarytokenprivilege(self, seassignprimarytokenprivilege): self.seassignprimarytokenprivilege = seassignprimarytokenprivilege
    def validate_seassignprimarytokenprivilege(self, value):
        # validate type seassignprimarytokenprivilege
        pass
    def get_seauditprivilege(self): return self.seauditprivilege
    def set_seauditprivilege(self, seauditprivilege): self.seauditprivilege = seauditprivilege
    def validate_seauditprivilege(self, value):
        # validate type seauditprivilege
        pass
    def get_sebackupprivilege(self): return self.sebackupprivilege
    def set_sebackupprivilege(self, sebackupprivilege): self.sebackupprivilege = sebackupprivilege
    def validate_sebackupprivilege(self, value):
        # validate type sebackupprivilege
        pass
    def get_sechangenotifyprivilege(self): return self.sechangenotifyprivilege
    def set_sechangenotifyprivilege(self, sechangenotifyprivilege): self.sechangenotifyprivilege = sechangenotifyprivilege
    def validate_sechangenotifyprivilege(self, value):
        # validate type sechangenotifyprivilege
        pass
    def get_secreateglobalprivilege(self): return self.secreateglobalprivilege
    def set_secreateglobalprivilege(self, secreateglobalprivilege): self.secreateglobalprivilege = secreateglobalprivilege
    def validate_secreateglobalprivilege(self, value):
        # validate type secreateglobalprivilege
        pass
    def get_secreatepagefileprivilege(self): return self.secreatepagefileprivilege
    def set_secreatepagefileprivilege(self, secreatepagefileprivilege): self.secreatepagefileprivilege = secreatepagefileprivilege
    def validate_secreatepagefileprivilege(self, value):
        # validate type secreatepagefileprivilege
        pass
    def get_secreatepermanentprivilege(self): return self.secreatepermanentprivilege
    def set_secreatepermanentprivilege(self, secreatepermanentprivilege): self.secreatepermanentprivilege = secreatepermanentprivilege
    def validate_secreatepermanentprivilege(self, value):
        # validate type secreatepermanentprivilege
        pass
    def get_secreatesymboliclinkprivilege(self): return self.secreatesymboliclinkprivilege
    def set_secreatesymboliclinkprivilege(self, secreatesymboliclinkprivilege): self.secreatesymboliclinkprivilege = secreatesymboliclinkprivilege
    def validate_secreatesymboliclinkprivilege(self, value):
        # validate type secreatesymboliclinkprivilege
        pass
    def get_secreatetokenprivilege(self): return self.secreatetokenprivilege
    def set_secreatetokenprivilege(self, secreatetokenprivilege): self.secreatetokenprivilege = secreatetokenprivilege
    def validate_secreatetokenprivilege(self, value):
        # validate type secreatetokenprivilege
        pass
    def get_sedebugprivilege(self): return self.sedebugprivilege
    def set_sedebugprivilege(self, sedebugprivilege): self.sedebugprivilege = sedebugprivilege
    def validate_sedebugprivilege(self, value):
        # validate type sedebugprivilege
        pass
    def get_seenabledelegationprivilege(self): return self.seenabledelegationprivilege
    def set_seenabledelegationprivilege(self, seenabledelegationprivilege): self.seenabledelegationprivilege = seenabledelegationprivilege
    def validate_seenabledelegationprivilege(self, value):
        # validate type seenabledelegationprivilege
        pass
    def get_seimpersonateprivilege(self): return self.seimpersonateprivilege
    def set_seimpersonateprivilege(self, seimpersonateprivilege): self.seimpersonateprivilege = seimpersonateprivilege
    def validate_seimpersonateprivilege(self, value):
        # validate type seimpersonateprivilege
        pass
    def get_seincreasebasepriorityprivilege(self): return self.seincreasebasepriorityprivilege
    def set_seincreasebasepriorityprivilege(self, seincreasebasepriorityprivilege): self.seincreasebasepriorityprivilege = seincreasebasepriorityprivilege
    def validate_seincreasebasepriorityprivilege(self, value):
        # validate type seincreasebasepriorityprivilege
        pass
    def get_seincreasequotaprivilege(self): return self.seincreasequotaprivilege
    def set_seincreasequotaprivilege(self, seincreasequotaprivilege): self.seincreasequotaprivilege = seincreasequotaprivilege
    def validate_seincreasequotaprivilege(self, value):
        # validate type seincreasequotaprivilege
        pass
    def get_seincreaseworkingsetprivilege(self): return self.seincreaseworkingsetprivilege
    def set_seincreaseworkingsetprivilege(self, seincreaseworkingsetprivilege): self.seincreaseworkingsetprivilege = seincreaseworkingsetprivilege
    def validate_seincreaseworkingsetprivilege(self, value):
        # validate type seincreaseworkingsetprivilege
        pass
    def get_seloaddriverprivilege(self): return self.seloaddriverprivilege
    def set_seloaddriverprivilege(self, seloaddriverprivilege): self.seloaddriverprivilege = seloaddriverprivilege
    def validate_seloaddriverprivilege(self, value):
        # validate type seloaddriverprivilege
        pass
    def get_selockmemoryprivilege(self): return self.selockmemoryprivilege
    def set_selockmemoryprivilege(self, selockmemoryprivilege): self.selockmemoryprivilege = selockmemoryprivilege
    def validate_selockmemoryprivilege(self, value):
        # validate type selockmemoryprivilege
        pass
    def get_semachineaccountprivilege(self): return self.semachineaccountprivilege
    def set_semachineaccountprivilege(self, semachineaccountprivilege): self.semachineaccountprivilege = semachineaccountprivilege
    def validate_semachineaccountprivilege(self, value):
        # validate type semachineaccountprivilege
        pass
    def get_semanagevolumeprivilege(self): return self.semanagevolumeprivilege
    def set_semanagevolumeprivilege(self, semanagevolumeprivilege): self.semanagevolumeprivilege = semanagevolumeprivilege
    def validate_semanagevolumeprivilege(self, value):
        # validate type semanagevolumeprivilege
        pass
    def get_seprofilesingleprocessprivilege(self): return self.seprofilesingleprocessprivilege
    def set_seprofilesingleprocessprivilege(self, seprofilesingleprocessprivilege): self.seprofilesingleprocessprivilege = seprofilesingleprocessprivilege
    def validate_seprofilesingleprocessprivilege(self, value):
        # validate type seprofilesingleprocessprivilege
        pass
    def get_serelabelprivilege(self): return self.serelabelprivilege
    def set_serelabelprivilege(self, serelabelprivilege): self.serelabelprivilege = serelabelprivilege
    def validate_serelabelprivilege(self, value):
        # validate type serelabelprivilege
        pass
    def get_seremoteshutdownprivilege(self): return self.seremoteshutdownprivilege
    def set_seremoteshutdownprivilege(self, seremoteshutdownprivilege): self.seremoteshutdownprivilege = seremoteshutdownprivilege
    def validate_seremoteshutdownprivilege(self, value):
        # validate type seremoteshutdownprivilege
        pass
    def get_serestoreprivilege(self): return self.serestoreprivilege
    def set_serestoreprivilege(self, serestoreprivilege): self.serestoreprivilege = serestoreprivilege
    def validate_serestoreprivilege(self, value):
        # validate type serestoreprivilege
        pass
    def get_sesecurityprivilege(self): return self.sesecurityprivilege
    def set_sesecurityprivilege(self, sesecurityprivilege): self.sesecurityprivilege = sesecurityprivilege
    def validate_sesecurityprivilege(self, value):
        # validate type sesecurityprivilege
        pass
    def get_seshutdownprivilege(self): return self.seshutdownprivilege
    def set_seshutdownprivilege(self, seshutdownprivilege): self.seshutdownprivilege = seshutdownprivilege
    def validate_seshutdownprivilege(self, value):
        # validate type seshutdownprivilege
        pass
    def get_sesyncagentprivilege(self): return self.sesyncagentprivilege
    def set_sesyncagentprivilege(self, sesyncagentprivilege): self.sesyncagentprivilege = sesyncagentprivilege
    def validate_sesyncagentprivilege(self, value):
        # validate type sesyncagentprivilege
        pass
    def get_sesystemenvironmentprivilege(self): return self.sesystemenvironmentprivilege
    def set_sesystemenvironmentprivilege(self, sesystemenvironmentprivilege): self.sesystemenvironmentprivilege = sesystemenvironmentprivilege
    def validate_sesystemenvironmentprivilege(self, value):
        # validate type sesystemenvironmentprivilege
        pass
    def get_sesystemprofileprivilege(self): return self.sesystemprofileprivilege
    def set_sesystemprofileprivilege(self, sesystemprofileprivilege): self.sesystemprofileprivilege = sesystemprofileprivilege
    def validate_sesystemprofileprivilege(self, value):
        # validate type sesystemprofileprivilege
        pass
    def get_sesystemtimeprivilege(self): return self.sesystemtimeprivilege
    def set_sesystemtimeprivilege(self, sesystemtimeprivilege): self.sesystemtimeprivilege = sesystemtimeprivilege
    def validate_sesystemtimeprivilege(self, value):
        # validate type sesystemtimeprivilege
        pass
    def get_setakeownershipprivilege(self): return self.setakeownershipprivilege
    def set_setakeownershipprivilege(self, setakeownershipprivilege): self.setakeownershipprivilege = setakeownershipprivilege
    def validate_setakeownershipprivilege(self, value):
        # validate type setakeownershipprivilege
        pass
    def get_setcbprivilege(self): return self.setcbprivilege
    def set_setcbprivilege(self, setcbprivilege): self.setcbprivilege = setcbprivilege
    def validate_setcbprivilege(self, value):
        # validate type setcbprivilege
        pass
    def get_setimezoneprivilege(self): return self.setimezoneprivilege
    def set_setimezoneprivilege(self, setimezoneprivilege): self.setimezoneprivilege = setimezoneprivilege
    def validate_setimezoneprivilege(self, value):
        # validate type setimezoneprivilege
        pass
    def get_seundockprivilege(self): return self.seundockprivilege
    def set_seundockprivilege(self, seundockprivilege): self.seundockprivilege = seundockprivilege
    def validate_seundockprivilege(self, value):
        # validate type seundockprivilege
        pass
    def get_seunsolicitedinputprivilege(self): return self.seunsolicitedinputprivilege
    def set_seunsolicitedinputprivilege(self, seunsolicitedinputprivilege): self.seunsolicitedinputprivilege = seunsolicitedinputprivilege
    def validate_seunsolicitedinputprivilege(self, value):
        # validate type seunsolicitedinputprivilege
        pass
    def get_sebatchlogonright(self): return self.sebatchlogonright
    def set_sebatchlogonright(self, sebatchlogonright): self.sebatchlogonright = sebatchlogonright
    def validate_sebatchlogonright(self, value):
        # validate type sebatchlogonright
        pass
    def get_seinteractivelogonright(self): return self.seinteractivelogonright
    def set_seinteractivelogonright(self, seinteractivelogonright): self.seinteractivelogonright = seinteractivelogonright
    def validate_seinteractivelogonright(self, value):
        # validate type seinteractivelogonright
        pass
    def get_senetworklogonright(self): return self.senetworklogonright
    def set_senetworklogonright(self, senetworklogonright): self.senetworklogonright = senetworklogonright
    def validate_senetworklogonright(self, value):
        # validate type senetworklogonright
        pass
    def get_seremoteinteractivelogonright(self): return self.seremoteinteractivelogonright
    def set_seremoteinteractivelogonright(self, seremoteinteractivelogonright): self.seremoteinteractivelogonright = seremoteinteractivelogonright
    def validate_seremoteinteractivelogonright(self, value):
        # validate type seremoteinteractivelogonright
        pass
    def get_seservicelogonright(self): return self.seservicelogonright
    def set_seservicelogonright(self, seservicelogonright): self.seservicelogonright = seservicelogonright
    def validate_seservicelogonright(self, value):
        # validate type seservicelogonright
        pass
    def get_sedenybatchLogonright(self): return self.sedenybatchLogonright
    def set_sedenybatchLogonright(self, sedenybatchLogonright): self.sedenybatchLogonright = sedenybatchLogonright
    def validate_sedenybatchLogonright(self, value):
        # validate type sedenybatchLogonright
        pass
    def get_sedenyinteractivelogonright(self): return self.sedenyinteractivelogonright
    def set_sedenyinteractivelogonright(self, sedenyinteractivelogonright): self.sedenyinteractivelogonright = sedenyinteractivelogonright
    def validate_sedenyinteractivelogonright(self, value):
        # validate type sedenyinteractivelogonright
        pass
    def get_sedenynetworklogonright(self): return self.sedenynetworklogonright
    def set_sedenynetworklogonright(self, sedenynetworklogonright): self.sedenynetworklogonright = sedenynetworklogonright
    def validate_sedenynetworklogonright(self, value):
        # validate type sedenynetworklogonright
        pass
    def get_sedenyremoteInteractivelogonright(self): return self.sedenyremoteInteractivelogonright
    def set_sedenyremoteInteractivelogonright(self, sedenyremoteInteractivelogonright): self.sedenyremoteInteractivelogonright = sedenyremoteInteractivelogonright
    def validate_sedenyremoteInteractivelogonright(self, value):
        # validate type sedenyremoteInteractivelogonright
        pass
    def get_sedenyservicelogonright(self): return self.sedenyservicelogonright
    def set_sedenyservicelogonright(self, sedenyservicelogonright): self.sedenyservicelogonright = sedenyservicelogonright
    def validate_sedenyservicelogonright(self, value):
        # validate type sedenyservicelogonright
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='accesstoken_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='accesstoken_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="accesstoken_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='accesstoken_state'):
        super(accesstoken_state, self).exportAttributes(outfile, level, namespace_, name_='accesstoken_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='accesstoken_state'):
        super(accesstoken_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.security_principle is not None:
            showIndent(outfile, level)
            outfile.write('<%ssecurity_principle>%s</%ssecurity_principle>\n' % (namespace_, self.format_string(quote_xml(self.security_principle).encode(ExternalEncoding), input_name='security_principle'), namespace_))
        if self.seassignprimarytokenprivilege:
            self.seassignprimarytokenprivilege.export(outfile, level, namespace_, name_='seassignprimarytokenprivilege')
        if self.seauditprivilege:
            self.seauditprivilege.export(outfile, level, namespace_, name_='seauditprivilege')
        if self.sebackupprivilege:
            self.sebackupprivilege.export(outfile, level, namespace_, name_='sebackupprivilege')
        if self.sechangenotifyprivilege:
            self.sechangenotifyprivilege.export(outfile, level, namespace_, name_='sechangenotifyprivilege')
        if self.secreateglobalprivilege:
            self.secreateglobalprivilege.export(outfile, level, namespace_, name_='secreateglobalprivilege')
        if self.secreatepagefileprivilege:
            self.secreatepagefileprivilege.export(outfile, level, namespace_, name_='secreatepagefileprivilege')
        if self.secreatepermanentprivilege:
            self.secreatepermanentprivilege.export(outfile, level, namespace_, name_='secreatepermanentprivilege')
        if self.secreatesymboliclinkprivilege:
            self.secreatesymboliclinkprivilege.export(outfile, level, namespace_, name_='secreatesymboliclinkprivilege')
        if self.secreatetokenprivilege:
            self.secreatetokenprivilege.export(outfile, level, namespace_, name_='secreatetokenprivilege')
        if self.sedebugprivilege:
            self.sedebugprivilege.export(outfile, level, namespace_, name_='sedebugprivilege')
        if self.seenabledelegationprivilege:
            self.seenabledelegationprivilege.export(outfile, level, namespace_, name_='seenabledelegationprivilege')
        if self.seimpersonateprivilege:
            self.seimpersonateprivilege.export(outfile, level, namespace_, name_='seimpersonateprivilege')
        if self.seincreasebasepriorityprivilege:
            self.seincreasebasepriorityprivilege.export(outfile, level, namespace_, name_='seincreasebasepriorityprivilege')
        if self.seincreasequotaprivilege:
            self.seincreasequotaprivilege.export(outfile, level, namespace_, name_='seincreasequotaprivilege')
        if self.seincreaseworkingsetprivilege:
            self.seincreaseworkingsetprivilege.export(outfile, level, namespace_, name_='seincreaseworkingsetprivilege')
        if self.seloaddriverprivilege:
            self.seloaddriverprivilege.export(outfile, level, namespace_, name_='seloaddriverprivilege')
        if self.selockmemoryprivilege:
            self.selockmemoryprivilege.export(outfile, level, namespace_, name_='selockmemoryprivilege')
        if self.semachineaccountprivilege:
            self.semachineaccountprivilege.export(outfile, level, namespace_, name_='semachineaccountprivilege')
        if self.semanagevolumeprivilege:
            self.semanagevolumeprivilege.export(outfile, level, namespace_, name_='semanagevolumeprivilege')
        if self.seprofilesingleprocessprivilege:
            self.seprofilesingleprocessprivilege.export(outfile, level, namespace_, name_='seprofilesingleprocessprivilege')
        if self.serelabelprivilege:
            self.serelabelprivilege.export(outfile, level, namespace_, name_='serelabelprivilege')
        if self.seremoteshutdownprivilege:
            self.seremoteshutdownprivilege.export(outfile, level, namespace_, name_='seremoteshutdownprivilege')
        if self.serestoreprivilege:
            self.serestoreprivilege.export(outfile, level, namespace_, name_='serestoreprivilege')
        if self.sesecurityprivilege:
            self.sesecurityprivilege.export(outfile, level, namespace_, name_='sesecurityprivilege')
        if self.seshutdownprivilege:
            self.seshutdownprivilege.export(outfile, level, namespace_, name_='seshutdownprivilege')
        if self.sesyncagentprivilege:
            self.sesyncagentprivilege.export(outfile, level, namespace_, name_='sesyncagentprivilege')
        if self.sesystemenvironmentprivilege:
            self.sesystemenvironmentprivilege.export(outfile, level, namespace_, name_='sesystemenvironmentprivilege')
        if self.sesystemprofileprivilege:
            self.sesystemprofileprivilege.export(outfile, level, namespace_, name_='sesystemprofileprivilege')
        if self.sesystemtimeprivilege:
            self.sesystemtimeprivilege.export(outfile, level, namespace_, name_='sesystemtimeprivilege')
        if self.setakeownershipprivilege:
            self.setakeownershipprivilege.export(outfile, level, namespace_, name_='setakeownershipprivilege')
        if self.setcbprivilege:
            self.setcbprivilege.export(outfile, level, namespace_, name_='setcbprivilege')
        if self.setimezoneprivilege:
            self.setimezoneprivilege.export(outfile, level, namespace_, name_='setimezoneprivilege')
        if self.seundockprivilege:
            self.seundockprivilege.export(outfile, level, namespace_, name_='seundockprivilege')
        if self.seunsolicitedinputprivilege:
            self.seunsolicitedinputprivilege.export(outfile, level, namespace_, name_='seunsolicitedinputprivilege')
        if self.sebatchlogonright:
            self.sebatchlogonright.export(outfile, level, namespace_, name_='sebatchlogonright')
        if self.seinteractivelogonright:
            self.seinteractivelogonright.export(outfile, level, namespace_, name_='seinteractivelogonright')
        if self.senetworklogonright:
            self.senetworklogonright.export(outfile, level, namespace_, name_='senetworklogonright')
        if self.seremoteinteractivelogonright:
            self.seremoteinteractivelogonright.export(outfile, level, namespace_, name_='seremoteinteractivelogonright')
        if self.seservicelogonright:
            self.seservicelogonright.export(outfile, level, namespace_, name_='seservicelogonright')
        if self.sedenybatchLogonright:
            self.sedenybatchLogonright.export(outfile, level, namespace_, name_='sedenybatchLogonright')
        if self.sedenyinteractivelogonright:
            self.sedenyinteractivelogonright.export(outfile, level, namespace_, name_='sedenyinteractivelogonright')
        if self.sedenynetworklogonright:
            self.sedenynetworklogonright.export(outfile, level, namespace_, name_='sedenynetworklogonright')
        if self.sedenyremoteInteractivelogonright:
            self.sedenyremoteInteractivelogonright.export(outfile, level, namespace_, name_='sedenyremoteInteractivelogonright')
        if self.sedenyservicelogonright:
            self.sedenyservicelogonright.export(outfile, level, namespace_, name_='sedenyservicelogonright')
    def hasContent_(self):
        if (
            self.security_principle is not None or
            self.seassignprimarytokenprivilege is not None or
            self.seauditprivilege is not None or
            self.sebackupprivilege is not None or
            self.sechangenotifyprivilege is not None or
            self.secreateglobalprivilege is not None or
            self.secreatepagefileprivilege is not None or
            self.secreatepermanentprivilege is not None or
            self.secreatesymboliclinkprivilege is not None or
            self.secreatetokenprivilege is not None or
            self.sedebugprivilege is not None or
            self.seenabledelegationprivilege is not None or
            self.seimpersonateprivilege is not None or
            self.seincreasebasepriorityprivilege is not None or
            self.seincreasequotaprivilege is not None or
            self.seincreaseworkingsetprivilege is not None or
            self.seloaddriverprivilege is not None or
            self.selockmemoryprivilege is not None or
            self.semachineaccountprivilege is not None or
            self.semanagevolumeprivilege is not None or
            self.seprofilesingleprocessprivilege is not None or
            self.serelabelprivilege is not None or
            self.seremoteshutdownprivilege is not None or
            self.serestoreprivilege is not None or
            self.sesecurityprivilege is not None or
            self.seshutdownprivilege is not None or
            self.sesyncagentprivilege is not None or
            self.sesystemenvironmentprivilege is not None or
            self.sesystemprofileprivilege is not None or
            self.sesystemtimeprivilege is not None or
            self.setakeownershipprivilege is not None or
            self.setcbprivilege is not None or
            self.setimezoneprivilege is not None or
            self.seundockprivilege is not None or
            self.seunsolicitedinputprivilege is not None or
            self.sebatchlogonright is not None or
            self.seinteractivelogonright is not None or
            self.senetworklogonright is not None or
            self.seremoteinteractivelogonright is not None or
            self.seservicelogonright is not None or
            self.sedenybatchLogonright is not None or
            self.sedenyinteractivelogonright is not None or
            self.sedenynetworklogonright is not None or
            self.sedenyremoteInteractivelogonright is not None or
            self.sedenyservicelogonright is not None or
            super(accesstoken_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='accesstoken_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(accesstoken_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(accesstoken_state, self).exportLiteralChildren(outfile, level, name_)
        if self.security_principle is not None:
            showIndent(outfile, level)
            outfile.write('security_principle=%s,\n' % quote_python(self.security_principle).encode(ExternalEncoding))
        if self.seassignprimarytokenprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seassignprimarytokenprivilege=model_.EntityStateBoolType(\n')
            self.seassignprimarytokenprivilege.exportLiteral(outfile, level, name_='seassignprimarytokenprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seauditprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seauditprivilege=model_.EntityStateBoolType(\n')
            self.seauditprivilege.exportLiteral(outfile, level, name_='seauditprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sebackupprivilege is not None:
            showIndent(outfile, level)
            outfile.write('sebackupprivilege=model_.EntityStateBoolType(\n')
            self.sebackupprivilege.exportLiteral(outfile, level, name_='sebackupprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sechangenotifyprivilege is not None:
            showIndent(outfile, level)
            outfile.write('sechangenotifyprivilege=model_.EntityStateBoolType(\n')
            self.sechangenotifyprivilege.exportLiteral(outfile, level, name_='sechangenotifyprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secreateglobalprivilege is not None:
            showIndent(outfile, level)
            outfile.write('secreateglobalprivilege=model_.EntityStateBoolType(\n')
            self.secreateglobalprivilege.exportLiteral(outfile, level, name_='secreateglobalprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secreatepagefileprivilege is not None:
            showIndent(outfile, level)
            outfile.write('secreatepagefileprivilege=model_.EntityStateBoolType(\n')
            self.secreatepagefileprivilege.exportLiteral(outfile, level, name_='secreatepagefileprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secreatepermanentprivilege is not None:
            showIndent(outfile, level)
            outfile.write('secreatepermanentprivilege=model_.EntityStateBoolType(\n')
            self.secreatepermanentprivilege.exportLiteral(outfile, level, name_='secreatepermanentprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secreatesymboliclinkprivilege is not None:
            showIndent(outfile, level)
            outfile.write('secreatesymboliclinkprivilege=model_.EntityStateBoolType(\n')
            self.secreatesymboliclinkprivilege.exportLiteral(outfile, level, name_='secreatesymboliclinkprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secreatetokenprivilege is not None:
            showIndent(outfile, level)
            outfile.write('secreatetokenprivilege=model_.EntityStateBoolType(\n')
            self.secreatetokenprivilege.exportLiteral(outfile, level, name_='secreatetokenprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sedebugprivilege is not None:
            showIndent(outfile, level)
            outfile.write('sedebugprivilege=model_.EntityStateBoolType(\n')
            self.sedebugprivilege.exportLiteral(outfile, level, name_='sedebugprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seenabledelegationprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seenabledelegationprivilege=model_.EntityStateBoolType(\n')
            self.seenabledelegationprivilege.exportLiteral(outfile, level, name_='seenabledelegationprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seimpersonateprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seimpersonateprivilege=model_.EntityStateBoolType(\n')
            self.seimpersonateprivilege.exportLiteral(outfile, level, name_='seimpersonateprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seincreasebasepriorityprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seincreasebasepriorityprivilege=model_.EntityStateBoolType(\n')
            self.seincreasebasepriorityprivilege.exportLiteral(outfile, level, name_='seincreasebasepriorityprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seincreasequotaprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seincreasequotaprivilege=model_.EntityStateBoolType(\n')
            self.seincreasequotaprivilege.exportLiteral(outfile, level, name_='seincreasequotaprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seincreaseworkingsetprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seincreaseworkingsetprivilege=model_.EntityStateBoolType(\n')
            self.seincreaseworkingsetprivilege.exportLiteral(outfile, level, name_='seincreaseworkingsetprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seloaddriverprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seloaddriverprivilege=model_.EntityStateBoolType(\n')
            self.seloaddriverprivilege.exportLiteral(outfile, level, name_='seloaddriverprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.selockmemoryprivilege is not None:
            showIndent(outfile, level)
            outfile.write('selockmemoryprivilege=model_.EntityStateBoolType(\n')
            self.selockmemoryprivilege.exportLiteral(outfile, level, name_='selockmemoryprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.semachineaccountprivilege is not None:
            showIndent(outfile, level)
            outfile.write('semachineaccountprivilege=model_.EntityStateBoolType(\n')
            self.semachineaccountprivilege.exportLiteral(outfile, level, name_='semachineaccountprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.semanagevolumeprivilege is not None:
            showIndent(outfile, level)
            outfile.write('semanagevolumeprivilege=model_.EntityStateBoolType(\n')
            self.semanagevolumeprivilege.exportLiteral(outfile, level, name_='semanagevolumeprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seprofilesingleprocessprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seprofilesingleprocessprivilege=model_.EntityStateBoolType(\n')
            self.seprofilesingleprocessprivilege.exportLiteral(outfile, level, name_='seprofilesingleprocessprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serelabelprivilege is not None:
            showIndent(outfile, level)
            outfile.write('serelabelprivilege=model_.EntityStateBoolType(\n')
            self.serelabelprivilege.exportLiteral(outfile, level, name_='serelabelprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seremoteshutdownprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seremoteshutdownprivilege=model_.EntityStateBoolType(\n')
            self.seremoteshutdownprivilege.exportLiteral(outfile, level, name_='seremoteshutdownprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serestoreprivilege is not None:
            showIndent(outfile, level)
            outfile.write('serestoreprivilege=model_.EntityStateBoolType(\n')
            self.serestoreprivilege.exportLiteral(outfile, level, name_='serestoreprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sesecurityprivilege is not None:
            showIndent(outfile, level)
            outfile.write('sesecurityprivilege=model_.EntityStateBoolType(\n')
            self.sesecurityprivilege.exportLiteral(outfile, level, name_='sesecurityprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seshutdownprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seshutdownprivilege=model_.EntityStateBoolType(\n')
            self.seshutdownprivilege.exportLiteral(outfile, level, name_='seshutdownprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sesyncagentprivilege is not None:
            showIndent(outfile, level)
            outfile.write('sesyncagentprivilege=model_.EntityStateBoolType(\n')
            self.sesyncagentprivilege.exportLiteral(outfile, level, name_='sesyncagentprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sesystemenvironmentprivilege is not None:
            showIndent(outfile, level)
            outfile.write('sesystemenvironmentprivilege=model_.EntityStateBoolType(\n')
            self.sesystemenvironmentprivilege.exportLiteral(outfile, level, name_='sesystemenvironmentprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sesystemprofileprivilege is not None:
            showIndent(outfile, level)
            outfile.write('sesystemprofileprivilege=model_.EntityStateBoolType(\n')
            self.sesystemprofileprivilege.exportLiteral(outfile, level, name_='sesystemprofileprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sesystemtimeprivilege is not None:
            showIndent(outfile, level)
            outfile.write('sesystemtimeprivilege=model_.EntityStateBoolType(\n')
            self.sesystemtimeprivilege.exportLiteral(outfile, level, name_='sesystemtimeprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setakeownershipprivilege is not None:
            showIndent(outfile, level)
            outfile.write('setakeownershipprivilege=model_.EntityStateBoolType(\n')
            self.setakeownershipprivilege.exportLiteral(outfile, level, name_='setakeownershipprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setcbprivilege is not None:
            showIndent(outfile, level)
            outfile.write('setcbprivilege=model_.EntityStateBoolType(\n')
            self.setcbprivilege.exportLiteral(outfile, level, name_='setcbprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setimezoneprivilege is not None:
            showIndent(outfile, level)
            outfile.write('setimezoneprivilege=model_.EntityStateBoolType(\n')
            self.setimezoneprivilege.exportLiteral(outfile, level, name_='setimezoneprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seundockprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seundockprivilege=model_.EntityStateBoolType(\n')
            self.seundockprivilege.exportLiteral(outfile, level, name_='seundockprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seunsolicitedinputprivilege is not None:
            showIndent(outfile, level)
            outfile.write('seunsolicitedinputprivilege=model_.EntityStateBoolType(\n')
            self.seunsolicitedinputprivilege.exportLiteral(outfile, level, name_='seunsolicitedinputprivilege')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sebatchlogonright is not None:
            showIndent(outfile, level)
            outfile.write('sebatchlogonright=model_.EntityStateBoolType(\n')
            self.sebatchlogonright.exportLiteral(outfile, level, name_='sebatchlogonright')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seinteractivelogonright is not None:
            showIndent(outfile, level)
            outfile.write('seinteractivelogonright=model_.EntityStateBoolType(\n')
            self.seinteractivelogonright.exportLiteral(outfile, level, name_='seinteractivelogonright')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.senetworklogonright is not None:
            showIndent(outfile, level)
            outfile.write('senetworklogonright=model_.EntityStateBoolType(\n')
            self.senetworklogonright.exportLiteral(outfile, level, name_='senetworklogonright')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seremoteinteractivelogonright is not None:
            showIndent(outfile, level)
            outfile.write('seremoteinteractivelogonright=model_.EntityStateBoolType(\n')
            self.seremoteinteractivelogonright.exportLiteral(outfile, level, name_='seremoteinteractivelogonright')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.seservicelogonright is not None:
            showIndent(outfile, level)
            outfile.write('seservicelogonright=model_.EntityStateBoolType(\n')
            self.seservicelogonright.exportLiteral(outfile, level, name_='seservicelogonright')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sedenybatchLogonright is not None:
            showIndent(outfile, level)
            outfile.write('sedenybatchLogonright=model_.EntityStateBoolType(\n')
            self.sedenybatchLogonright.exportLiteral(outfile, level, name_='sedenybatchLogonright')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sedenyinteractivelogonright is not None:
            showIndent(outfile, level)
            outfile.write('sedenyinteractivelogonright=model_.EntityStateBoolType(\n')
            self.sedenyinteractivelogonright.exportLiteral(outfile, level, name_='sedenyinteractivelogonright')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sedenynetworklogonright is not None:
            showIndent(outfile, level)
            outfile.write('sedenynetworklogonright=model_.EntityStateBoolType(\n')
            self.sedenynetworklogonright.exportLiteral(outfile, level, name_='sedenynetworklogonright')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sedenyremoteInteractivelogonright is not None:
            showIndent(outfile, level)
            outfile.write('sedenyremoteInteractivelogonright=model_.EntityStateBoolType(\n')
            self.sedenyremoteInteractivelogonright.exportLiteral(outfile, level, name_='sedenyremoteInteractivelogonright')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sedenyservicelogonright is not None:
            showIndent(outfile, level)
            outfile.write('sedenyservicelogonright=model_.EntityStateBoolType(\n')
            self.sedenyservicelogonright.exportLiteral(outfile, level, name_='sedenyservicelogonright')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(accesstoken_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'security_principle':
            security_principle_ = child_.text
            self.security_principle = security_principle_
            self.validate_security_principle(self.security_principle)    # validate type security_principle
        elif nodeName_ == 'seassignprimarytokenprivilege': 
            obj_ = None
            self.set_seassignprimarytokenprivilege(obj_)
            self.validate_seassignprimarytokenprivilege(self.seassignprimarytokenprivilege)    # validate type seassignprimarytokenprivilege
        elif nodeName_ == 'seauditprivilege': 
            obj_ = None
            self.set_seauditprivilege(obj_)
            self.validate_seauditprivilege(self.seauditprivilege)    # validate type seauditprivilege
        elif nodeName_ == 'sebackupprivilege': 
            obj_ = None
            self.set_sebackupprivilege(obj_)
            self.validate_sebackupprivilege(self.sebackupprivilege)    # validate type sebackupprivilege
        elif nodeName_ == 'sechangenotifyprivilege': 
            obj_ = None
            self.set_sechangenotifyprivilege(obj_)
            self.validate_sechangenotifyprivilege(self.sechangenotifyprivilege)    # validate type sechangenotifyprivilege
        elif nodeName_ == 'secreateglobalprivilege': 
            obj_ = None
            self.set_secreateglobalprivilege(obj_)
            self.validate_secreateglobalprivilege(self.secreateglobalprivilege)    # validate type secreateglobalprivilege
        elif nodeName_ == 'secreatepagefileprivilege': 
            obj_ = None
            self.set_secreatepagefileprivilege(obj_)
            self.validate_secreatepagefileprivilege(self.secreatepagefileprivilege)    # validate type secreatepagefileprivilege
        elif nodeName_ == 'secreatepermanentprivilege': 
            obj_ = None
            self.set_secreatepermanentprivilege(obj_)
            self.validate_secreatepermanentprivilege(self.secreatepermanentprivilege)    # validate type secreatepermanentprivilege
        elif nodeName_ == 'secreatesymboliclinkprivilege': 
            obj_ = None
            self.set_secreatesymboliclinkprivilege(obj_)
            self.validate_secreatesymboliclinkprivilege(self.secreatesymboliclinkprivilege)    # validate type secreatesymboliclinkprivilege
        elif nodeName_ == 'secreatetokenprivilege': 
            obj_ = None
            self.set_secreatetokenprivilege(obj_)
            self.validate_secreatetokenprivilege(self.secreatetokenprivilege)    # validate type secreatetokenprivilege
        elif nodeName_ == 'sedebugprivilege': 
            obj_ = None
            self.set_sedebugprivilege(obj_)
            self.validate_sedebugprivilege(self.sedebugprivilege)    # validate type sedebugprivilege
        elif nodeName_ == 'seenabledelegationprivilege': 
            obj_ = None
            self.set_seenabledelegationprivilege(obj_)
            self.validate_seenabledelegationprivilege(self.seenabledelegationprivilege)    # validate type seenabledelegationprivilege
        elif nodeName_ == 'seimpersonateprivilege': 
            obj_ = None
            self.set_seimpersonateprivilege(obj_)
            self.validate_seimpersonateprivilege(self.seimpersonateprivilege)    # validate type seimpersonateprivilege
        elif nodeName_ == 'seincreasebasepriorityprivilege': 
            obj_ = None
            self.set_seincreasebasepriorityprivilege(obj_)
            self.validate_seincreasebasepriorityprivilege(self.seincreasebasepriorityprivilege)    # validate type seincreasebasepriorityprivilege
        elif nodeName_ == 'seincreasequotaprivilege': 
            obj_ = None
            self.set_seincreasequotaprivilege(obj_)
            self.validate_seincreasequotaprivilege(self.seincreasequotaprivilege)    # validate type seincreasequotaprivilege
        elif nodeName_ == 'seincreaseworkingsetprivilege': 
            obj_ = None
            self.set_seincreaseworkingsetprivilege(obj_)
            self.validate_seincreaseworkingsetprivilege(self.seincreaseworkingsetprivilege)    # validate type seincreaseworkingsetprivilege
        elif nodeName_ == 'seloaddriverprivilege': 
            obj_ = None
            self.set_seloaddriverprivilege(obj_)
            self.validate_seloaddriverprivilege(self.seloaddriverprivilege)    # validate type seloaddriverprivilege
        elif nodeName_ == 'selockmemoryprivilege': 
            obj_ = None
            self.set_selockmemoryprivilege(obj_)
            self.validate_selockmemoryprivilege(self.selockmemoryprivilege)    # validate type selockmemoryprivilege
        elif nodeName_ == 'semachineaccountprivilege': 
            obj_ = None
            self.set_semachineaccountprivilege(obj_)
            self.validate_semachineaccountprivilege(self.semachineaccountprivilege)    # validate type semachineaccountprivilege
        elif nodeName_ == 'semanagevolumeprivilege': 
            obj_ = None
            self.set_semanagevolumeprivilege(obj_)
            self.validate_semanagevolumeprivilege(self.semanagevolumeprivilege)    # validate type semanagevolumeprivilege
        elif nodeName_ == 'seprofilesingleprocessprivilege': 
            obj_ = None
            self.set_seprofilesingleprocessprivilege(obj_)
            self.validate_seprofilesingleprocessprivilege(self.seprofilesingleprocessprivilege)    # validate type seprofilesingleprocessprivilege
        elif nodeName_ == 'serelabelprivilege': 
            obj_ = None
            self.set_serelabelprivilege(obj_)
            self.validate_serelabelprivilege(self.serelabelprivilege)    # validate type serelabelprivilege
        elif nodeName_ == 'seremoteshutdownprivilege': 
            obj_ = None
            self.set_seremoteshutdownprivilege(obj_)
            self.validate_seremoteshutdownprivilege(self.seremoteshutdownprivilege)    # validate type seremoteshutdownprivilege
        elif nodeName_ == 'serestoreprivilege': 
            obj_ = None
            self.set_serestoreprivilege(obj_)
            self.validate_serestoreprivilege(self.serestoreprivilege)    # validate type serestoreprivilege
        elif nodeName_ == 'sesecurityprivilege': 
            obj_ = None
            self.set_sesecurityprivilege(obj_)
            self.validate_sesecurityprivilege(self.sesecurityprivilege)    # validate type sesecurityprivilege
        elif nodeName_ == 'seshutdownprivilege': 
            obj_ = None
            self.set_seshutdownprivilege(obj_)
            self.validate_seshutdownprivilege(self.seshutdownprivilege)    # validate type seshutdownprivilege
        elif nodeName_ == 'sesyncagentprivilege': 
            obj_ = None
            self.set_sesyncagentprivilege(obj_)
            self.validate_sesyncagentprivilege(self.sesyncagentprivilege)    # validate type sesyncagentprivilege
        elif nodeName_ == 'sesystemenvironmentprivilege': 
            obj_ = None
            self.set_sesystemenvironmentprivilege(obj_)
            self.validate_sesystemenvironmentprivilege(self.sesystemenvironmentprivilege)    # validate type sesystemenvironmentprivilege
        elif nodeName_ == 'sesystemprofileprivilege': 
            obj_ = None
            self.set_sesystemprofileprivilege(obj_)
            self.validate_sesystemprofileprivilege(self.sesystemprofileprivilege)    # validate type sesystemprofileprivilege
        elif nodeName_ == 'sesystemtimeprivilege': 
            obj_ = None
            self.set_sesystemtimeprivilege(obj_)
            self.validate_sesystemtimeprivilege(self.sesystemtimeprivilege)    # validate type sesystemtimeprivilege
        elif nodeName_ == 'setakeownershipprivilege': 
            obj_ = None
            self.set_setakeownershipprivilege(obj_)
            self.validate_setakeownershipprivilege(self.setakeownershipprivilege)    # validate type setakeownershipprivilege
        elif nodeName_ == 'setcbprivilege': 
            obj_ = None
            self.set_setcbprivilege(obj_)
            self.validate_setcbprivilege(self.setcbprivilege)    # validate type setcbprivilege
        elif nodeName_ == 'setimezoneprivilege': 
            obj_ = None
            self.set_setimezoneprivilege(obj_)
            self.validate_setimezoneprivilege(self.setimezoneprivilege)    # validate type setimezoneprivilege
        elif nodeName_ == 'seundockprivilege': 
            obj_ = None
            self.set_seundockprivilege(obj_)
            self.validate_seundockprivilege(self.seundockprivilege)    # validate type seundockprivilege
        elif nodeName_ == 'seunsolicitedinputprivilege': 
            obj_ = None
            self.set_seunsolicitedinputprivilege(obj_)
            self.validate_seunsolicitedinputprivilege(self.seunsolicitedinputprivilege)    # validate type seunsolicitedinputprivilege
        elif nodeName_ == 'sebatchlogonright': 
            obj_ = None
            self.set_sebatchlogonright(obj_)
            self.validate_sebatchlogonright(self.sebatchlogonright)    # validate type sebatchlogonright
        elif nodeName_ == 'seinteractivelogonright': 
            obj_ = None
            self.set_seinteractivelogonright(obj_)
            self.validate_seinteractivelogonright(self.seinteractivelogonright)    # validate type seinteractivelogonright
        elif nodeName_ == 'senetworklogonright': 
            obj_ = None
            self.set_senetworklogonright(obj_)
            self.validate_senetworklogonright(self.senetworklogonright)    # validate type senetworklogonright
        elif nodeName_ == 'seremoteinteractivelogonright': 
            obj_ = None
            self.set_seremoteinteractivelogonright(obj_)
            self.validate_seremoteinteractivelogonright(self.seremoteinteractivelogonright)    # validate type seremoteinteractivelogonright
        elif nodeName_ == 'seservicelogonright': 
            obj_ = None
            self.set_seservicelogonright(obj_)
            self.validate_seservicelogonright(self.seservicelogonright)    # validate type seservicelogonright
        elif nodeName_ == 'sedenybatchLogonright': 
            obj_ = None
            self.set_sedenybatchLogonright(obj_)
            self.validate_sedenybatchLogonright(self.sedenybatchLogonright)    # validate type sedenybatchLogonright
        elif nodeName_ == 'sedenyinteractivelogonright': 
            obj_ = None
            self.set_sedenyinteractivelogonright(obj_)
            self.validate_sedenyinteractivelogonright(self.sedenyinteractivelogonright)    # validate type sedenyinteractivelogonright
        elif nodeName_ == 'sedenynetworklogonright': 
            obj_ = None
            self.set_sedenynetworklogonright(obj_)
            self.validate_sedenynetworklogonright(self.sedenynetworklogonright)    # validate type sedenynetworklogonright
        elif nodeName_ == 'sedenyremoteInteractivelogonright': 
            obj_ = None
            self.set_sedenyremoteInteractivelogonright(obj_)
            self.validate_sedenyremoteInteractivelogonright(self.sedenyremoteInteractivelogonright)    # validate type sedenyremoteInteractivelogonright
        elif nodeName_ == 'sedenyservicelogonright': 
            obj_ = None
            self.set_sedenyservicelogonright(obj_)
            self.validate_sedenyservicelogonright(self.sedenyservicelogonright)    # validate type sedenyservicelogonright
        super(accesstoken_state, self).buildChildren(child_, nodeName_)
# end class accesstoken_state


class AccesstokenBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, include_group=True, resolve_group=False, valueOf_=None):
        self.include_group = _cast(bool, include_group)
        self.resolve_group = _cast(bool, resolve_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AccesstokenBehaviors.subclass:
            return AccesstokenBehaviors.subclass(*args_, **kwargs_)
        else:
            return AccesstokenBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='AccesstokenBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='AccesstokenBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='AccesstokenBehaviors'):
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='AccesstokenBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AccesstokenBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class AccesstokenBehaviors


class activedirectory_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=False, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(activedirectory_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if activedirectory_test.subclass:
            return activedirectory_test.subclass(*args_, **kwargs_)
        else:
            return activedirectory_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='activedirectory_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='activedirectory_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="activedirectory_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='activedirectory_test'):
        super(activedirectory_test, self).exportAttributes(outfile, level, namespace_, name_='activedirectory_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='activedirectory_test'):
        super(activedirectory_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(activedirectory_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='activedirectory_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(activedirectory_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(activedirectory_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(activedirectory_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(activedirectory_test, self).buildChildren(child_, nodeName_)
# end class activedirectory_test


class activedirectory_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=False, version=None, id=None, Signature=None, notes=None, set=None, naming_context=None, relative_dn=None, attribute=None):
        super(activedirectory_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.naming_context = naming_context
        self.relative_dn = relative_dn
        self.attribute = attribute
    def factory(*args_, **kwargs_):
        if activedirectory_object.subclass:
            return activedirectory_object.subclass(*args_, **kwargs_)
        else:
            return activedirectory_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_naming_context(self): return self.naming_context
    def set_naming_context(self, naming_context): self.naming_context = naming_context
    def get_relative_dn(self): return self.relative_dn
    def set_relative_dn(self, relative_dn): self.relative_dn = relative_dn
    def validate_relative_dn(self, value):
        # validate type relative_dn
        pass
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def validate_attribute(self, value):
        # validate type attribute
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='activedirectory_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='activedirectory_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="activedirectory_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='activedirectory_object'):
        super(activedirectory_object, self).exportAttributes(outfile, level, namespace_, name_='activedirectory_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='activedirectory_object'):
        super(activedirectory_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set', )
        if self.naming_context:
            self.naming_context.export(outfile, level, namespace_, name_='naming_context', )
        if self.relative_dn is not None:
            showIndent(outfile, level)
            outfile.write('<%srelative_dn>%s</%srelative_dn>\n' % (namespace_, self.format_string(quote_xml(self.relative_dn).encode(ExternalEncoding), input_name='relative_dn'), namespace_))
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('<%sattribute>%s</%sattribute>\n' % (namespace_, self.format_string(quote_xml(self.attribute).encode(ExternalEncoding), input_name='attribute'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.naming_context is not None or
            self.relative_dn is not None or
            self.attribute is not None or
            super(activedirectory_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='activedirectory_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(activedirectory_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(activedirectory_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.naming_context is not None:
            showIndent(outfile, level)
            outfile.write('naming_context=model_.EntityObjectNamingContextType(\n')
            self.naming_context.exportLiteral(outfile, level, name_='naming_context')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.relative_dn is not None:
            showIndent(outfile, level)
            outfile.write('relative_dn=%s,\n' % quote_python(self.relative_dn).encode(ExternalEncoding))
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('attribute=%s,\n' % quote_python(self.attribute).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(activedirectory_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'naming_context': 
            obj_ = EntityObjectNamingContextType.factory()
            obj_.build(child_)
            self.set_naming_context(obj_)
        elif nodeName_ == 'relative_dn':
            relative_dn_ = child_.text
            self.relative_dn = relative_dn_
            self.validate_relative_dn(self.relative_dn)    # validate type relative_dn
        elif nodeName_ == 'attribute':
            attribute_ = child_.text
            self.attribute = attribute_
            self.validate_attribute(self.attribute)    # validate type attribute
        super(activedirectory_object, self).buildChildren(child_, nodeName_)
# end class activedirectory_object


class activedirectory_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=False, Signature=None, notes=None, naming_context=None, relative_dn=None, attribute=None, object_class=None, adstype=None, value=None):
        super(activedirectory_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.naming_context = naming_context
        self.relative_dn = relative_dn
        self.attribute = attribute
        self.object_class = object_class
        self.adstype = adstype
        self.value = value
    def factory(*args_, **kwargs_):
        if activedirectory_state.subclass:
            return activedirectory_state.subclass(*args_, **kwargs_)
        else:
            return activedirectory_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_naming_context(self): return self.naming_context
    def set_naming_context(self, naming_context): self.naming_context = naming_context
    def get_relative_dn(self): return self.relative_dn
    def set_relative_dn(self, relative_dn): self.relative_dn = relative_dn
    def validate_relative_dn(self, value):
        # validate type relative_dn
        pass
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def validate_attribute(self, value):
        # validate type attribute
        pass
    def get_object_class(self): return self.object_class
    def set_object_class(self, object_class): self.object_class = object_class
    def validate_object_class(self, value):
        # validate type object_class
        pass
    def get_adstype(self): return self.adstype
    def set_adstype(self, adstype): self.adstype = adstype
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_value(self, value):
        # validate type value
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='activedirectory_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='activedirectory_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="activedirectory_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='activedirectory_state'):
        super(activedirectory_state, self).exportAttributes(outfile, level, namespace_, name_='activedirectory_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='activedirectory_state'):
        super(activedirectory_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.naming_context:
            self.naming_context.export(outfile, level, namespace_, name_='naming_context')
        if self.relative_dn is not None:
            showIndent(outfile, level)
            outfile.write('<%srelative_dn>%s</%srelative_dn>\n' % (namespace_, self.format_string(quote_xml(self.relative_dn).encode(ExternalEncoding), input_name='relative_dn'), namespace_))
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('<%sattribute>%s</%sattribute>\n' % (namespace_, self.format_string(quote_xml(self.attribute).encode(ExternalEncoding), input_name='attribute'), namespace_))
        if self.object_class is not None:
            showIndent(outfile, level)
            outfile.write('<%sobject_class>%s</%sobject_class>\n' % (namespace_, self.format_string(quote_xml(self.object_class).encode(ExternalEncoding), input_name='object_class'), namespace_))
        if self.adstype:
            self.adstype.export(outfile, level, namespace_, name_='adstype')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('<%svalue>%s</%svalue>\n' % (namespace_, self.format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_))
    def hasContent_(self):
        if (
            self.naming_context is not None or
            self.relative_dn is not None or
            self.attribute is not None or
            self.object_class is not None or
            self.adstype is not None or
            self.value is not None or
            super(activedirectory_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='activedirectory_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(activedirectory_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(activedirectory_state, self).exportLiteralChildren(outfile, level, name_)
        if self.naming_context is not None:
            showIndent(outfile, level)
            outfile.write('naming_context=model_.EntityStateNamingContextType(\n')
            self.naming_context.exportLiteral(outfile, level, name_='naming_context')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.relative_dn is not None:
            showIndent(outfile, level)
            outfile.write('relative_dn=%s,\n' % quote_python(self.relative_dn).encode(ExternalEncoding))
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('attribute=%s,\n' % quote_python(self.attribute).encode(ExternalEncoding))
        if self.object_class is not None:
            showIndent(outfile, level)
            outfile.write('object_class=%s,\n' % quote_python(self.object_class).encode(ExternalEncoding))
        if self.adstype is not None:
            showIndent(outfile, level)
            outfile.write('adstype=model_.EntityStateAdstypeType(\n')
            self.adstype.exportLiteral(outfile, level, name_='adstype')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(activedirectory_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'naming_context': 
            obj_ = EntityStateNamingContextType.factory()
            obj_.build(child_)
            self.set_naming_context(obj_)
        elif nodeName_ == 'relative_dn':
            relative_dn_ = child_.text
            self.relative_dn = relative_dn_
            self.validate_relative_dn(self.relative_dn)    # validate type relative_dn
        elif nodeName_ == 'attribute':
            attribute_ = child_.text
            self.attribute = attribute_
            self.validate_attribute(self.attribute)    # validate type attribute
        elif nodeName_ == 'object_class':
            object_class_ = child_.text
            self.object_class = object_class_
            self.validate_object_class(self.object_class)    # validate type object_class
        elif nodeName_ == 'adstype': 
            obj_ = EntityStateAdstypeType.factory()
            obj_.build(child_)
            self.set_adstype(obj_)
        elif nodeName_ == 'value':
            value_ = child_.text
            self.value = value_
            self.validate_value(self.value)    # validate type value
        super(activedirectory_state, self).buildChildren(child_, nodeName_)
# end class activedirectory_state


class activedirectory57_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=False, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(activedirectory57_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if activedirectory57_test.subclass:
            return activedirectory57_test.subclass(*args_, **kwargs_)
        else:
            return activedirectory57_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='activedirectory57_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='activedirectory57_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="activedirectory57_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='activedirectory57_test'):
        super(activedirectory57_test, self).exportAttributes(outfile, level, namespace_, name_='activedirectory57_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='activedirectory57_test'):
        super(activedirectory57_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(activedirectory57_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='activedirectory57_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(activedirectory57_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(activedirectory57_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(activedirectory57_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(activedirectory57_test, self).buildChildren(child_, nodeName_)
# end class activedirectory57_test


class activedirectory57_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=False, version=None, id=None, Signature=None, notes=None, set=None, naming_context=None, relative_dn=None, attribute=None):
        super(activedirectory57_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.naming_context = naming_context
        self.relative_dn = relative_dn
        self.attribute = attribute
    def factory(*args_, **kwargs_):
        if activedirectory57_object.subclass:
            return activedirectory57_object.subclass(*args_, **kwargs_)
        else:
            return activedirectory57_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_naming_context(self): return self.naming_context
    def set_naming_context(self, naming_context): self.naming_context = naming_context
    def get_relative_dn(self): return self.relative_dn
    def set_relative_dn(self, relative_dn): self.relative_dn = relative_dn
    def validate_relative_dn(self, value):
        # validate type relative_dn
        pass
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def validate_attribute(self, value):
        # validate type attribute
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='activedirectory57_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='activedirectory57_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="activedirectory57_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='activedirectory57_object'):
        super(activedirectory57_object, self).exportAttributes(outfile, level, namespace_, name_='activedirectory57_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='activedirectory57_object'):
        super(activedirectory57_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set', )
        if self.naming_context:
            self.naming_context.export(outfile, level, namespace_, name_='naming_context', )
        if self.relative_dn is not None:
            showIndent(outfile, level)
            outfile.write('<%srelative_dn>%s</%srelative_dn>\n' % (namespace_, self.format_string(quote_xml(self.relative_dn).encode(ExternalEncoding), input_name='relative_dn'), namespace_))
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('<%sattribute>%s</%sattribute>\n' % (namespace_, self.format_string(quote_xml(self.attribute).encode(ExternalEncoding), input_name='attribute'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.naming_context is not None or
            self.relative_dn is not None or
            self.attribute is not None or
            super(activedirectory57_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='activedirectory57_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(activedirectory57_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(activedirectory57_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.naming_context is not None:
            showIndent(outfile, level)
            outfile.write('naming_context=model_.EntityObjectNamingContextType(\n')
            self.naming_context.exportLiteral(outfile, level, name_='naming_context')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.relative_dn is not None:
            showIndent(outfile, level)
            outfile.write('relative_dn=%s,\n' % quote_python(self.relative_dn).encode(ExternalEncoding))
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('attribute=%s,\n' % quote_python(self.attribute).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(activedirectory57_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'naming_context': 
            obj_ = EntityObjectNamingContextType.factory()
            obj_.build(child_)
            self.set_naming_context(obj_)
        elif nodeName_ == 'relative_dn':
            relative_dn_ = child_.text
            self.relative_dn = relative_dn_
            self.validate_relative_dn(self.relative_dn)    # validate type relative_dn
        elif nodeName_ == 'attribute':
            attribute_ = child_.text
            self.attribute = attribute_
            self.validate_attribute(self.attribute)    # validate type attribute
        super(activedirectory57_object, self).buildChildren(child_, nodeName_)
# end class activedirectory57_object


class activedirectory57_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=False, Signature=None, notes=None, naming_context=None, relative_dn=None, attribute=None, object_class=None, adstype=None, value=None):
        super(activedirectory57_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.naming_context = naming_context
        self.relative_dn = relative_dn
        self.attribute = attribute
        self.object_class = object_class
        self.adstype = adstype
        self.value = value
    def factory(*args_, **kwargs_):
        if activedirectory57_state.subclass:
            return activedirectory57_state.subclass(*args_, **kwargs_)
        else:
            return activedirectory57_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_naming_context(self): return self.naming_context
    def set_naming_context(self, naming_context): self.naming_context = naming_context
    def get_relative_dn(self): return self.relative_dn
    def set_relative_dn(self, relative_dn): self.relative_dn = relative_dn
    def validate_relative_dn(self, value):
        # validate type relative_dn
        pass
    def get_attribute(self): return self.attribute
    def set_attribute(self, attribute): self.attribute = attribute
    def validate_attribute(self, value):
        # validate type attribute
        pass
    def get_object_class(self): return self.object_class
    def set_object_class(self, object_class): self.object_class = object_class
    def validate_object_class(self, value):
        # validate type object_class
        pass
    def get_adstype(self): return self.adstype
    def set_adstype(self, adstype): self.adstype = adstype
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='win-def:', name_='activedirectory57_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='activedirectory57_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="activedirectory57_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='activedirectory57_state'):
        super(activedirectory57_state, self).exportAttributes(outfile, level, namespace_, name_='activedirectory57_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='activedirectory57_state'):
        super(activedirectory57_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.naming_context:
            self.naming_context.export(outfile, level, namespace_, name_='naming_context')
        if self.relative_dn is not None:
            showIndent(outfile, level)
            outfile.write('<%srelative_dn>%s</%srelative_dn>\n' % (namespace_, self.format_string(quote_xml(self.relative_dn).encode(ExternalEncoding), input_name='relative_dn'), namespace_))
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('<%sattribute>%s</%sattribute>\n' % (namespace_, self.format_string(quote_xml(self.attribute).encode(ExternalEncoding), input_name='attribute'), namespace_))
        if self.object_class is not None:
            showIndent(outfile, level)
            outfile.write('<%sobject_class>%s</%sobject_class>\n' % (namespace_, self.format_string(quote_xml(self.object_class).encode(ExternalEncoding), input_name='object_class'), namespace_))
        if self.adstype:
            self.adstype.export(outfile, level, namespace_, name_='adstype')
        if self.value:
            self.value.export(outfile, level, namespace_, name_='value')
    def hasContent_(self):
        if (
            self.naming_context is not None or
            self.relative_dn is not None or
            self.attribute is not None or
            self.object_class is not None or
            self.adstype is not None or
            self.value is not None or
            super(activedirectory57_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='activedirectory57_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(activedirectory57_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(activedirectory57_state, self).exportLiteralChildren(outfile, level, name_)
        if self.naming_context is not None:
            showIndent(outfile, level)
            outfile.write('naming_context=model_.EntityStateNamingContextType(\n')
            self.naming_context.exportLiteral(outfile, level, name_='naming_context')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.relative_dn is not None:
            showIndent(outfile, level)
            outfile.write('relative_dn=%s,\n' % quote_python(self.relative_dn).encode(ExternalEncoding))
        if self.attribute is not None:
            showIndent(outfile, level)
            outfile.write('attribute=%s,\n' % quote_python(self.attribute).encode(ExternalEncoding))
        if self.object_class is not None:
            showIndent(outfile, level)
            outfile.write('object_class=%s,\n' % quote_python(self.object_class).encode(ExternalEncoding))
        if self.adstype is not None:
            showIndent(outfile, level)
            outfile.write('adstype=model_.EntityStateAdstypeType(\n')
            self.adstype.exportLiteral(outfile, level, name_='adstype')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.EntityStateRecordType(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(activedirectory57_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'naming_context': 
            obj_ = EntityStateNamingContextType.factory()
            obj_.build(child_)
            self.set_naming_context(obj_)
        elif nodeName_ == 'relative_dn':
            relative_dn_ = child_.text
            self.relative_dn = relative_dn_
            self.validate_relative_dn(self.relative_dn)    # validate type relative_dn
        elif nodeName_ == 'attribute':
            attribute_ = child_.text
            self.attribute = attribute_
            self.validate_attribute(self.attribute)    # validate type attribute
        elif nodeName_ == 'object_class':
            object_class_ = child_.text
            self.object_class = object_class_
            self.validate_object_class(self.object_class)    # validate type object_class
        elif nodeName_ == 'adstype': 
            obj_ = EntityStateAdstypeType.factory()
            obj_.build(child_)
            self.set_adstype(obj_)
        elif nodeName_ == 'value': 
            obj_ = EntityStateRecordType.factory()
            obj_.build(child_)
            self.set_value(obj_)
        super(activedirectory57_state, self).buildChildren(child_, nodeName_)
# end class activedirectory57_state


class auditeventpolicy_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=False, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(auditeventpolicy_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if auditeventpolicy_test.subclass:
            return auditeventpolicy_test.subclass(*args_, **kwargs_)
        else:
            return auditeventpolicy_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='auditeventpolicy_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='auditeventpolicy_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="auditeventpolicy_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='auditeventpolicy_test'):
        super(auditeventpolicy_test, self).exportAttributes(outfile, level, namespace_, name_='auditeventpolicy_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='auditeventpolicy_test'):
        super(auditeventpolicy_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(auditeventpolicy_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='auditeventpolicy_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(auditeventpolicy_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(auditeventpolicy_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(auditeventpolicy_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(auditeventpolicy_test, self).buildChildren(child_, nodeName_)
# end class auditeventpolicy_test


class auditeventpolicy_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=False, version=None, id=None, Signature=None, notes=None):
        super(auditeventpolicy_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        pass
    def factory(*args_, **kwargs_):
        if auditeventpolicy_object.subclass:
            return auditeventpolicy_object.subclass(*args_, **kwargs_)
        else:
            return auditeventpolicy_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='win-def:', name_='auditeventpolicy_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='auditeventpolicy_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="auditeventpolicy_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='auditeventpolicy_object'):
        super(auditeventpolicy_object, self).exportAttributes(outfile, level, namespace_, name_='auditeventpolicy_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='auditeventpolicy_object'):
        super(auditeventpolicy_object, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            super(auditeventpolicy_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='auditeventpolicy_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(auditeventpolicy_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(auditeventpolicy_object, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(auditeventpolicy_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        super(auditeventpolicy_object, self).buildChildren(child_, nodeName_)
        pass
# end class auditeventpolicy_object


class auditeventpolicy_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=False, Signature=None, notes=None, account_logon=None, account_management=None, detailed_tracking=None, directory_service_access=None, logon=None, object_access=None, policy_change=None, privilege_use=None, system=None):
        super(auditeventpolicy_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.account_logon = account_logon
        self.account_management = account_management
        self.detailed_tracking = detailed_tracking
        self.directory_service_access = directory_service_access
        self.logon = logon
        self.object_access = object_access
        self.policy_change = policy_change
        self.privilege_use = privilege_use
        self.system = system
    def factory(*args_, **kwargs_):
        if auditeventpolicy_state.subclass:
            return auditeventpolicy_state.subclass(*args_, **kwargs_)
        else:
            return auditeventpolicy_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_account_logon(self): return self.account_logon
    def set_account_logon(self, account_logon): self.account_logon = account_logon
    def get_account_management(self): return self.account_management
    def set_account_management(self, account_management): self.account_management = account_management
    def get_detailed_tracking(self): return self.detailed_tracking
    def set_detailed_tracking(self, detailed_tracking): self.detailed_tracking = detailed_tracking
    def get_directory_service_access(self): return self.directory_service_access
    def set_directory_service_access(self, directory_service_access): self.directory_service_access = directory_service_access
    def get_logon(self): return self.logon
    def set_logon(self, logon): self.logon = logon
    def get_object_access(self): return self.object_access
    def set_object_access(self, object_access): self.object_access = object_access
    def get_policy_change(self): return self.policy_change
    def set_policy_change(self, policy_change): self.policy_change = policy_change
    def get_privilege_use(self): return self.privilege_use
    def set_privilege_use(self, privilege_use): self.privilege_use = privilege_use
    def get_system(self): return self.system
    def set_system(self, system): self.system = system
    def export(self, outfile, level, namespace_='win-def:', name_='auditeventpolicy_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='auditeventpolicy_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="auditeventpolicy_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='auditeventpolicy_state'):
        super(auditeventpolicy_state, self).exportAttributes(outfile, level, namespace_, name_='auditeventpolicy_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='auditeventpolicy_state'):
        super(auditeventpolicy_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.account_logon:
            self.account_logon.export(outfile, level, namespace_, name_='account_logon')
        if self.account_management:
            self.account_management.export(outfile, level, namespace_, name_='account_management')
        if self.detailed_tracking:
            self.detailed_tracking.export(outfile, level, namespace_, name_='detailed_tracking')
        if self.directory_service_access:
            self.directory_service_access.export(outfile, level, namespace_, name_='directory_service_access')
        if self.logon:
            self.logon.export(outfile, level, namespace_, name_='logon')
        if self.object_access:
            self.object_access.export(outfile, level, namespace_, name_='object_access')
        if self.policy_change:
            self.policy_change.export(outfile, level, namespace_, name_='policy_change')
        if self.privilege_use:
            self.privilege_use.export(outfile, level, namespace_, name_='privilege_use')
        if self.system:
            self.system.export(outfile, level, namespace_, name_='system')
    def hasContent_(self):
        if (
            self.account_logon is not None or
            self.account_management is not None or
            self.detailed_tracking is not None or
            self.directory_service_access is not None or
            self.logon is not None or
            self.object_access is not None or
            self.policy_change is not None or
            self.privilege_use is not None or
            self.system is not None or
            super(auditeventpolicy_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='auditeventpolicy_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(auditeventpolicy_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(auditeventpolicy_state, self).exportLiteralChildren(outfile, level, name_)
        if self.account_logon is not None:
            showIndent(outfile, level)
            outfile.write('account_logon=model_.EntityStateAuditType(\n')
            self.account_logon.exportLiteral(outfile, level, name_='account_logon')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.account_management is not None:
            showIndent(outfile, level)
            outfile.write('account_management=model_.EntityStateAuditType(\n')
            self.account_management.exportLiteral(outfile, level, name_='account_management')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.detailed_tracking is not None:
            showIndent(outfile, level)
            outfile.write('detailed_tracking=model_.EntityStateAuditType(\n')
            self.detailed_tracking.exportLiteral(outfile, level, name_='detailed_tracking')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.directory_service_access is not None:
            showIndent(outfile, level)
            outfile.write('directory_service_access=model_.EntityStateAuditType(\n')
            self.directory_service_access.exportLiteral(outfile, level, name_='directory_service_access')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.logon is not None:
            showIndent(outfile, level)
            outfile.write('logon=model_.EntityStateAuditType(\n')
            self.logon.exportLiteral(outfile, level, name_='logon')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.object_access is not None:
            showIndent(outfile, level)
            outfile.write('object_access=model_.EntityStateAuditType(\n')
            self.object_access.exportLiteral(outfile, level, name_='object_access')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.policy_change is not None:
            showIndent(outfile, level)
            outfile.write('policy_change=model_.EntityStateAuditType(\n')
            self.policy_change.exportLiteral(outfile, level, name_='policy_change')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.privilege_use is not None:
            showIndent(outfile, level)
            outfile.write('privilege_use=model_.EntityStateAuditType(\n')
            self.privilege_use.exportLiteral(outfile, level, name_='privilege_use')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.system is not None:
            showIndent(outfile, level)
            outfile.write('system=model_.EntityStateAuditType(\n')
            self.system.exportLiteral(outfile, level, name_='system')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(auditeventpolicy_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'account_logon': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_account_logon(obj_)
        elif nodeName_ == 'account_management': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_account_management(obj_)
        elif nodeName_ == 'detailed_tracking': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_detailed_tracking(obj_)
        elif nodeName_ == 'directory_service_access': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_directory_service_access(obj_)
        elif nodeName_ == 'logon': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_logon(obj_)
        elif nodeName_ == 'object_access': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_object_access(obj_)
        elif nodeName_ == 'policy_change': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_policy_change(obj_)
        elif nodeName_ == 'privilege_use': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_privilege_use(obj_)
        elif nodeName_ == 'system': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_system(obj_)
        super(auditeventpolicy_state, self).buildChildren(child_, nodeName_)
# end class auditeventpolicy_state


class auditeventpolicysubcategories_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=False, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(auditeventpolicysubcategories_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if auditeventpolicysubcategories_test.subclass:
            return auditeventpolicysubcategories_test.subclass(*args_, **kwargs_)
        else:
            return auditeventpolicysubcategories_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='auditeventpolicysubcategories_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='auditeventpolicysubcategories_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="auditeventpolicysubcategories_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='auditeventpolicysubcategories_test'):
        super(auditeventpolicysubcategories_test, self).exportAttributes(outfile, level, namespace_, name_='auditeventpolicysubcategories_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='auditeventpolicysubcategories_test'):
        super(auditeventpolicysubcategories_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(auditeventpolicysubcategories_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='auditeventpolicysubcategories_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(auditeventpolicysubcategories_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(auditeventpolicysubcategories_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(auditeventpolicysubcategories_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(auditeventpolicysubcategories_test, self).buildChildren(child_, nodeName_)
# end class auditeventpolicysubcategories_test


class auditeventpolicysubcategories_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=False, version=None, id=None, Signature=None, notes=None):
        super(auditeventpolicysubcategories_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        pass
    def factory(*args_, **kwargs_):
        if auditeventpolicysubcategories_object.subclass:
            return auditeventpolicysubcategories_object.subclass(*args_, **kwargs_)
        else:
            return auditeventpolicysubcategories_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='win-def:', name_='auditeventpolicysubcategories_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='auditeventpolicysubcategories_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="auditeventpolicysubcategories_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='auditeventpolicysubcategories_object'):
        super(auditeventpolicysubcategories_object, self).exportAttributes(outfile, level, namespace_, name_='auditeventpolicysubcategories_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='auditeventpolicysubcategories_object'):
        super(auditeventpolicysubcategories_object, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            super(auditeventpolicysubcategories_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='auditeventpolicysubcategories_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(auditeventpolicysubcategories_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(auditeventpolicysubcategories_object, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(auditeventpolicysubcategories_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        super(auditeventpolicysubcategories_object, self).buildChildren(child_, nodeName_)
        pass
# end class auditeventpolicysubcategories_object


class auditeventpolicysubcategories_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=False, Signature=None, notes=None, credential_validation=None, kerberos_authentication_service=None, kerberos_service_ticket_operations=None, kerberos_ticket_events=None, other_account_logon_events=None, application_group_management=None, computer_account_management=None, distribution_group_management=None, other_account_management_events=None, security_group_management=None, user_account_management=None, dpapi_activity=None, process_creation=None, process_termination=None, rpc_events=None, directory_service_access=None, directory_service_changes=None, directory_service_replication=None, detailed_directory_service_replication=None, account_lockout=None, ipsec_extended_mode=None, ipsec_main_mode=None, ipsec_quick_mode=None, logoff=None, logon=None, network_policy_server=None, other_logon_logoff_events=None, special_logon=None, application_generated=None, certification_services=None, detailed_file_share=None, file_share=None, file_system=None, filtering_platform_connection=None, filtering_platform_packet_drop=None, handle_manipulation=None, kernel_object=None, other_object_access_events=None, registry=None, sam=None, audit_policy_change=None, authentication_policy_change=None, authorization_policy_change=None, filtering_platform_policy_change=None, mpssvc_rule_level_policy_change=None, other_policy_change_events=None, non_sensitive_privilege_use=None, other_privilege_use_events=None, sensitive_privilege_use=None, ipsec_driver=None, other_system_events=None, security_state_change=None, security_system_extension=None, system_integrity=None):
        super(auditeventpolicysubcategories_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.credential_validation = credential_validation
        self.kerberos_authentication_service = kerberos_authentication_service
        self.kerberos_service_ticket_operations = kerberos_service_ticket_operations
        self.kerberos_ticket_events = kerberos_ticket_events
        self.other_account_logon_events = other_account_logon_events
        self.application_group_management = application_group_management
        self.computer_account_management = computer_account_management
        self.distribution_group_management = distribution_group_management
        self.other_account_management_events = other_account_management_events
        self.security_group_management = security_group_management
        self.user_account_management = user_account_management
        self.dpapi_activity = dpapi_activity
        self.process_creation = process_creation
        self.process_termination = process_termination
        self.rpc_events = rpc_events
        self.directory_service_access = directory_service_access
        self.directory_service_changes = directory_service_changes
        self.directory_service_replication = directory_service_replication
        self.detailed_directory_service_replication = detailed_directory_service_replication
        self.account_lockout = account_lockout
        self.ipsec_extended_mode = ipsec_extended_mode
        self.ipsec_main_mode = ipsec_main_mode
        self.ipsec_quick_mode = ipsec_quick_mode
        self.logoff = logoff
        self.logon = logon
        self.network_policy_server = network_policy_server
        self.other_logon_logoff_events = other_logon_logoff_events
        self.special_logon = special_logon
        self.application_generated = application_generated
        self.certification_services = certification_services
        self.detailed_file_share = detailed_file_share
        self.file_share = file_share
        self.file_system = file_system
        self.filtering_platform_connection = filtering_platform_connection
        self.filtering_platform_packet_drop = filtering_platform_packet_drop
        self.handle_manipulation = handle_manipulation
        self.kernel_object = kernel_object
        self.other_object_access_events = other_object_access_events
        self.registry = registry
        self.sam = sam
        self.audit_policy_change = audit_policy_change
        self.authentication_policy_change = authentication_policy_change
        self.authorization_policy_change = authorization_policy_change
        self.filtering_platform_policy_change = filtering_platform_policy_change
        self.mpssvc_rule_level_policy_change = mpssvc_rule_level_policy_change
        self.other_policy_change_events = other_policy_change_events
        self.non_sensitive_privilege_use = non_sensitive_privilege_use
        self.other_privilege_use_events = other_privilege_use_events
        self.sensitive_privilege_use = sensitive_privilege_use
        self.ipsec_driver = ipsec_driver
        self.other_system_events = other_system_events
        self.security_state_change = security_state_change
        self.security_system_extension = security_system_extension
        self.system_integrity = system_integrity
    def factory(*args_, **kwargs_):
        if auditeventpolicysubcategories_state.subclass:
            return auditeventpolicysubcategories_state.subclass(*args_, **kwargs_)
        else:
            return auditeventpolicysubcategories_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_credential_validation(self): return self.credential_validation
    def set_credential_validation(self, credential_validation): self.credential_validation = credential_validation
    def get_kerberos_authentication_service(self): return self.kerberos_authentication_service
    def set_kerberos_authentication_service(self, kerberos_authentication_service): self.kerberos_authentication_service = kerberos_authentication_service
    def get_kerberos_service_ticket_operations(self): return self.kerberos_service_ticket_operations
    def set_kerberos_service_ticket_operations(self, kerberos_service_ticket_operations): self.kerberos_service_ticket_operations = kerberos_service_ticket_operations
    def get_kerberos_ticket_events(self): return self.kerberos_ticket_events
    def set_kerberos_ticket_events(self, kerberos_ticket_events): self.kerberos_ticket_events = kerberos_ticket_events
    def get_other_account_logon_events(self): return self.other_account_logon_events
    def set_other_account_logon_events(self, other_account_logon_events): self.other_account_logon_events = other_account_logon_events
    def get_application_group_management(self): return self.application_group_management
    def set_application_group_management(self, application_group_management): self.application_group_management = application_group_management
    def get_computer_account_management(self): return self.computer_account_management
    def set_computer_account_management(self, computer_account_management): self.computer_account_management = computer_account_management
    def get_distribution_group_management(self): return self.distribution_group_management
    def set_distribution_group_management(self, distribution_group_management): self.distribution_group_management = distribution_group_management
    def get_other_account_management_events(self): return self.other_account_management_events
    def set_other_account_management_events(self, other_account_management_events): self.other_account_management_events = other_account_management_events
    def get_security_group_management(self): return self.security_group_management
    def set_security_group_management(self, security_group_management): self.security_group_management = security_group_management
    def get_user_account_management(self): return self.user_account_management
    def set_user_account_management(self, user_account_management): self.user_account_management = user_account_management
    def get_dpapi_activity(self): return self.dpapi_activity
    def set_dpapi_activity(self, dpapi_activity): self.dpapi_activity = dpapi_activity
    def get_process_creation(self): return self.process_creation
    def set_process_creation(self, process_creation): self.process_creation = process_creation
    def get_process_termination(self): return self.process_termination
    def set_process_termination(self, process_termination): self.process_termination = process_termination
    def get_rpc_events(self): return self.rpc_events
    def set_rpc_events(self, rpc_events): self.rpc_events = rpc_events
    def get_directory_service_access(self): return self.directory_service_access
    def set_directory_service_access(self, directory_service_access): self.directory_service_access = directory_service_access
    def get_directory_service_changes(self): return self.directory_service_changes
    def set_directory_service_changes(self, directory_service_changes): self.directory_service_changes = directory_service_changes
    def get_directory_service_replication(self): return self.directory_service_replication
    def set_directory_service_replication(self, directory_service_replication): self.directory_service_replication = directory_service_replication
    def get_detailed_directory_service_replication(self): return self.detailed_directory_service_replication
    def set_detailed_directory_service_replication(self, detailed_directory_service_replication): self.detailed_directory_service_replication = detailed_directory_service_replication
    def get_account_lockout(self): return self.account_lockout
    def set_account_lockout(self, account_lockout): self.account_lockout = account_lockout
    def get_ipsec_extended_mode(self): return self.ipsec_extended_mode
    def set_ipsec_extended_mode(self, ipsec_extended_mode): self.ipsec_extended_mode = ipsec_extended_mode
    def get_ipsec_main_mode(self): return self.ipsec_main_mode
    def set_ipsec_main_mode(self, ipsec_main_mode): self.ipsec_main_mode = ipsec_main_mode
    def get_ipsec_quick_mode(self): return self.ipsec_quick_mode
    def set_ipsec_quick_mode(self, ipsec_quick_mode): self.ipsec_quick_mode = ipsec_quick_mode
    def get_logoff(self): return self.logoff
    def set_logoff(self, logoff): self.logoff = logoff
    def get_logon(self): return self.logon
    def set_logon(self, logon): self.logon = logon
    def get_network_policy_server(self): return self.network_policy_server
    def set_network_policy_server(self, network_policy_server): self.network_policy_server = network_policy_server
    def get_other_logon_logoff_events(self): return self.other_logon_logoff_events
    def set_other_logon_logoff_events(self, other_logon_logoff_events): self.other_logon_logoff_events = other_logon_logoff_events
    def get_special_logon(self): return self.special_logon
    def set_special_logon(self, special_logon): self.special_logon = special_logon
    def get_application_generated(self): return self.application_generated
    def set_application_generated(self, application_generated): self.application_generated = application_generated
    def get_certification_services(self): return self.certification_services
    def set_certification_services(self, certification_services): self.certification_services = certification_services
    def get_detailed_file_share(self): return self.detailed_file_share
    def set_detailed_file_share(self, detailed_file_share): self.detailed_file_share = detailed_file_share
    def get_file_share(self): return self.file_share
    def set_file_share(self, file_share): self.file_share = file_share
    def get_file_system(self): return self.file_system
    def set_file_system(self, file_system): self.file_system = file_system
    def get_filtering_platform_connection(self): return self.filtering_platform_connection
    def set_filtering_platform_connection(self, filtering_platform_connection): self.filtering_platform_connection = filtering_platform_connection
    def get_filtering_platform_packet_drop(self): return self.filtering_platform_packet_drop
    def set_filtering_platform_packet_drop(self, filtering_platform_packet_drop): self.filtering_platform_packet_drop = filtering_platform_packet_drop
    def get_handle_manipulation(self): return self.handle_manipulation
    def set_handle_manipulation(self, handle_manipulation): self.handle_manipulation = handle_manipulation
    def get_kernel_object(self): return self.kernel_object
    def set_kernel_object(self, kernel_object): self.kernel_object = kernel_object
    def get_other_object_access_events(self): return self.other_object_access_events
    def set_other_object_access_events(self, other_object_access_events): self.other_object_access_events = other_object_access_events
    def get_registry(self): return self.registry
    def set_registry(self, registry): self.registry = registry
    def get_sam(self): return self.sam
    def set_sam(self, sam): self.sam = sam
    def get_audit_policy_change(self): return self.audit_policy_change
    def set_audit_policy_change(self, audit_policy_change): self.audit_policy_change = audit_policy_change
    def get_authentication_policy_change(self): return self.authentication_policy_change
    def set_authentication_policy_change(self, authentication_policy_change): self.authentication_policy_change = authentication_policy_change
    def get_authorization_policy_change(self): return self.authorization_policy_change
    def set_authorization_policy_change(self, authorization_policy_change): self.authorization_policy_change = authorization_policy_change
    def get_filtering_platform_policy_change(self): return self.filtering_platform_policy_change
    def set_filtering_platform_policy_change(self, filtering_platform_policy_change): self.filtering_platform_policy_change = filtering_platform_policy_change
    def get_mpssvc_rule_level_policy_change(self): return self.mpssvc_rule_level_policy_change
    def set_mpssvc_rule_level_policy_change(self, mpssvc_rule_level_policy_change): self.mpssvc_rule_level_policy_change = mpssvc_rule_level_policy_change
    def get_other_policy_change_events(self): return self.other_policy_change_events
    def set_other_policy_change_events(self, other_policy_change_events): self.other_policy_change_events = other_policy_change_events
    def get_non_sensitive_privilege_use(self): return self.non_sensitive_privilege_use
    def set_non_sensitive_privilege_use(self, non_sensitive_privilege_use): self.non_sensitive_privilege_use = non_sensitive_privilege_use
    def get_other_privilege_use_events(self): return self.other_privilege_use_events
    def set_other_privilege_use_events(self, other_privilege_use_events): self.other_privilege_use_events = other_privilege_use_events
    def get_sensitive_privilege_use(self): return self.sensitive_privilege_use
    def set_sensitive_privilege_use(self, sensitive_privilege_use): self.sensitive_privilege_use = sensitive_privilege_use
    def get_ipsec_driver(self): return self.ipsec_driver
    def set_ipsec_driver(self, ipsec_driver): self.ipsec_driver = ipsec_driver
    def get_other_system_events(self): return self.other_system_events
    def set_other_system_events(self, other_system_events): self.other_system_events = other_system_events
    def get_security_state_change(self): return self.security_state_change
    def set_security_state_change(self, security_state_change): self.security_state_change = security_state_change
    def get_security_system_extension(self): return self.security_system_extension
    def set_security_system_extension(self, security_system_extension): self.security_system_extension = security_system_extension
    def get_system_integrity(self): return self.system_integrity
    def set_system_integrity(self, system_integrity): self.system_integrity = system_integrity
    def export(self, outfile, level, namespace_='win-def:', name_='auditeventpolicysubcategories_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='auditeventpolicysubcategories_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="auditeventpolicysubcategories_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='auditeventpolicysubcategories_state'):
        super(auditeventpolicysubcategories_state, self).exportAttributes(outfile, level, namespace_, name_='auditeventpolicysubcategories_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='auditeventpolicysubcategories_state'):
        super(auditeventpolicysubcategories_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.credential_validation:
            self.credential_validation.export(outfile, level, namespace_, name_='credential_validation')
        if self.kerberos_authentication_service:
            self.kerberos_authentication_service.export(outfile, level, namespace_, name_='kerberos_authentication_service')
        if self.kerberos_service_ticket_operations:
            self.kerberos_service_ticket_operations.export(outfile, level, namespace_, name_='kerberos_service_ticket_operations')
        if self.kerberos_ticket_events:
            self.kerberos_ticket_events.export(outfile, level, namespace_, name_='kerberos_ticket_events')
        if self.other_account_logon_events:
            self.other_account_logon_events.export(outfile, level, namespace_, name_='other_account_logon_events')
        if self.application_group_management:
            self.application_group_management.export(outfile, level, namespace_, name_='application_group_management')
        if self.computer_account_management:
            self.computer_account_management.export(outfile, level, namespace_, name_='computer_account_management')
        if self.distribution_group_management:
            self.distribution_group_management.export(outfile, level, namespace_, name_='distribution_group_management')
        if self.other_account_management_events:
            self.other_account_management_events.export(outfile, level, namespace_, name_='other_account_management_events')
        if self.security_group_management:
            self.security_group_management.export(outfile, level, namespace_, name_='security_group_management')
        if self.user_account_management:
            self.user_account_management.export(outfile, level, namespace_, name_='user_account_management')
        if self.dpapi_activity:
            self.dpapi_activity.export(outfile, level, namespace_, name_='dpapi_activity')
        if self.process_creation:
            self.process_creation.export(outfile, level, namespace_, name_='process_creation')
        if self.process_termination:
            self.process_termination.export(outfile, level, namespace_, name_='process_termination')
        if self.rpc_events:
            self.rpc_events.export(outfile, level, namespace_, name_='rpc_events')
        if self.directory_service_access:
            self.directory_service_access.export(outfile, level, namespace_, name_='directory_service_access')
        if self.directory_service_changes:
            self.directory_service_changes.export(outfile, level, namespace_, name_='directory_service_changes')
        if self.directory_service_replication:
            self.directory_service_replication.export(outfile, level, namespace_, name_='directory_service_replication')
        if self.detailed_directory_service_replication:
            self.detailed_directory_service_replication.export(outfile, level, namespace_, name_='detailed_directory_service_replication')
        if self.account_lockout:
            self.account_lockout.export(outfile, level, namespace_, name_='account_lockout')
        if self.ipsec_extended_mode:
            self.ipsec_extended_mode.export(outfile, level, namespace_, name_='ipsec_extended_mode')
        if self.ipsec_main_mode:
            self.ipsec_main_mode.export(outfile, level, namespace_, name_='ipsec_main_mode')
        if self.ipsec_quick_mode:
            self.ipsec_quick_mode.export(outfile, level, namespace_, name_='ipsec_quick_mode')
        if self.logoff:
            self.logoff.export(outfile, level, namespace_, name_='logoff')
        if self.logon:
            self.logon.export(outfile, level, namespace_, name_='logon')
        if self.network_policy_server:
            self.network_policy_server.export(outfile, level, namespace_, name_='network_policy_server')
        if self.other_logon_logoff_events:
            self.other_logon_logoff_events.export(outfile, level, namespace_, name_='other_logon_logoff_events')
        if self.special_logon:
            self.special_logon.export(outfile, level, namespace_, name_='special_logon')
        if self.application_generated:
            self.application_generated.export(outfile, level, namespace_, name_='application_generated')
        if self.certification_services:
            self.certification_services.export(outfile, level, namespace_, name_='certification_services')
        if self.detailed_file_share:
            self.detailed_file_share.export(outfile, level, namespace_, name_='detailed_file_share')
        if self.file_share:
            self.file_share.export(outfile, level, namespace_, name_='file_share')
        if self.file_system:
            self.file_system.export(outfile, level, namespace_, name_='file_system')
        if self.filtering_platform_connection:
            self.filtering_platform_connection.export(outfile, level, namespace_, name_='filtering_platform_connection')
        if self.filtering_platform_packet_drop:
            self.filtering_platform_packet_drop.export(outfile, level, namespace_, name_='filtering_platform_packet_drop')
        if self.handle_manipulation:
            self.handle_manipulation.export(outfile, level, namespace_, name_='handle_manipulation')
        if self.kernel_object:
            self.kernel_object.export(outfile, level, namespace_, name_='kernel_object')
        if self.other_object_access_events:
            self.other_object_access_events.export(outfile, level, namespace_, name_='other_object_access_events')
        if self.registry:
            self.registry.export(outfile, level, namespace_, name_='registry')
        if self.sam:
            self.sam.export(outfile, level, namespace_, name_='sam')
        if self.audit_policy_change:
            self.audit_policy_change.export(outfile, level, namespace_, name_='audit_policy_change')
        if self.authentication_policy_change:
            self.authentication_policy_change.export(outfile, level, namespace_, name_='authentication_policy_change')
        if self.authorization_policy_change:
            self.authorization_policy_change.export(outfile, level, namespace_, name_='authorization_policy_change')
        if self.filtering_platform_policy_change:
            self.filtering_platform_policy_change.export(outfile, level, namespace_, name_='filtering_platform_policy_change')
        if self.mpssvc_rule_level_policy_change:
            self.mpssvc_rule_level_policy_change.export(outfile, level, namespace_, name_='mpssvc_rule_level_policy_change')
        if self.other_policy_change_events:
            self.other_policy_change_events.export(outfile, level, namespace_, name_='other_policy_change_events')
        if self.non_sensitive_privilege_use:
            self.non_sensitive_privilege_use.export(outfile, level, namespace_, name_='non_sensitive_privilege_use')
        if self.other_privilege_use_events:
            self.other_privilege_use_events.export(outfile, level, namespace_, name_='other_privilege_use_events')
        if self.sensitive_privilege_use:
            self.sensitive_privilege_use.export(outfile, level, namespace_, name_='sensitive_privilege_use')
        if self.ipsec_driver:
            self.ipsec_driver.export(outfile, level, namespace_, name_='ipsec_driver')
        if self.other_system_events:
            self.other_system_events.export(outfile, level, namespace_, name_='other_system_events')
        if self.security_state_change:
            self.security_state_change.export(outfile, level, namespace_, name_='security_state_change')
        if self.security_system_extension:
            self.security_system_extension.export(outfile, level, namespace_, name_='security_system_extension')
        if self.system_integrity:
            self.system_integrity.export(outfile, level, namespace_, name_='system_integrity')
    def hasContent_(self):
        if (
            self.credential_validation is not None or
            self.kerberos_authentication_service is not None or
            self.kerberos_service_ticket_operations is not None or
            self.kerberos_ticket_events is not None or
            self.other_account_logon_events is not None or
            self.application_group_management is not None or
            self.computer_account_management is not None or
            self.distribution_group_management is not None or
            self.other_account_management_events is not None or
            self.security_group_management is not None or
            self.user_account_management is not None or
            self.dpapi_activity is not None or
            self.process_creation is not None or
            self.process_termination is not None or
            self.rpc_events is not None or
            self.directory_service_access is not None or
            self.directory_service_changes is not None or
            self.directory_service_replication is not None or
            self.detailed_directory_service_replication is not None or
            self.account_lockout is not None or
            self.ipsec_extended_mode is not None or
            self.ipsec_main_mode is not None or
            self.ipsec_quick_mode is not None or
            self.logoff is not None or
            self.logon is not None or
            self.network_policy_server is not None or
            self.other_logon_logoff_events is not None or
            self.special_logon is not None or
            self.application_generated is not None or
            self.certification_services is not None or
            self.detailed_file_share is not None or
            self.file_share is not None or
            self.file_system is not None or
            self.filtering_platform_connection is not None or
            self.filtering_platform_packet_drop is not None or
            self.handle_manipulation is not None or
            self.kernel_object is not None or
            self.other_object_access_events is not None or
            self.registry is not None or
            self.sam is not None or
            self.audit_policy_change is not None or
            self.authentication_policy_change is not None or
            self.authorization_policy_change is not None or
            self.filtering_platform_policy_change is not None or
            self.mpssvc_rule_level_policy_change is not None or
            self.other_policy_change_events is not None or
            self.non_sensitive_privilege_use is not None or
            self.other_privilege_use_events is not None or
            self.sensitive_privilege_use is not None or
            self.ipsec_driver is not None or
            self.other_system_events is not None or
            self.security_state_change is not None or
            self.security_system_extension is not None or
            self.system_integrity is not None or
            super(auditeventpolicysubcategories_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='auditeventpolicysubcategories_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(auditeventpolicysubcategories_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(auditeventpolicysubcategories_state, self).exportLiteralChildren(outfile, level, name_)
        if self.credential_validation is not None:
            showIndent(outfile, level)
            outfile.write('credential_validation=model_.EntityStateAuditType(\n')
            self.credential_validation.exportLiteral(outfile, level, name_='credential_validation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.kerberos_authentication_service is not None:
            showIndent(outfile, level)
            outfile.write('kerberos_authentication_service=model_.EntityStateAuditType(\n')
            self.kerberos_authentication_service.exportLiteral(outfile, level, name_='kerberos_authentication_service')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.kerberos_service_ticket_operations is not None:
            showIndent(outfile, level)
            outfile.write('kerberos_service_ticket_operations=model_.EntityStateAuditType(\n')
            self.kerberos_service_ticket_operations.exportLiteral(outfile, level, name_='kerberos_service_ticket_operations')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.kerberos_ticket_events is not None:
            showIndent(outfile, level)
            outfile.write('kerberos_ticket_events=model_.EntityStateAuditType(\n')
            self.kerberos_ticket_events.exportLiteral(outfile, level, name_='kerberos_ticket_events')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.other_account_logon_events is not None:
            showIndent(outfile, level)
            outfile.write('other_account_logon_events=model_.EntityStateAuditType(\n')
            self.other_account_logon_events.exportLiteral(outfile, level, name_='other_account_logon_events')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.application_group_management is not None:
            showIndent(outfile, level)
            outfile.write('application_group_management=model_.EntityStateAuditType(\n')
            self.application_group_management.exportLiteral(outfile, level, name_='application_group_management')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.computer_account_management is not None:
            showIndent(outfile, level)
            outfile.write('computer_account_management=model_.EntityStateAuditType(\n')
            self.computer_account_management.exportLiteral(outfile, level, name_='computer_account_management')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.distribution_group_management is not None:
            showIndent(outfile, level)
            outfile.write('distribution_group_management=model_.EntityStateAuditType(\n')
            self.distribution_group_management.exportLiteral(outfile, level, name_='distribution_group_management')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.other_account_management_events is not None:
            showIndent(outfile, level)
            outfile.write('other_account_management_events=model_.EntityStateAuditType(\n')
            self.other_account_management_events.exportLiteral(outfile, level, name_='other_account_management_events')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.security_group_management is not None:
            showIndent(outfile, level)
            outfile.write('security_group_management=model_.EntityStateAuditType(\n')
            self.security_group_management.exportLiteral(outfile, level, name_='security_group_management')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.user_account_management is not None:
            showIndent(outfile, level)
            outfile.write('user_account_management=model_.EntityStateAuditType(\n')
            self.user_account_management.exportLiteral(outfile, level, name_='user_account_management')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dpapi_activity is not None:
            showIndent(outfile, level)
            outfile.write('dpapi_activity=model_.EntityStateAuditType(\n')
            self.dpapi_activity.exportLiteral(outfile, level, name_='dpapi_activity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.process_creation is not None:
            showIndent(outfile, level)
            outfile.write('process_creation=model_.EntityStateAuditType(\n')
            self.process_creation.exportLiteral(outfile, level, name_='process_creation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.process_termination is not None:
            showIndent(outfile, level)
            outfile.write('process_termination=model_.EntityStateAuditType(\n')
            self.process_termination.exportLiteral(outfile, level, name_='process_termination')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rpc_events is not None:
            showIndent(outfile, level)
            outfile.write('rpc_events=model_.EntityStateAuditType(\n')
            self.rpc_events.exportLiteral(outfile, level, name_='rpc_events')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.directory_service_access is not None:
            showIndent(outfile, level)
            outfile.write('directory_service_access=model_.EntityStateAuditType(\n')
            self.directory_service_access.exportLiteral(outfile, level, name_='directory_service_access')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.directory_service_changes is not None:
            showIndent(outfile, level)
            outfile.write('directory_service_changes=model_.EntityStateAuditType(\n')
            self.directory_service_changes.exportLiteral(outfile, level, name_='directory_service_changes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.directory_service_replication is not None:
            showIndent(outfile, level)
            outfile.write('directory_service_replication=model_.EntityStateAuditType(\n')
            self.directory_service_replication.exportLiteral(outfile, level, name_='directory_service_replication')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.detailed_directory_service_replication is not None:
            showIndent(outfile, level)
            outfile.write('detailed_directory_service_replication=model_.EntityStateAuditType(\n')
            self.detailed_directory_service_replication.exportLiteral(outfile, level, name_='detailed_directory_service_replication')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.account_lockout is not None:
            showIndent(outfile, level)
            outfile.write('account_lockout=model_.EntityStateAuditType(\n')
            self.account_lockout.exportLiteral(outfile, level, name_='account_lockout')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ipsec_extended_mode is not None:
            showIndent(outfile, level)
            outfile.write('ipsec_extended_mode=model_.EntityStateAuditType(\n')
            self.ipsec_extended_mode.exportLiteral(outfile, level, name_='ipsec_extended_mode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ipsec_main_mode is not None:
            showIndent(outfile, level)
            outfile.write('ipsec_main_mode=model_.EntityStateAuditType(\n')
            self.ipsec_main_mode.exportLiteral(outfile, level, name_='ipsec_main_mode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ipsec_quick_mode is not None:
            showIndent(outfile, level)
            outfile.write('ipsec_quick_mode=model_.EntityStateAuditType(\n')
            self.ipsec_quick_mode.exportLiteral(outfile, level, name_='ipsec_quick_mode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.logoff is not None:
            showIndent(outfile, level)
            outfile.write('logoff=model_.EntityStateAuditType(\n')
            self.logoff.exportLiteral(outfile, level, name_='logoff')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.logon is not None:
            showIndent(outfile, level)
            outfile.write('logon=model_.EntityStateAuditType(\n')
            self.logon.exportLiteral(outfile, level, name_='logon')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.network_policy_server is not None:
            showIndent(outfile, level)
            outfile.write('network_policy_server=model_.EntityStateAuditType(\n')
            self.network_policy_server.exportLiteral(outfile, level, name_='network_policy_server')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.other_logon_logoff_events is not None:
            showIndent(outfile, level)
            outfile.write('other_logon_logoff_events=model_.EntityStateAuditType(\n')
            self.other_logon_logoff_events.exportLiteral(outfile, level, name_='other_logon_logoff_events')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.special_logon is not None:
            showIndent(outfile, level)
            outfile.write('special_logon=model_.EntityStateAuditType(\n')
            self.special_logon.exportLiteral(outfile, level, name_='special_logon')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.application_generated is not None:
            showIndent(outfile, level)
            outfile.write('application_generated=model_.EntityStateAuditType(\n')
            self.application_generated.exportLiteral(outfile, level, name_='application_generated')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.certification_services is not None:
            showIndent(outfile, level)
            outfile.write('certification_services=model_.EntityStateAuditType(\n')
            self.certification_services.exportLiteral(outfile, level, name_='certification_services')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.detailed_file_share is not None:
            showIndent(outfile, level)
            outfile.write('detailed_file_share=model_.EntityStateAuditType(\n')
            self.detailed_file_share.exportLiteral(outfile, level, name_='detailed_file_share')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_share is not None:
            showIndent(outfile, level)
            outfile.write('file_share=model_.EntityStateAuditType(\n')
            self.file_share.exportLiteral(outfile, level, name_='file_share')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_system is not None:
            showIndent(outfile, level)
            outfile.write('file_system=model_.EntityStateAuditType(\n')
            self.file_system.exportLiteral(outfile, level, name_='file_system')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.filtering_platform_connection is not None:
            showIndent(outfile, level)
            outfile.write('filtering_platform_connection=model_.EntityStateAuditType(\n')
            self.filtering_platform_connection.exportLiteral(outfile, level, name_='filtering_platform_connection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.filtering_platform_packet_drop is not None:
            showIndent(outfile, level)
            outfile.write('filtering_platform_packet_drop=model_.EntityStateAuditType(\n')
            self.filtering_platform_packet_drop.exportLiteral(outfile, level, name_='filtering_platform_packet_drop')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.handle_manipulation is not None:
            showIndent(outfile, level)
            outfile.write('handle_manipulation=model_.EntityStateAuditType(\n')
            self.handle_manipulation.exportLiteral(outfile, level, name_='handle_manipulation')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.kernel_object is not None:
            showIndent(outfile, level)
            outfile.write('kernel_object=model_.EntityStateAuditType(\n')
            self.kernel_object.exportLiteral(outfile, level, name_='kernel_object')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.other_object_access_events is not None:
            showIndent(outfile, level)
            outfile.write('other_object_access_events=model_.EntityStateAuditType(\n')
            self.other_object_access_events.exportLiteral(outfile, level, name_='other_object_access_events')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.registry is not None:
            showIndent(outfile, level)
            outfile.write('registry=model_.EntityStateAuditType(\n')
            self.registry.exportLiteral(outfile, level, name_='registry')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sam is not None:
            showIndent(outfile, level)
            outfile.write('sam=model_.EntityStateAuditType(\n')
            self.sam.exportLiteral(outfile, level, name_='sam')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.audit_policy_change is not None:
            showIndent(outfile, level)
            outfile.write('audit_policy_change=model_.EntityStateAuditType(\n')
            self.audit_policy_change.exportLiteral(outfile, level, name_='audit_policy_change')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.authentication_policy_change is not None:
            showIndent(outfile, level)
            outfile.write('authentication_policy_change=model_.EntityStateAuditType(\n')
            self.authentication_policy_change.exportLiteral(outfile, level, name_='authentication_policy_change')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.authorization_policy_change is not None:
            showIndent(outfile, level)
            outfile.write('authorization_policy_change=model_.EntityStateAuditType(\n')
            self.authorization_policy_change.exportLiteral(outfile, level, name_='authorization_policy_change')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.filtering_platform_policy_change is not None:
            showIndent(outfile, level)
            outfile.write('filtering_platform_policy_change=model_.EntityStateAuditType(\n')
            self.filtering_platform_policy_change.exportLiteral(outfile, level, name_='filtering_platform_policy_change')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mpssvc_rule_level_policy_change is not None:
            showIndent(outfile, level)
            outfile.write('mpssvc_rule_level_policy_change=model_.EntityStateAuditType(\n')
            self.mpssvc_rule_level_policy_change.exportLiteral(outfile, level, name_='mpssvc_rule_level_policy_change')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.other_policy_change_events is not None:
            showIndent(outfile, level)
            outfile.write('other_policy_change_events=model_.EntityStateAuditType(\n')
            self.other_policy_change_events.exportLiteral(outfile, level, name_='other_policy_change_events')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.non_sensitive_privilege_use is not None:
            showIndent(outfile, level)
            outfile.write('non_sensitive_privilege_use=model_.EntityStateAuditType(\n')
            self.non_sensitive_privilege_use.exportLiteral(outfile, level, name_='non_sensitive_privilege_use')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.other_privilege_use_events is not None:
            showIndent(outfile, level)
            outfile.write('other_privilege_use_events=model_.EntityStateAuditType(\n')
            self.other_privilege_use_events.exportLiteral(outfile, level, name_='other_privilege_use_events')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sensitive_privilege_use is not None:
            showIndent(outfile, level)
            outfile.write('sensitive_privilege_use=model_.EntityStateAuditType(\n')
            self.sensitive_privilege_use.exportLiteral(outfile, level, name_='sensitive_privilege_use')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ipsec_driver is not None:
            showIndent(outfile, level)
            outfile.write('ipsec_driver=model_.EntityStateAuditType(\n')
            self.ipsec_driver.exportLiteral(outfile, level, name_='ipsec_driver')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.other_system_events is not None:
            showIndent(outfile, level)
            outfile.write('other_system_events=model_.EntityStateAuditType(\n')
            self.other_system_events.exportLiteral(outfile, level, name_='other_system_events')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.security_state_change is not None:
            showIndent(outfile, level)
            outfile.write('security_state_change=model_.EntityStateAuditType(\n')
            self.security_state_change.exportLiteral(outfile, level, name_='security_state_change')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.security_system_extension is not None:
            showIndent(outfile, level)
            outfile.write('security_system_extension=model_.EntityStateAuditType(\n')
            self.security_system_extension.exportLiteral(outfile, level, name_='security_system_extension')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.system_integrity is not None:
            showIndent(outfile, level)
            outfile.write('system_integrity=model_.EntityStateAuditType(\n')
            self.system_integrity.exportLiteral(outfile, level, name_='system_integrity')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(auditeventpolicysubcategories_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'credential_validation': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_credential_validation(obj_)
        elif nodeName_ == 'kerberos_authentication_service': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_kerberos_authentication_service(obj_)
        elif nodeName_ == 'kerberos_service_ticket_operations': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_kerberos_service_ticket_operations(obj_)
        elif nodeName_ == 'kerberos_ticket_events': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_kerberos_ticket_events(obj_)
        elif nodeName_ == 'other_account_logon_events': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_other_account_logon_events(obj_)
        elif nodeName_ == 'application_group_management': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_application_group_management(obj_)
        elif nodeName_ == 'computer_account_management': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_computer_account_management(obj_)
        elif nodeName_ == 'distribution_group_management': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_distribution_group_management(obj_)
        elif nodeName_ == 'other_account_management_events': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_other_account_management_events(obj_)
        elif nodeName_ == 'security_group_management': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_security_group_management(obj_)
        elif nodeName_ == 'user_account_management': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_user_account_management(obj_)
        elif nodeName_ == 'dpapi_activity': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_dpapi_activity(obj_)
        elif nodeName_ == 'process_creation': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_process_creation(obj_)
        elif nodeName_ == 'process_termination': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_process_termination(obj_)
        elif nodeName_ == 'rpc_events': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_rpc_events(obj_)
        elif nodeName_ == 'directory_service_access': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_directory_service_access(obj_)
        elif nodeName_ == 'directory_service_changes': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_directory_service_changes(obj_)
        elif nodeName_ == 'directory_service_replication': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_directory_service_replication(obj_)
        elif nodeName_ == 'detailed_directory_service_replication': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_detailed_directory_service_replication(obj_)
        elif nodeName_ == 'account_lockout': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_account_lockout(obj_)
        elif nodeName_ == 'ipsec_extended_mode': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_ipsec_extended_mode(obj_)
        elif nodeName_ == 'ipsec_main_mode': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_ipsec_main_mode(obj_)
        elif nodeName_ == 'ipsec_quick_mode': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_ipsec_quick_mode(obj_)
        elif nodeName_ == 'logoff': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_logoff(obj_)
        elif nodeName_ == 'logon': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_logon(obj_)
        elif nodeName_ == 'network_policy_server': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_network_policy_server(obj_)
        elif nodeName_ == 'other_logon_logoff_events': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_other_logon_logoff_events(obj_)
        elif nodeName_ == 'special_logon': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_special_logon(obj_)
        elif nodeName_ == 'application_generated': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_application_generated(obj_)
        elif nodeName_ == 'certification_services': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_certification_services(obj_)
        elif nodeName_ == 'detailed_file_share': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_detailed_file_share(obj_)
        elif nodeName_ == 'file_share': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_share(obj_)
        elif nodeName_ == 'file_system': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_system(obj_)
        elif nodeName_ == 'filtering_platform_connection': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_filtering_platform_connection(obj_)
        elif nodeName_ == 'filtering_platform_packet_drop': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_filtering_platform_packet_drop(obj_)
        elif nodeName_ == 'handle_manipulation': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_handle_manipulation(obj_)
        elif nodeName_ == 'kernel_object': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_kernel_object(obj_)
        elif nodeName_ == 'other_object_access_events': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_other_object_access_events(obj_)
        elif nodeName_ == 'registry': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_registry(obj_)
        elif nodeName_ == 'sam': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_sam(obj_)
        elif nodeName_ == 'audit_policy_change': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_audit_policy_change(obj_)
        elif nodeName_ == 'authentication_policy_change': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_authentication_policy_change(obj_)
        elif nodeName_ == 'authorization_policy_change': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_authorization_policy_change(obj_)
        elif nodeName_ == 'filtering_platform_policy_change': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_filtering_platform_policy_change(obj_)
        elif nodeName_ == 'mpssvc_rule_level_policy_change': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_mpssvc_rule_level_policy_change(obj_)
        elif nodeName_ == 'other_policy_change_events': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_other_policy_change_events(obj_)
        elif nodeName_ == 'non_sensitive_privilege_use': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_non_sensitive_privilege_use(obj_)
        elif nodeName_ == 'other_privilege_use_events': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_other_privilege_use_events(obj_)
        elif nodeName_ == 'sensitive_privilege_use': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_sensitive_privilege_use(obj_)
        elif nodeName_ == 'ipsec_driver': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_ipsec_driver(obj_)
        elif nodeName_ == 'other_system_events': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_other_system_events(obj_)
        elif nodeName_ == 'security_state_change': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_security_state_change(obj_)
        elif nodeName_ == 'security_system_extension': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_security_system_extension(obj_)
        elif nodeName_ == 'system_integrity': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_system_integrity(obj_)
        super(auditeventpolicysubcategories_state, self).buildChildren(child_, nodeName_)
# end class auditeventpolicysubcategories_state


class dnscache_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=False, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(dnscache_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if dnscache_test.subclass:
            return dnscache_test.subclass(*args_, **kwargs_)
        else:
            return dnscache_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='dnscache_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dnscache_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="dnscache_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='dnscache_test'):
        super(dnscache_test, self).exportAttributes(outfile, level, namespace_, name_='dnscache_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='dnscache_test'):
        super(dnscache_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(dnscache_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dnscache_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(dnscache_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(dnscache_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(dnscache_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(dnscache_test, self).buildChildren(child_, nodeName_)
# end class dnscache_test


class dnscache_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=False, version=None, id=None, Signature=None, notes=None, set=None, domain_name=None):
        super(dnscache_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.domain_name = domain_name
    def factory(*args_, **kwargs_):
        if dnscache_object.subclass:
            return dnscache_object.subclass(*args_, **kwargs_)
        else:
            return dnscache_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_domain_name(self): return self.domain_name
    def set_domain_name(self, domain_name): self.domain_name = domain_name
    def validate_domain_name(self, value):
        # validate type domain_name
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='dnscache_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dnscache_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="dnscache_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='dnscache_object'):
        super(dnscache_object, self).exportAttributes(outfile, level, namespace_, name_='dnscache_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='dnscache_object'):
        super(dnscache_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.domain_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sdomain_name>%s</%sdomain_name>\n' % (namespace_, self.format_string(quote_xml(self.domain_name).encode(ExternalEncoding), input_name='domain_name'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.domain_name is not None or
            super(dnscache_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dnscache_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(dnscache_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(dnscache_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.domain_name is not None:
            showIndent(outfile, level)
            outfile.write('domain_name=%s,\n' % quote_python(self.domain_name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(dnscache_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'domain_name':
            domain_name_ = child_.text
            self.domain_name = domain_name_
            self.validate_domain_name(self.domain_name)    # validate type domain_name
        super(dnscache_object, self).buildChildren(child_, nodeName_)
# end class dnscache_object


class dnscache_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=False, Signature=None, notes=None, domain_name=None, ttl=None, ip_address=None):
        super(dnscache_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.domain_name = domain_name
        self.ttl = ttl
        self.ip_address = ip_address
    def factory(*args_, **kwargs_):
        if dnscache_state.subclass:
            return dnscache_state.subclass(*args_, **kwargs_)
        else:
            return dnscache_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_domain_name(self): return self.domain_name
    def set_domain_name(self, domain_name): self.domain_name = domain_name
    def validate_domain_name(self, value):
        # validate type domain_name
        pass
    def get_ttl(self): return self.ttl
    def set_ttl(self, ttl): self.ttl = ttl
    def validate_ttl(self, value):
        # validate type ttl
        pass
    def get_ip_address(self): return self.ip_address
    def set_ip_address(self, ip_address): self.ip_address = ip_address
    def validate_ip_address(self, value):
        # validate type ip_address
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='dnscache_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dnscache_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="dnscache_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='dnscache_state'):
        super(dnscache_state, self).exportAttributes(outfile, level, namespace_, name_='dnscache_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='dnscache_state'):
        super(dnscache_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.domain_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sdomain_name>%s</%sdomain_name>\n' % (namespace_, self.format_string(quote_xml(self.domain_name).encode(ExternalEncoding), input_name='domain_name'), namespace_))
        if self.ttl:
            self.ttl.export(outfile, level, namespace_, name_='ttl')
        if self.ip_address is not None:
            showIndent(outfile, level)
            outfile.write('<%sip_address>%s</%sip_address>\n' % (namespace_, self.format_string(quote_xml(self.ip_address).encode(ExternalEncoding), input_name='ip_address'), namespace_))
    def hasContent_(self):
        if (
            self.domain_name is not None or
            self.ttl is not None or
            self.ip_address is not None or
            super(dnscache_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dnscache_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(dnscache_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(dnscache_state, self).exportLiteralChildren(outfile, level, name_)
        if self.domain_name is not None:
            showIndent(outfile, level)
            outfile.write('domain_name=%s,\n' % quote_python(self.domain_name).encode(ExternalEncoding))
        if self.ttl is not None:
            showIndent(outfile, level)
            outfile.write('ttl=model_.EntityStateIntType(\n')
            self.ttl.exportLiteral(outfile, level, name_='ttl')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ip_address is not None:
            showIndent(outfile, level)
            outfile.write('ip_address=%s,\n' % quote_python(self.ip_address).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(dnscache_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'domain_name':
            domain_name_ = child_.text
            self.domain_name = domain_name_
            self.validate_domain_name(self.domain_name)    # validate type domain_name
        elif nodeName_ == 'ttl': 
            obj_ = None
            self.set_ttl(obj_)
            self.validate_ttl(self.ttl)    # validate type ttl
        elif nodeName_ == 'ip_address':
            ip_address_ = child_.text
            self.ip_address = ip_address_
            self.validate_ip_address(self.ip_address)    # validate type ip_address
        super(dnscache_state, self).buildChildren(child_, nodeName_)
# end class dnscache_state


class file_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(file_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if file_test.subclass:
            return file_test.subclass(*args_, **kwargs_)
        else:
            return file_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='file_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<win-def:file_test')
        self.exportAttributes(outfile, level, namespace_, name_='file_test')
        #outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        #outfile.write(' xsi:type="file_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</win-def:file_test>\n')
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='file_test'):
        super(file_test, self).exportAttributes(outfile, level, 'win-def:', name_='file_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='file_test'):
        super(file_test, self).exportChildren(outfile, level, 'win-def:', name_)
        if self.object:
            self.object.export(outfile, level, 'win-def:', name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, 'win-def:', name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(file_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='file_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(file_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(file_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(file_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(file_test, self).buildChildren(child_, nodeName_)
# end class file_test


class file_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, filepath=None, path=None, filename=None):
        super(file_object, self).__init__(comment, deprecated, version, id)
        self.set = set
        self.behaviors = behaviors
        self.filepath = filepath
        self.path = path
        self.filename = filename
    def factory(*args_, **kwargs_):
        if file_object.subclass:
            return file_object.subclass(*args_, **kwargs_)
        else:
            return file_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_filepath(self): return self.filepath
    def set_filepath(self, filepath): self.filepath = filepath
    def validate_filepath(self, value):
        # validate type filepath
        pass
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def validate_path(self, value):
        # validate type path
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='file_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<win-def:file_object')
        self.exportAttributes(outfile, level, namespace_, name_='file_object')
        #outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        #outfile.write(' xsi:type="file_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</win-def:file_object>\n')
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='file_object'):
        super(file_object, self).exportAttributes(outfile, level, namespace_, name_='file_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='file_object'):
        #super(file_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, 'win-def:', name_='set', )
        if self.behaviors:
            self.behaviors.export(outfile, level, 'win-def:', name_='behaviors')
        if self.filepath is not None:
            self.filepath.export(outfile, level, 'win-def:', name_='filepath')
        if self.path is not None:
            self.path.export(outfile, level, 'win-def:', name_='path')
        if self.filename is not None:
            self.filename.export(outfile, level, 'win-def:', name_='filename')
        else:
          showIndent(outfile, level)
          outfile.write('<%sfilename xsi:nil="true"/>\n' % ('win-def:'))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.filepath is not None or
            self.path is not None or
            self.filename is not None or
            super(file_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='file_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(file_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(file_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.FileBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.filepath is not None:
            showIndent(outfile, level)
            outfile.write('filepath=%s,\n' % quote_python(self.filepath).encode(ExternalEncoding))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(file_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = FileBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'filepath':
            filepath_ = child_.text
            self.filepath = filepath_
            self.validate_filepath(self.filepath)    # validate type filepath
        elif nodeName_ == 'path':
            path_ = child_.text
            self.path = path_
            self.validate_path(self.path)    # validate type path
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
        super(file_object, self).buildChildren(child_, nodeName_)
# end class file_object


class file_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, filepath=None, path=None, filename=None, owner=None, size=None, a_time=None, c_time=None, m_time=None, ms_checksum=None, type_=None, version_=None, development_class=None, company=None, internal_name=None, language=None, original_filename=None, product_name=None, product_version=None):
        super(file_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes)
        self.filepath = filepath
        self.path = path
        self.filename = filename
        self.owner = owner
        self.size = size
        self.a_time = a_time
        self.c_time = c_time
        self.m_time = m_time
        self.ms_checksum = ms_checksum
        self.version_ = version_
        self.type_ = type_
        self.development_class = development_class
        self.company = company
        self.internal_name = internal_name
        self.language = language
        self.original_filename = original_filename
        self.product_name = product_name
        self.product_version = product_version
    def factory(*args_, **kwargs_):
        if file_state.subclass:
            return file_state.subclass(*args_, **kwargs_)
        else:
            return file_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filepath(self): return self.filepath
    def set_filepath(self, filepath): self.filepath = filepath
    def validate_filepath(self, value):
        # validate type filepath
        pass
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def validate_path(self, value):
        # validate type path
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def validate_owner(self, value):
        # validate type owner
        pass
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def validate_size(self, value):
        # validate type size
        pass
    def get_a_time(self): return self.a_time
    def set_a_time(self, a_time): self.a_time = a_time
    def validate_a_time(self, value):
        # validate type a_time
        pass
    def get_c_time(self): return self.c_time
    def set_c_time(self, c_time): self.c_time = c_time
    def validate_c_time(self, value):
        # validate type c_time
        pass
    def get_m_time(self): return self.m_time
    def set_m_time(self, m_time): self.m_time = m_time
    def validate_m_time(self, value):
        # validate type m_time
        pass
    def get_ms_checksum(self): return self.ms_checksum
    def set_ms_checksum(self, ms_checksum): self.ms_checksum = ms_checksum
    def validate_ms_checksum(self, value):
        # validate type ms_checksum
        pass
    def get_version_(self): return self.version_
    def set_version_(self, version_): self.version_ = version_
    def validate_version(self, value):
        # validate type version
        pass
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_development_class(self): return self.development_class
    def set_development_class(self, development_class): self.development_class = development_class
    def validate_development_class(self, value):
        # validate type development_class
        pass
    def get_company(self): return self.company
    def set_company(self, company): self.company = company
    def validate_company(self, value):
        # validate type company
        pass
    def get_internal_name(self): return self.internal_name
    def set_internal_name(self, internal_name): self.internal_name = internal_name
    def validate_internal_name(self, value):
        # validate type internal_name
        pass
    def get_language(self): return self.language
    def set_language(self, language): self.language = language
    def validate_language(self, value):
        # validate type language
        pass
    def get_original_filename(self): return self.original_filename
    def set_original_filename(self, original_filename): self.original_filename = original_filename
    def validate_original_filename(self, value):
        # validate type original_filename
        pass
    def get_product_name(self): return self.product_name
    def set_product_name(self, product_name): self.product_name = product_name
    def validate_product_name(self, value):
        # validate type product_name
        pass
    def get_product_version(self): return self.product_version
    def set_product_version(self, product_version): self.product_version = product_version
    def validate_product_version(self, value):
        # validate type product_version
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='file_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % ('win-def:', 'file_state', namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='file_state')
        #outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        #outfile.write(' xsi:type="file_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % ('win-def:', 'file_state'))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='file_state'):
        super(file_state, self).exportAttributes(outfile, level, namespace_, name_='file_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='file_state'):
        super(file_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.filepath is not None:
            self.filepath.export(outfile, level, 'win-def:', name_='filepath')
        if self.path is not None:
            self.path.export(outfile, level, 'win-def:', name_='path')
        if self.filename is not None:
            self.filename.export(outfile, level, 'win-def:', name_='filename')
        if self.owner is not None:
            self.owner.export(outfile, level, 'win-def:', name_='owner')
        if self.size:
            self.size.export(outfile, level, 'win-def:', name_='size')
        if self.a_time:
            self.a_time.export(outfile, level, 'win-def:', name_='a_time')
        if self.c_time:
            self.c_time.export(outfile, level, 'win-def:', name_='c_time')
        if self.m_time:
            self.m_time.export(outfile, level, 'win-def:', name_='m_time')
        if self.ms_checksum is not None:
            self.ms_checksum.export(outfile, level, 'win-def:', name_='ms_checksum')
        if self.version_ is not None:
            self.version_.export(outfile, level, 'win-def:', name_='version')
        if self.type_:
            self.type_.export(outfile, level, 'win-def:', name_='type')
        if self.development_class is not None:
            self.development_class.export(outfile, level, 'win-def:', name_='development_class')
        if self.company is not None:
            self.company.export(outfile, level, 'win-def:', name_='company')
        if self.internal_name is not None:
            self.internal_name.export(outfile, level, 'win-def:', name_='internal_name')
        if self.language is not None:
            self.language.export(outfile, level, 'win-def:', name_='language')
        if self.original_filename is not None:
            self.original_filename.export(outfile, level, 'win-def:', name_='original_filename')
        if self.product_name is not None:
            self.product_name.export(outfile, level, 'win-def:', name_='product_name')
        if self.product_version is not None:
            self.product_version.export(outfile, level, 'win-def:', name_='product_version')
    def hasContent_(self):
        if (
            self.filepath is not None or
            self.path is not None or
            self.filename is not None or
            self.owner is not None or
            self.size is not None or
            self.a_time is not None or
            self.c_time is not None or
            self.m_time is not None or
            self.ms_checksum is not None or
            self.version_ is not None or
            self.type_ is not None or
            self.development_class is not None or
            self.company is not None or
            self.internal_name is not None or
            self.language is not None or
            self.original_filename is not None or
            self.product_name is not None or
            self.product_version is not None or
            super(file_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='file_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(file_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(file_state, self).exportLiteralChildren(outfile, level, name_)
        if self.filepath is not None:
            showIndent(outfile, level)
            outfile.write('filepath=%s,\n' % quote_python(self.filepath).encode(ExternalEncoding))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
        if self.owner is not None:
            showIndent(outfile, level)
            outfile.write('owner=%s,\n' % quote_python(self.owner).encode(ExternalEncoding))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=model_.EntityStateIntType(\n')
            self.size.exportLiteral(outfile, level, name_='size')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.a_time is not None:
            showIndent(outfile, level)
            outfile.write('a_time=model_.EntityStateIntType(\n')
            self.a_time.exportLiteral(outfile, level, name_='a_time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.c_time is not None:
            showIndent(outfile, level)
            outfile.write('c_time=model_.EntityStateIntType(\n')
            self.c_time.exportLiteral(outfile, level, name_='c_time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.m_time is not None:
            showIndent(outfile, level)
            outfile.write('m_time=model_.EntityStateIntType(\n')
            self.m_time.exportLiteral(outfile, level, name_='m_time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ms_checksum is not None:
            showIndent(outfile, level)
            outfile.write('ms_checksum=%s,\n' % quote_python(self.ms_checksum).encode(ExternalEncoding))
        if self.version_ is not None:
            showIndent(outfile, level)
            outfile.write('version=%s,\n' % quote_python(self.version_).encode(ExternalEncoding))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.EntityStateFileTypeType(\n')
            self.type_.exportLiteral(outfile, level, name_='type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.development_class is not None:
            showIndent(outfile, level)
            outfile.write('development_class=%s,\n' % quote_python(self.development_class).encode(ExternalEncoding))
        if self.company is not None:
            showIndent(outfile, level)
            outfile.write('company=%s,\n' % quote_python(self.company).encode(ExternalEncoding))
        if self.internal_name is not None:
            showIndent(outfile, level)
            outfile.write('internal_name=%s,\n' % quote_python(self.internal_name).encode(ExternalEncoding))
        if self.language is not None:
            showIndent(outfile, level)
            outfile.write('language=%s,\n' % quote_python(self.language).encode(ExternalEncoding))
        if self.original_filename is not None:
            showIndent(outfile, level)
            outfile.write('original_filename=%s,\n' % quote_python(self.original_filename).encode(ExternalEncoding))
        if self.product_name is not None:
            showIndent(outfile, level)
            outfile.write('product_name=%s,\n' % quote_python(self.product_name).encode(ExternalEncoding))
        if self.product_version is not None:
            showIndent(outfile, level)
            outfile.write('product_version=%s,\n' % quote_python(self.product_version).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(file_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'filepath':
            filepath_ = child_.text
            self.filepath = filepath_
            self.validate_filepath(self.filepath)    # validate type filepath
        elif nodeName_ == 'path':
            path_ = child_.text
            self.path = path_
            self.validate_path(self.path)    # validate type path
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
        elif nodeName_ == 'owner':
            owner_ = child_.text
            self.owner = owner_
            self.validate_owner(self.owner)    # validate type owner
        elif nodeName_ == 'size': 
            obj_ = None
            self.set_size(obj_)
            self.validate_size(self.size)    # validate type size
        elif nodeName_ == 'a_time': 
            obj_ = None
            self.set_a_time(obj_)
            self.validate_a_time(self.a_time)    # validate type a_time
        elif nodeName_ == 'c_time': 
            obj_ = None
            self.set_c_time(obj_)
            self.validate_c_time(self.c_time)    # validate type c_time
        elif nodeName_ == 'm_time': 
            obj_ = None
            self.set_m_time(obj_)
            self.validate_m_time(self.m_time)    # validate type m_time
        elif nodeName_ == 'ms_checksum':
            ms_checksum_ = child_.text
            self.ms_checksum = ms_checksum_
            self.validate_ms_checksum(self.ms_checksum)    # validate type ms_checksum
        elif nodeName_ == 'version_':
            version_ = child_.text
            self.version_ = version_
            self.validate_version(self.version_)    # validate type version
        elif nodeName_ == 'type': 
            obj_ = EntityStateFileTypeType.factory()
            obj_.build(child_)
            self.set_type(obj_)
        elif nodeName_ == 'development_class':
            development_class_ = child_.text
            self.development_class = development_class_
            self.validate_development_class(self.development_class)    # validate type development_class
        elif nodeName_ == 'company':
            company_ = child_.text
            self.company = company_
            self.validate_company(self.company)    # validate type company
        elif nodeName_ == 'internal_name':
            internal_name_ = child_.text
            self.internal_name = internal_name_
            self.validate_internal_name(self.internal_name)    # validate type internal_name
        elif nodeName_ == 'language':
            language_ = child_.text
            self.language = language_
            self.validate_language(self.language)    # validate type language
        elif nodeName_ == 'original_filename':
            original_filename_ = child_.text
            self.original_filename = original_filename_
            self.validate_original_filename(self.original_filename)    # validate type original_filename
        elif nodeName_ == 'product_name':
            product_name_ = child_.text
            self.product_name = product_name_
            self.validate_product_name(self.product_name)    # validate type product_name
        elif nodeName_ == 'product_version':
            product_version_ = child_.text
            self.product_version = product_version_
            self.validate_product_version(self.product_version)    # validate type product_version
        super(file_state, self).buildChildren(child_, nodeName_)
# end class file_state


class FileBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, recurse_file_system='all', recurse_direction='none', max_depth=-1, valueOf_=None):
        self.recurse_file_system = _cast(None, recurse_file_system)
        self.recurse_direction = _cast(None, recurse_direction)
        self.max_depth = _cast(int, max_depth)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FileBehaviors.subclass:
            return FileBehaviors.subclass(*args_, **kwargs_)
        else:
            return FileBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recurse_file_system(self): return self.recurse_file_system
    def set_recurse_file_system(self, recurse_file_system): self.recurse_file_system = recurse_file_system
    def get_recurse_direction(self): return self.recurse_direction
    def set_recurse_direction(self, recurse_direction): self.recurse_direction = recurse_direction
    def get_max_depth(self): return self.max_depth
    def set_max_depth(self, max_depth): self.max_depth = max_depth
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='FileBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='FileBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='FileBehaviors'):
        if self.recurse_file_system is not None:
            outfile.write(' recurse_file_system=%s' % (self.format_string(quote_attrib(self.recurse_file_system).encode(ExternalEncoding), input_name='recurse_file_system'), ))
        if self.recurse_direction is not None:
            outfile.write(' recurse_direction=%s' % (self.format_string(quote_attrib(self.recurse_direction).encode(ExternalEncoding), input_name='recurse_direction'), ))
        if self.max_depth is not None:
            outfile.write(' max_depth="%s"' % self.format_integer(self.max_depth, input_name='max_depth'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='FileBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FileBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.recurse_file_system is not None:
            showIndent(outfile, level)
            outfile.write('recurse_file_system = "%s",\n' % (self.recurse_file_system,))
        if self.recurse_direction is not None:
            showIndent(outfile, level)
            outfile.write('recurse_direction = "%s",\n' % (self.recurse_direction,))
        if self.max_depth is not None:
            showIndent(outfile, level)
            outfile.write('max_depth = %d,\n' % (self.max_depth,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('recurse_file_system')
        if value is not None:
            self.recurse_file_system = value
        value = attrs.get('recurse_direction')
        if value is not None:
            self.recurse_direction = value
        value = attrs.get('max_depth')
        if value is not None:
            try:
                self.max_depth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_):
        pass
# end class FileBehaviors


class fileauditedpermissions53_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(fileauditedpermissions53_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if fileauditedpermissions53_test.subclass:
            return fileauditedpermissions53_test.subclass(*args_, **kwargs_)
        else:
            return fileauditedpermissions53_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions53_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions53_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileauditedpermissions53_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions53_test'):
        super(fileauditedpermissions53_test, self).exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions53_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions53_test'):
        super(fileauditedpermissions53_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(fileauditedpermissions53_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileauditedpermissions53_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileauditedpermissions53_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileauditedpermissions53_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileauditedpermissions53_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(fileauditedpermissions53_test, self).buildChildren(child_, nodeName_)
# end class fileauditedpermissions53_test


class fileauditedpermissions53_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, filepath=None, path=None, filename=None, trustee_sid=None):
        super(fileauditedpermissions53_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.filepath = filepath
        self.path = path
        self.filename = filename
        self.trustee_sid = trustee_sid
    def factory(*args_, **kwargs_):
        if fileauditedpermissions53_object.subclass:
            return fileauditedpermissions53_object.subclass(*args_, **kwargs_)
        else:
            return fileauditedpermissions53_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_filepath(self): return self.filepath
    def set_filepath(self, filepath): self.filepath = filepath
    def validate_filepath(self, value):
        # validate type filepath
        pass
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def validate_path(self, value):
        # validate type path
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions53_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions53_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileauditedpermissions53_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions53_object'):
        super(fileauditedpermissions53_object, self).exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions53_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions53_object'):
        super(fileauditedpermissions53_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.filepath is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilepath>%s</%sfilepath>\n' % (namespace_, self.format_string(quote_xml(self.filepath).encode(ExternalEncoding), input_name='filepath'), namespace_))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('<%spath>%s</%spath>\n' % (namespace_, self.format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilename>%s</%sfilename>\n' % (namespace_, self.format_string(quote_xml(self.filename).encode(ExternalEncoding), input_name='filename'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.filepath is not None or
            self.path is not None or
            self.filename is not None or
            self.trustee_sid is not None or
            super(fileauditedpermissions53_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileauditedpermissions53_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileauditedpermissions53_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileauditedpermissions53_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.FileAuditPermissions53Behaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.filepath is not None:
            showIndent(outfile, level)
            outfile.write('filepath=%s,\n' % quote_python(self.filepath).encode(ExternalEncoding))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileauditedpermissions53_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = FileAuditPermissions53Behaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'filepath':
            filepath_ = child_.text
            self.filepath = filepath_
            self.validate_filepath(self.filepath)    # validate type filepath
        elif nodeName_ == 'path':
            path_ = child_.text
            self.path = path_
            self.validate_path(self.path)    # validate type path
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        super(fileauditedpermissions53_object, self).buildChildren(child_, nodeName_)
# end class fileauditedpermissions53_object


class fileauditedpermissions53_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, filepath=None, path=None, filename=None, trustee_sid=None, standard_delete=None, standard_read_control=None, standard_write_dac=None, standard_write_owner=None, standard_synchronize=None, access_system_security=None, generic_read=None, generic_write=None, generic_execute=None, generic_all=None, file_read_data=None, file_write_data=None, file_append_data=None, file_read_ea=None, file_write_ea=None, file_execute=None, file_delete_child=None, file_read_attributes=None, file_write_attributes=None):
        super(fileauditedpermissions53_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.filepath = filepath
        self.path = path
        self.filename = filename
        self.trustee_sid = trustee_sid
        self.standard_delete = standard_delete
        self.standard_read_control = standard_read_control
        self.standard_write_dac = standard_write_dac
        self.standard_write_owner = standard_write_owner
        self.standard_synchronize = standard_synchronize
        self.access_system_security = access_system_security
        self.generic_read = generic_read
        self.generic_write = generic_write
        self.generic_execute = generic_execute
        self.generic_all = generic_all
        self.file_read_data = file_read_data
        self.file_write_data = file_write_data
        self.file_append_data = file_append_data
        self.file_read_ea = file_read_ea
        self.file_write_ea = file_write_ea
        self.file_execute = file_execute
        self.file_delete_child = file_delete_child
        self.file_read_attributes = file_read_attributes
        self.file_write_attributes = file_write_attributes
    def factory(*args_, **kwargs_):
        if fileauditedpermissions53_state.subclass:
            return fileauditedpermissions53_state.subclass(*args_, **kwargs_)
        else:
            return fileauditedpermissions53_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filepath(self): return self.filepath
    def set_filepath(self, filepath): self.filepath = filepath
    def validate_filepath(self, value):
        # validate type filepath
        pass
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def validate_path(self, value):
        # validate type path
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def get_standard_delete(self): return self.standard_delete
    def set_standard_delete(self, standard_delete): self.standard_delete = standard_delete
    def get_standard_read_control(self): return self.standard_read_control
    def set_standard_read_control(self, standard_read_control): self.standard_read_control = standard_read_control
    def get_standard_write_dac(self): return self.standard_write_dac
    def set_standard_write_dac(self, standard_write_dac): self.standard_write_dac = standard_write_dac
    def get_standard_write_owner(self): return self.standard_write_owner
    def set_standard_write_owner(self, standard_write_owner): self.standard_write_owner = standard_write_owner
    def get_standard_synchronize(self): return self.standard_synchronize
    def set_standard_synchronize(self, standard_synchronize): self.standard_synchronize = standard_synchronize
    def get_access_system_security(self): return self.access_system_security
    def set_access_system_security(self, access_system_security): self.access_system_security = access_system_security
    def get_generic_read(self): return self.generic_read
    def set_generic_read(self, generic_read): self.generic_read = generic_read
    def get_generic_write(self): return self.generic_write
    def set_generic_write(self, generic_write): self.generic_write = generic_write
    def get_generic_execute(self): return self.generic_execute
    def set_generic_execute(self, generic_execute): self.generic_execute = generic_execute
    def get_generic_all(self): return self.generic_all
    def set_generic_all(self, generic_all): self.generic_all = generic_all
    def get_file_read_data(self): return self.file_read_data
    def set_file_read_data(self, file_read_data): self.file_read_data = file_read_data
    def get_file_write_data(self): return self.file_write_data
    def set_file_write_data(self, file_write_data): self.file_write_data = file_write_data
    def get_file_append_data(self): return self.file_append_data
    def set_file_append_data(self, file_append_data): self.file_append_data = file_append_data
    def get_file_read_ea(self): return self.file_read_ea
    def set_file_read_ea(self, file_read_ea): self.file_read_ea = file_read_ea
    def get_file_write_ea(self): return self.file_write_ea
    def set_file_write_ea(self, file_write_ea): self.file_write_ea = file_write_ea
    def get_file_execute(self): return self.file_execute
    def set_file_execute(self, file_execute): self.file_execute = file_execute
    def get_file_delete_child(self): return self.file_delete_child
    def set_file_delete_child(self, file_delete_child): self.file_delete_child = file_delete_child
    def get_file_read_attributes(self): return self.file_read_attributes
    def set_file_read_attributes(self, file_read_attributes): self.file_read_attributes = file_read_attributes
    def get_file_write_attributes(self): return self.file_write_attributes
    def set_file_write_attributes(self, file_write_attributes): self.file_write_attributes = file_write_attributes
    def export(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions53_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions53_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileauditedpermissions53_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions53_state'):
        super(fileauditedpermissions53_state, self).exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions53_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions53_state'):
        super(fileauditedpermissions53_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.filepath is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilepath>%s</%sfilepath>\n' % (namespace_, self.format_string(quote_xml(self.filepath).encode(ExternalEncoding), input_name='filepath'), namespace_))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('<%spath>%s</%spath>\n' % (namespace_, self.format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilename>%s</%sfilename>\n' % (namespace_, self.format_string(quote_xml(self.filename).encode(ExternalEncoding), input_name='filename'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
        if self.standard_delete:
            self.standard_delete.export(outfile, level, namespace_, name_='standard_delete')
        if self.standard_read_control:
            self.standard_read_control.export(outfile, level, namespace_, name_='standard_read_control')
        if self.standard_write_dac:
            self.standard_write_dac.export(outfile, level, namespace_, name_='standard_write_dac')
        if self.standard_write_owner:
            self.standard_write_owner.export(outfile, level, namespace_, name_='standard_write_owner')
        if self.standard_synchronize:
            self.standard_synchronize.export(outfile, level, namespace_, name_='standard_synchronize')
        if self.access_system_security:
            self.access_system_security.export(outfile, level, namespace_, name_='access_system_security')
        if self.generic_read:
            self.generic_read.export(outfile, level, namespace_, name_='generic_read')
        if self.generic_write:
            self.generic_write.export(outfile, level, namespace_, name_='generic_write')
        if self.generic_execute:
            self.generic_execute.export(outfile, level, namespace_, name_='generic_execute')
        if self.generic_all:
            self.generic_all.export(outfile, level, namespace_, name_='generic_all')
        if self.file_read_data:
            self.file_read_data.export(outfile, level, namespace_, name_='file_read_data')
        if self.file_write_data:
            self.file_write_data.export(outfile, level, namespace_, name_='file_write_data')
        if self.file_append_data:
            self.file_append_data.export(outfile, level, namespace_, name_='file_append_data')
        if self.file_read_ea:
            self.file_read_ea.export(outfile, level, namespace_, name_='file_read_ea')
        if self.file_write_ea:
            self.file_write_ea.export(outfile, level, namespace_, name_='file_write_ea')
        if self.file_execute:
            self.file_execute.export(outfile, level, namespace_, name_='file_execute')
        if self.file_delete_child:
            self.file_delete_child.export(outfile, level, namespace_, name_='file_delete_child')
        if self.file_read_attributes:
            self.file_read_attributes.export(outfile, level, namespace_, name_='file_read_attributes')
        if self.file_write_attributes:
            self.file_write_attributes.export(outfile, level, namespace_, name_='file_write_attributes')
    def hasContent_(self):
        if (
            self.filepath is not None or
            self.path is not None or
            self.filename is not None or
            self.trustee_sid is not None or
            self.standard_delete is not None or
            self.standard_read_control is not None or
            self.standard_write_dac is not None or
            self.standard_write_owner is not None or
            self.standard_synchronize is not None or
            self.access_system_security is not None or
            self.generic_read is not None or
            self.generic_write is not None or
            self.generic_execute is not None or
            self.generic_all is not None or
            self.file_read_data is not None or
            self.file_write_data is not None or
            self.file_append_data is not None or
            self.file_read_ea is not None or
            self.file_write_ea is not None or
            self.file_execute is not None or
            self.file_delete_child is not None or
            self.file_read_attributes is not None or
            self.file_write_attributes is not None or
            super(fileauditedpermissions53_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileauditedpermissions53_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileauditedpermissions53_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileauditedpermissions53_state, self).exportLiteralChildren(outfile, level, name_)
        if self.filepath is not None:
            showIndent(outfile, level)
            outfile.write('filepath=%s,\n' % quote_python(self.filepath).encode(ExternalEncoding))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
        if self.standard_delete is not None:
            showIndent(outfile, level)
            outfile.write('standard_delete=model_.EntityStateAuditType(\n')
            self.standard_delete.exportLiteral(outfile, level, name_='standard_delete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_read_control is not None:
            showIndent(outfile, level)
            outfile.write('standard_read_control=model_.EntityStateAuditType(\n')
            self.standard_read_control.exportLiteral(outfile, level, name_='standard_read_control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_dac is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_dac=model_.EntityStateAuditType(\n')
            self.standard_write_dac.exportLiteral(outfile, level, name_='standard_write_dac')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_owner is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_owner=model_.EntityStateAuditType(\n')
            self.standard_write_owner.exportLiteral(outfile, level, name_='standard_write_owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_synchronize is not None:
            showIndent(outfile, level)
            outfile.write('standard_synchronize=model_.EntityStateAuditType(\n')
            self.standard_synchronize.exportLiteral(outfile, level, name_='standard_synchronize')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_system_security is not None:
            showIndent(outfile, level)
            outfile.write('access_system_security=model_.EntityStateAuditType(\n')
            self.access_system_security.exportLiteral(outfile, level, name_='access_system_security')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_read is not None:
            showIndent(outfile, level)
            outfile.write('generic_read=model_.EntityStateAuditType(\n')
            self.generic_read.exportLiteral(outfile, level, name_='generic_read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_write is not None:
            showIndent(outfile, level)
            outfile.write('generic_write=model_.EntityStateAuditType(\n')
            self.generic_write.exportLiteral(outfile, level, name_='generic_write')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_execute is not None:
            showIndent(outfile, level)
            outfile.write('generic_execute=model_.EntityStateAuditType(\n')
            self.generic_execute.exportLiteral(outfile, level, name_='generic_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_all is not None:
            showIndent(outfile, level)
            outfile.write('generic_all=model_.EntityStateAuditType(\n')
            self.generic_all.exportLiteral(outfile, level, name_='generic_all')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_data is not None:
            showIndent(outfile, level)
            outfile.write('file_read_data=model_.EntityStateAuditType(\n')
            self.file_read_data.exportLiteral(outfile, level, name_='file_read_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_data is not None:
            showIndent(outfile, level)
            outfile.write('file_write_data=model_.EntityStateAuditType(\n')
            self.file_write_data.exportLiteral(outfile, level, name_='file_write_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_append_data is not None:
            showIndent(outfile, level)
            outfile.write('file_append_data=model_.EntityStateAuditType(\n')
            self.file_append_data.exportLiteral(outfile, level, name_='file_append_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_ea is not None:
            showIndent(outfile, level)
            outfile.write('file_read_ea=model_.EntityStateAuditType(\n')
            self.file_read_ea.exportLiteral(outfile, level, name_='file_read_ea')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_ea is not None:
            showIndent(outfile, level)
            outfile.write('file_write_ea=model_.EntityStateAuditType(\n')
            self.file_write_ea.exportLiteral(outfile, level, name_='file_write_ea')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_execute is not None:
            showIndent(outfile, level)
            outfile.write('file_execute=model_.EntityStateAuditType(\n')
            self.file_execute.exportLiteral(outfile, level, name_='file_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_delete_child is not None:
            showIndent(outfile, level)
            outfile.write('file_delete_child=model_.EntityStateAuditType(\n')
            self.file_delete_child.exportLiteral(outfile, level, name_='file_delete_child')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_attributes is not None:
            showIndent(outfile, level)
            outfile.write('file_read_attributes=model_.EntityStateAuditType(\n')
            self.file_read_attributes.exportLiteral(outfile, level, name_='file_read_attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_attributes is not None:
            showIndent(outfile, level)
            outfile.write('file_write_attributes=model_.EntityStateAuditType(\n')
            self.file_write_attributes.exportLiteral(outfile, level, name_='file_write_attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileauditedpermissions53_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'filepath':
            filepath_ = child_.text
            self.filepath = filepath_
            self.validate_filepath(self.filepath)    # validate type filepath
        elif nodeName_ == 'path':
            path_ = child_.text
            self.path = path_
            self.validate_path(self.path)    # validate type path
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        elif nodeName_ == 'standard_delete': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_delete(obj_)
        elif nodeName_ == 'standard_read_control': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_read_control(obj_)
        elif nodeName_ == 'standard_write_dac': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_write_dac(obj_)
        elif nodeName_ == 'standard_write_owner': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_write_owner(obj_)
        elif nodeName_ == 'standard_synchronize': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_synchronize(obj_)
        elif nodeName_ == 'access_system_security': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_access_system_security(obj_)
        elif nodeName_ == 'generic_read': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_read(obj_)
        elif nodeName_ == 'generic_write': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_write(obj_)
        elif nodeName_ == 'generic_execute': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_execute(obj_)
        elif nodeName_ == 'generic_all': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_all(obj_)
        elif nodeName_ == 'file_read_data': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_read_data(obj_)
        elif nodeName_ == 'file_write_data': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_write_data(obj_)
        elif nodeName_ == 'file_append_data': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_append_data(obj_)
        elif nodeName_ == 'file_read_ea': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_read_ea(obj_)
        elif nodeName_ == 'file_write_ea': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_write_ea(obj_)
        elif nodeName_ == 'file_execute': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_execute(obj_)
        elif nodeName_ == 'file_delete_child': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_delete_child(obj_)
        elif nodeName_ == 'file_read_attributes': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_read_attributes(obj_)
        elif nodeName_ == 'file_write_attributes': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_write_attributes(obj_)
        super(fileauditedpermissions53_state, self).buildChildren(child_, nodeName_)
# end class fileauditedpermissions53_state


class FileAuditPermissions53Behaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resolve_group=False, recurse_file_system='all', recurse_direction='none', max_depth=-1, include_group=True, valueOf_=None):
        self.resolve_group = _cast(bool, resolve_group)
        self.recurse_file_system = _cast(None, recurse_file_system)
        self.recurse_direction = _cast(None, recurse_direction)
        self.max_depth = _cast(int, max_depth)
        self.include_group = _cast(bool, include_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FileAuditPermissions53Behaviors.subclass:
            return FileAuditPermissions53Behaviors.subclass(*args_, **kwargs_)
        else:
            return FileAuditPermissions53Behaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_recurse_file_system(self): return self.recurse_file_system
    def set_recurse_file_system(self, recurse_file_system): self.recurse_file_system = recurse_file_system
    def get_recurse_direction(self): return self.recurse_direction
    def set_recurse_direction(self, recurse_direction): self.recurse_direction = recurse_direction
    def get_max_depth(self): return self.max_depth
    def set_max_depth(self, max_depth): self.max_depth = max_depth
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='FileAuditPermissions53Behaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='FileAuditPermissions53Behaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='FileAuditPermissions53Behaviors'):
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
        if self.recurse_file_system is not None:
            outfile.write(' recurse_file_system=%s' % (self.format_string(quote_attrib(self.recurse_file_system).encode(ExternalEncoding), input_name='recurse_file_system'), ))
        if self.recurse_direction is not None:
            outfile.write(' recurse_direction=%s' % (self.format_string(quote_attrib(self.recurse_direction).encode(ExternalEncoding), input_name='recurse_direction'), ))
        if self.max_depth is not None:
            outfile.write(' max_depth="%s"' % self.format_integer(self.max_depth, input_name='max_depth'))
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='FileAuditPermissions53Behaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FileAuditPermissions53Behaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
        if self.recurse_file_system is not None:
            showIndent(outfile, level)
            outfile.write('recurse_file_system = "%s",\n' % (self.recurse_file_system,))
        if self.recurse_direction is not None:
            showIndent(outfile, level)
            outfile.write('recurse_direction = "%s",\n' % (self.recurse_direction,))
        if self.max_depth is not None:
            showIndent(outfile, level)
            outfile.write('max_depth = %d,\n' % (self.max_depth,))
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('recurse_file_system')
        if value is not None:
            self.recurse_file_system = value
        value = attrs.get('recurse_direction')
        if value is not None:
            self.recurse_direction = value
        value = attrs.get('max_depth')
        if value is not None:
            try:
                self.max_depth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class FileAuditPermissions53Behaviors


class fileauditedpermissions_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(fileauditedpermissions_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if fileauditedpermissions_test.subclass:
            return fileauditedpermissions_test.subclass(*args_, **kwargs_)
        else:
            return fileauditedpermissions_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileauditedpermissions_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions_test'):
        super(fileauditedpermissions_test, self).exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions_test'):
        super(fileauditedpermissions_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(fileauditedpermissions_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileauditedpermissions_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileauditedpermissions_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileauditedpermissions_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileauditedpermissions_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(fileauditedpermissions_test, self).buildChildren(child_, nodeName_)
# end class fileauditedpermissions_test


class fileauditedpermissions_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, path=None, filename=None, trustee_name=None):
        super(fileauditedpermissions_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.path = path
        self.filename = filename
        self.trustee_name = trustee_name
    def factory(*args_, **kwargs_):
        if fileauditedpermissions_object.subclass:
            return fileauditedpermissions_object.subclass(*args_, **kwargs_)
        else:
            return fileauditedpermissions_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def validate_path(self, value):
        # validate type path
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileauditedpermissions_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions_object'):
        super(fileauditedpermissions_object, self).exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions_object'):
        super(fileauditedpermissions_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('<%spath>%s</%spath>\n' % (namespace_, self.format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilename>%s</%sfilename>\n' % (namespace_, self.format_string(quote_xml(self.filename).encode(ExternalEncoding), input_name='filename'), namespace_))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.path is not None or
            self.filename is not None or
            self.trustee_name is not None or
            super(fileauditedpermissions_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileauditedpermissions_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileauditedpermissions_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileauditedpermissions_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.FileAuditPermissionsBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileauditedpermissions_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = FileAuditPermissionsBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'path':
            path_ = child_.text
            self.path = path_
            self.validate_path(self.path)    # validate type path
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
        elif nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        super(fileauditedpermissions_object, self).buildChildren(child_, nodeName_)
# end class fileauditedpermissions_object


class fileauditedpermissions_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, path=None, filename=None, trustee_name=None, standard_delete=None, standard_read_control=None, standard_write_dac=None, standard_write_owner=None, standard_synchronize=None, access_system_security=None, generic_read=None, generic_write=None, generic_execute=None, generic_all=None, file_read_data=None, file_write_data=None, file_append_data=None, file_read_ea=None, file_write_ea=None, file_execute=None, file_delete_child=None, file_read_attributes=None, file_write_attributes=None):
        super(fileauditedpermissions_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.path = path
        self.filename = filename
        self.trustee_name = trustee_name
        self.standard_delete = standard_delete
        self.standard_read_control = standard_read_control
        self.standard_write_dac = standard_write_dac
        self.standard_write_owner = standard_write_owner
        self.standard_synchronize = standard_synchronize
        self.access_system_security = access_system_security
        self.generic_read = generic_read
        self.generic_write = generic_write
        self.generic_execute = generic_execute
        self.generic_all = generic_all
        self.file_read_data = file_read_data
        self.file_write_data = file_write_data
        self.file_append_data = file_append_data
        self.file_read_ea = file_read_ea
        self.file_write_ea = file_write_ea
        self.file_execute = file_execute
        self.file_delete_child = file_delete_child
        self.file_read_attributes = file_read_attributes
        self.file_write_attributes = file_write_attributes
    def factory(*args_, **kwargs_):
        if fileauditedpermissions_state.subclass:
            return fileauditedpermissions_state.subclass(*args_, **kwargs_)
        else:
            return fileauditedpermissions_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def validate_path(self, value):
        # validate type path
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def get_standard_delete(self): return self.standard_delete
    def set_standard_delete(self, standard_delete): self.standard_delete = standard_delete
    def get_standard_read_control(self): return self.standard_read_control
    def set_standard_read_control(self, standard_read_control): self.standard_read_control = standard_read_control
    def get_standard_write_dac(self): return self.standard_write_dac
    def set_standard_write_dac(self, standard_write_dac): self.standard_write_dac = standard_write_dac
    def get_standard_write_owner(self): return self.standard_write_owner
    def set_standard_write_owner(self, standard_write_owner): self.standard_write_owner = standard_write_owner
    def get_standard_synchronize(self): return self.standard_synchronize
    def set_standard_synchronize(self, standard_synchronize): self.standard_synchronize = standard_synchronize
    def get_access_system_security(self): return self.access_system_security
    def set_access_system_security(self, access_system_security): self.access_system_security = access_system_security
    def get_generic_read(self): return self.generic_read
    def set_generic_read(self, generic_read): self.generic_read = generic_read
    def get_generic_write(self): return self.generic_write
    def set_generic_write(self, generic_write): self.generic_write = generic_write
    def get_generic_execute(self): return self.generic_execute
    def set_generic_execute(self, generic_execute): self.generic_execute = generic_execute
    def get_generic_all(self): return self.generic_all
    def set_generic_all(self, generic_all): self.generic_all = generic_all
    def get_file_read_data(self): return self.file_read_data
    def set_file_read_data(self, file_read_data): self.file_read_data = file_read_data
    def get_file_write_data(self): return self.file_write_data
    def set_file_write_data(self, file_write_data): self.file_write_data = file_write_data
    def get_file_append_data(self): return self.file_append_data
    def set_file_append_data(self, file_append_data): self.file_append_data = file_append_data
    def get_file_read_ea(self): return self.file_read_ea
    def set_file_read_ea(self, file_read_ea): self.file_read_ea = file_read_ea
    def get_file_write_ea(self): return self.file_write_ea
    def set_file_write_ea(self, file_write_ea): self.file_write_ea = file_write_ea
    def get_file_execute(self): return self.file_execute
    def set_file_execute(self, file_execute): self.file_execute = file_execute
    def get_file_delete_child(self): return self.file_delete_child
    def set_file_delete_child(self, file_delete_child): self.file_delete_child = file_delete_child
    def get_file_read_attributes(self): return self.file_read_attributes
    def set_file_read_attributes(self, file_read_attributes): self.file_read_attributes = file_read_attributes
    def get_file_write_attributes(self): return self.file_write_attributes
    def set_file_write_attributes(self, file_write_attributes): self.file_write_attributes = file_write_attributes
    def export(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileauditedpermissions_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions_state'):
        super(fileauditedpermissions_state, self).exportAttributes(outfile, level, namespace_, name_='fileauditedpermissions_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileauditedpermissions_state'):
        super(fileauditedpermissions_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('<%spath>%s</%spath>\n' % (namespace_, self.format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilename>%s</%sfilename>\n' % (namespace_, self.format_string(quote_xml(self.filename).encode(ExternalEncoding), input_name='filename'), namespace_))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
        if self.standard_delete:
            self.standard_delete.export(outfile, level, namespace_, name_='standard_delete')
        if self.standard_read_control:
            self.standard_read_control.export(outfile, level, namespace_, name_='standard_read_control')
        if self.standard_write_dac:
            self.standard_write_dac.export(outfile, level, namespace_, name_='standard_write_dac')
        if self.standard_write_owner:
            self.standard_write_owner.export(outfile, level, namespace_, name_='standard_write_owner')
        if self.standard_synchronize:
            self.standard_synchronize.export(outfile, level, namespace_, name_='standard_synchronize')
        if self.access_system_security:
            self.access_system_security.export(outfile, level, namespace_, name_='access_system_security')
        if self.generic_read:
            self.generic_read.export(outfile, level, namespace_, name_='generic_read')
        if self.generic_write:
            self.generic_write.export(outfile, level, namespace_, name_='generic_write')
        if self.generic_execute:
            self.generic_execute.export(outfile, level, namespace_, name_='generic_execute')
        if self.generic_all:
            self.generic_all.export(outfile, level, namespace_, name_='generic_all')
        if self.file_read_data:
            self.file_read_data.export(outfile, level, namespace_, name_='file_read_data')
        if self.file_write_data:
            self.file_write_data.export(outfile, level, namespace_, name_='file_write_data')
        if self.file_append_data:
            self.file_append_data.export(outfile, level, namespace_, name_='file_append_data')
        if self.file_read_ea:
            self.file_read_ea.export(outfile, level, namespace_, name_='file_read_ea')
        if self.file_write_ea:
            self.file_write_ea.export(outfile, level, namespace_, name_='file_write_ea')
        if self.file_execute:
            self.file_execute.export(outfile, level, namespace_, name_='file_execute')
        if self.file_delete_child:
            self.file_delete_child.export(outfile, level, namespace_, name_='file_delete_child')
        if self.file_read_attributes:
            self.file_read_attributes.export(outfile, level, namespace_, name_='file_read_attributes')
        if self.file_write_attributes:
            self.file_write_attributes.export(outfile, level, namespace_, name_='file_write_attributes')
    def hasContent_(self):
        if (
            self.path is not None or
            self.filename is not None or
            self.trustee_name is not None or
            self.standard_delete is not None or
            self.standard_read_control is not None or
            self.standard_write_dac is not None or
            self.standard_write_owner is not None or
            self.standard_synchronize is not None or
            self.access_system_security is not None or
            self.generic_read is not None or
            self.generic_write is not None or
            self.generic_execute is not None or
            self.generic_all is not None or
            self.file_read_data is not None or
            self.file_write_data is not None or
            self.file_append_data is not None or
            self.file_read_ea is not None or
            self.file_write_ea is not None or
            self.file_execute is not None or
            self.file_delete_child is not None or
            self.file_read_attributes is not None or
            self.file_write_attributes is not None or
            super(fileauditedpermissions_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileauditedpermissions_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileauditedpermissions_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileauditedpermissions_state, self).exportLiteralChildren(outfile, level, name_)
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
        if self.standard_delete is not None:
            showIndent(outfile, level)
            outfile.write('standard_delete=model_.EntityStateAuditType(\n')
            self.standard_delete.exportLiteral(outfile, level, name_='standard_delete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_read_control is not None:
            showIndent(outfile, level)
            outfile.write('standard_read_control=model_.EntityStateAuditType(\n')
            self.standard_read_control.exportLiteral(outfile, level, name_='standard_read_control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_dac is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_dac=model_.EntityStateAuditType(\n')
            self.standard_write_dac.exportLiteral(outfile, level, name_='standard_write_dac')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_owner is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_owner=model_.EntityStateAuditType(\n')
            self.standard_write_owner.exportLiteral(outfile, level, name_='standard_write_owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_synchronize is not None:
            showIndent(outfile, level)
            outfile.write('standard_synchronize=model_.EntityStateAuditType(\n')
            self.standard_synchronize.exportLiteral(outfile, level, name_='standard_synchronize')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_system_security is not None:
            showIndent(outfile, level)
            outfile.write('access_system_security=model_.EntityStateAuditType(\n')
            self.access_system_security.exportLiteral(outfile, level, name_='access_system_security')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_read is not None:
            showIndent(outfile, level)
            outfile.write('generic_read=model_.EntityStateAuditType(\n')
            self.generic_read.exportLiteral(outfile, level, name_='generic_read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_write is not None:
            showIndent(outfile, level)
            outfile.write('generic_write=model_.EntityStateAuditType(\n')
            self.generic_write.exportLiteral(outfile, level, name_='generic_write')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_execute is not None:
            showIndent(outfile, level)
            outfile.write('generic_execute=model_.EntityStateAuditType(\n')
            self.generic_execute.exportLiteral(outfile, level, name_='generic_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_all is not None:
            showIndent(outfile, level)
            outfile.write('generic_all=model_.EntityStateAuditType(\n')
            self.generic_all.exportLiteral(outfile, level, name_='generic_all')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_data is not None:
            showIndent(outfile, level)
            outfile.write('file_read_data=model_.EntityStateAuditType(\n')
            self.file_read_data.exportLiteral(outfile, level, name_='file_read_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_data is not None:
            showIndent(outfile, level)
            outfile.write('file_write_data=model_.EntityStateAuditType(\n')
            self.file_write_data.exportLiteral(outfile, level, name_='file_write_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_append_data is not None:
            showIndent(outfile, level)
            outfile.write('file_append_data=model_.EntityStateAuditType(\n')
            self.file_append_data.exportLiteral(outfile, level, name_='file_append_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_ea is not None:
            showIndent(outfile, level)
            outfile.write('file_read_ea=model_.EntityStateAuditType(\n')
            self.file_read_ea.exportLiteral(outfile, level, name_='file_read_ea')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_ea is not None:
            showIndent(outfile, level)
            outfile.write('file_write_ea=model_.EntityStateAuditType(\n')
            self.file_write_ea.exportLiteral(outfile, level, name_='file_write_ea')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_execute is not None:
            showIndent(outfile, level)
            outfile.write('file_execute=model_.EntityStateAuditType(\n')
            self.file_execute.exportLiteral(outfile, level, name_='file_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_delete_child is not None:
            showIndent(outfile, level)
            outfile.write('file_delete_child=model_.EntityStateAuditType(\n')
            self.file_delete_child.exportLiteral(outfile, level, name_='file_delete_child')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_attributes is not None:
            showIndent(outfile, level)
            outfile.write('file_read_attributes=model_.EntityStateAuditType(\n')
            self.file_read_attributes.exportLiteral(outfile, level, name_='file_read_attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_attributes is not None:
            showIndent(outfile, level)
            outfile.write('file_write_attributes=model_.EntityStateAuditType(\n')
            self.file_write_attributes.exportLiteral(outfile, level, name_='file_write_attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileauditedpermissions_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'path':
            path_ = child_.text
            self.path = path_
            self.validate_path(self.path)    # validate type path
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
        elif nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        elif nodeName_ == 'standard_delete': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_delete(obj_)
        elif nodeName_ == 'standard_read_control': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_read_control(obj_)
        elif nodeName_ == 'standard_write_dac': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_write_dac(obj_)
        elif nodeName_ == 'standard_write_owner': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_write_owner(obj_)
        elif nodeName_ == 'standard_synchronize': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_synchronize(obj_)
        elif nodeName_ == 'access_system_security': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_access_system_security(obj_)
        elif nodeName_ == 'generic_read': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_read(obj_)
        elif nodeName_ == 'generic_write': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_write(obj_)
        elif nodeName_ == 'generic_execute': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_execute(obj_)
        elif nodeName_ == 'generic_all': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_all(obj_)
        elif nodeName_ == 'file_read_data': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_read_data(obj_)
        elif nodeName_ == 'file_write_data': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_write_data(obj_)
        elif nodeName_ == 'file_append_data': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_append_data(obj_)
        elif nodeName_ == 'file_read_ea': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_read_ea(obj_)
        elif nodeName_ == 'file_write_ea': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_write_ea(obj_)
        elif nodeName_ == 'file_execute': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_execute(obj_)
        elif nodeName_ == 'file_delete_child': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_delete_child(obj_)
        elif nodeName_ == 'file_read_attributes': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_read_attributes(obj_)
        elif nodeName_ == 'file_write_attributes': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_file_write_attributes(obj_)
        super(fileauditedpermissions_state, self).buildChildren(child_, nodeName_)
# end class fileauditedpermissions_state


class FileAuditPermissionsBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resolve_group=False, recurse_direction='none', max_depth=-1, include_group=True, valueOf_=None):
        self.resolve_group = _cast(bool, resolve_group)
        self.recurse_direction = _cast(None, recurse_direction)
        self.max_depth = _cast(int, max_depth)
        self.include_group = _cast(bool, include_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FileAuditPermissionsBehaviors.subclass:
            return FileAuditPermissionsBehaviors.subclass(*args_, **kwargs_)
        else:
            return FileAuditPermissionsBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_recurse_direction(self): return self.recurse_direction
    def set_recurse_direction(self, recurse_direction): self.recurse_direction = recurse_direction
    def get_max_depth(self): return self.max_depth
    def set_max_depth(self, max_depth): self.max_depth = max_depth
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='FileAuditPermissionsBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='FileAuditPermissionsBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='FileAuditPermissionsBehaviors'):
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
        if self.recurse_direction is not None:
            outfile.write(' recurse_direction=%s' % (self.format_string(quote_attrib(self.recurse_direction).encode(ExternalEncoding), input_name='recurse_direction'), ))
        if self.max_depth is not None:
            outfile.write(' max_depth="%s"' % self.format_integer(self.max_depth, input_name='max_depth'))
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='FileAuditPermissionsBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FileAuditPermissionsBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
        if self.recurse_direction is not None:
            showIndent(outfile, level)
            outfile.write('recurse_direction = "%s",\n' % (self.recurse_direction,))
        if self.max_depth is not None:
            showIndent(outfile, level)
            outfile.write('max_depth = %d,\n' % (self.max_depth,))
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('recurse_direction')
        if value is not None:
            self.recurse_direction = value
        value = attrs.get('max_depth')
        if value is not None:
            try:
                self.max_depth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class FileAuditPermissionsBehaviors


class fileeffectiverights53_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(fileeffectiverights53_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if fileeffectiverights53_test.subclass:
            return fileeffectiverights53_test.subclass(*args_, **kwargs_)
        else:
            return fileeffectiverights53_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights53_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileeffectiverights53_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileeffectiverights53_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights53_test'):
        super(fileeffectiverights53_test, self).exportAttributes(outfile, level, namespace_, name_='fileeffectiverights53_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights53_test'):
        super(fileeffectiverights53_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(fileeffectiverights53_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileeffectiverights53_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileeffectiverights53_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileeffectiverights53_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileeffectiverights53_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(fileeffectiverights53_test, self).buildChildren(child_, nodeName_)
# end class fileeffectiverights53_test


class fileeffectiverights53_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, filepath=None, path=None, filename=None, trustee_sid=None):
        super(fileeffectiverights53_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.filepath = filepath
        self.path = path
        self.filename = filename
        self.trustee_sid = trustee_sid
    def factory(*args_, **kwargs_):
        if fileeffectiverights53_object.subclass:
            return fileeffectiverights53_object.subclass(*args_, **kwargs_)
        else:
            return fileeffectiverights53_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_filepath(self): return self.filepath
    def set_filepath(self, filepath): self.filepath = filepath
    def validate_filepath(self, value):
        # validate type filepath
        pass
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def validate_path(self, value):
        # validate type path
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights53_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileeffectiverights53_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileeffectiverights53_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights53_object'):
        super(fileeffectiverights53_object, self).exportAttributes(outfile, level, namespace_, name_='fileeffectiverights53_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights53_object'):
        super(fileeffectiverights53_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.filepath is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilepath>%s</%sfilepath>\n' % (namespace_, self.format_string(quote_xml(self.filepath).encode(ExternalEncoding), input_name='filepath'), namespace_))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('<%spath>%s</%spath>\n' % (namespace_, self.format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilename>%s</%sfilename>\n' % (namespace_, self.format_string(quote_xml(self.filename).encode(ExternalEncoding), input_name='filename'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.filepath is not None or
            self.path is not None or
            self.filename is not None or
            self.trustee_sid is not None or
            super(fileeffectiverights53_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileeffectiverights53_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileeffectiverights53_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileeffectiverights53_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.FileEffectiveRights53Behaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.filepath is not None:
            showIndent(outfile, level)
            outfile.write('filepath=%s,\n' % quote_python(self.filepath).encode(ExternalEncoding))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileeffectiverights53_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = FileEffectiveRights53Behaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'filepath':
            filepath_ = child_.text
            self.filepath = filepath_
            self.validate_filepath(self.filepath)    # validate type filepath
        elif nodeName_ == 'path':
            path_ = child_.text
            self.path = path_
            self.validate_path(self.path)    # validate type path
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        super(fileeffectiverights53_object, self).buildChildren(child_, nodeName_)
# end class fileeffectiverights53_object


class fileeffectiverights53_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, filepath=None, path=None, filename=None, trustee_sid=None, standard_delete=None, standard_read_control=None, standard_write_dac=None, standard_write_owner=None, standard_synchronize=None, access_system_security=None, generic_read=None, generic_write=None, generic_execute=None, generic_all=None, file_read_data=None, file_write_data=None, file_append_data=None, file_read_ea=None, file_write_ea=None, file_execute=None, file_delete_child=None, file_read_attributes=None, file_write_attributes=None):
        super(fileeffectiverights53_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.filepath = filepath
        self.path = path
        self.filename = filename
        self.trustee_sid = trustee_sid
        self.standard_delete = standard_delete
        self.standard_read_control = standard_read_control
        self.standard_write_dac = standard_write_dac
        self.standard_write_owner = standard_write_owner
        self.standard_synchronize = standard_synchronize
        self.access_system_security = access_system_security
        self.generic_read = generic_read
        self.generic_write = generic_write
        self.generic_execute = generic_execute
        self.generic_all = generic_all
        self.file_read_data = file_read_data
        self.file_write_data = file_write_data
        self.file_append_data = file_append_data
        self.file_read_ea = file_read_ea
        self.file_write_ea = file_write_ea
        self.file_execute = file_execute
        self.file_delete_child = file_delete_child
        self.file_read_attributes = file_read_attributes
        self.file_write_attributes = file_write_attributes
    def factory(*args_, **kwargs_):
        if fileeffectiverights53_state.subclass:
            return fileeffectiverights53_state.subclass(*args_, **kwargs_)
        else:
            return fileeffectiverights53_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_filepath(self): return self.filepath
    def set_filepath(self, filepath): self.filepath = filepath
    def validate_filepath(self, value):
        # validate type filepath
        pass
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def validate_path(self, value):
        # validate type path
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def get_standard_delete(self): return self.standard_delete
    def set_standard_delete(self, standard_delete): self.standard_delete = standard_delete
    def validate_standard_delete(self, value):
        # validate type standard_delete
        pass
    def get_standard_read_control(self): return self.standard_read_control
    def set_standard_read_control(self, standard_read_control): self.standard_read_control = standard_read_control
    def validate_standard_read_control(self, value):
        # validate type standard_read_control
        pass
    def get_standard_write_dac(self): return self.standard_write_dac
    def set_standard_write_dac(self, standard_write_dac): self.standard_write_dac = standard_write_dac
    def validate_standard_write_dac(self, value):
        # validate type standard_write_dac
        pass
    def get_standard_write_owner(self): return self.standard_write_owner
    def set_standard_write_owner(self, standard_write_owner): self.standard_write_owner = standard_write_owner
    def validate_standard_write_owner(self, value):
        # validate type standard_write_owner
        pass
    def get_standard_synchronize(self): return self.standard_synchronize
    def set_standard_synchronize(self, standard_synchronize): self.standard_synchronize = standard_synchronize
    def validate_standard_synchronize(self, value):
        # validate type standard_synchronize
        pass
    def get_access_system_security(self): return self.access_system_security
    def set_access_system_security(self, access_system_security): self.access_system_security = access_system_security
    def validate_access_system_security(self, value):
        # validate type access_system_security
        pass
    def get_generic_read(self): return self.generic_read
    def set_generic_read(self, generic_read): self.generic_read = generic_read
    def validate_generic_read(self, value):
        # validate type generic_read
        pass
    def get_generic_write(self): return self.generic_write
    def set_generic_write(self, generic_write): self.generic_write = generic_write
    def validate_generic_write(self, value):
        # validate type generic_write
        pass
    def get_generic_execute(self): return self.generic_execute
    def set_generic_execute(self, generic_execute): self.generic_execute = generic_execute
    def validate_generic_execute(self, value):
        # validate type generic_execute
        pass
    def get_generic_all(self): return self.generic_all
    def set_generic_all(self, generic_all): self.generic_all = generic_all
    def validate_generic_all(self, value):
        # validate type generic_all
        pass
    def get_file_read_data(self): return self.file_read_data
    def set_file_read_data(self, file_read_data): self.file_read_data = file_read_data
    def validate_file_read_data(self, value):
        # validate type file_read_data
        pass
    def get_file_write_data(self): return self.file_write_data
    def set_file_write_data(self, file_write_data): self.file_write_data = file_write_data
    def validate_file_write_data(self, value):
        # validate type file_write_data
        pass
    def get_file_append_data(self): return self.file_append_data
    def set_file_append_data(self, file_append_data): self.file_append_data = file_append_data
    def validate_file_append_data(self, value):
        # validate type file_append_data
        pass
    def get_file_read_ea(self): return self.file_read_ea
    def set_file_read_ea(self, file_read_ea): self.file_read_ea = file_read_ea
    def validate_file_read_ea(self, value):
        # validate type file_read_ea
        pass
    def get_file_write_ea(self): return self.file_write_ea
    def set_file_write_ea(self, file_write_ea): self.file_write_ea = file_write_ea
    def validate_file_write_ea(self, value):
        # validate type file_write_ea
        pass
    def get_file_execute(self): return self.file_execute
    def set_file_execute(self, file_execute): self.file_execute = file_execute
    def validate_file_execute(self, value):
        # validate type file_execute
        pass
    def get_file_delete_child(self): return self.file_delete_child
    def set_file_delete_child(self, file_delete_child): self.file_delete_child = file_delete_child
    def validate_file_delete_child(self, value):
        # validate type file_delete_child
        pass
    def get_file_read_attributes(self): return self.file_read_attributes
    def set_file_read_attributes(self, file_read_attributes): self.file_read_attributes = file_read_attributes
    def validate_file_read_attributes(self, value):
        # validate type file_read_attributes
        pass
    def get_file_write_attributes(self): return self.file_write_attributes
    def set_file_write_attributes(self, file_write_attributes): self.file_write_attributes = file_write_attributes
    def validate_file_write_attributes(self, value):
        # validate type file_write_attributes
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights53_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileeffectiverights53_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileeffectiverights53_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights53_state'):
        super(fileeffectiverights53_state, self).exportAttributes(outfile, level, namespace_, name_='fileeffectiverights53_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights53_state'):
        super(fileeffectiverights53_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.filepath is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilepath>%s</%sfilepath>\n' % (namespace_, self.format_string(quote_xml(self.filepath).encode(ExternalEncoding), input_name='filepath'), namespace_))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('<%spath>%s</%spath>\n' % (namespace_, self.format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilename>%s</%sfilename>\n' % (namespace_, self.format_string(quote_xml(self.filename).encode(ExternalEncoding), input_name='filename'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
        if self.standard_delete:
            self.standard_delete.export(outfile, level, namespace_, name_='standard_delete')
        if self.standard_read_control:
            self.standard_read_control.export(outfile, level, namespace_, name_='standard_read_control')
        if self.standard_write_dac:
            self.standard_write_dac.export(outfile, level, namespace_, name_='standard_write_dac')
        if self.standard_write_owner:
            self.standard_write_owner.export(outfile, level, namespace_, name_='standard_write_owner')
        if self.standard_synchronize:
            self.standard_synchronize.export(outfile, level, namespace_, name_='standard_synchronize')
        if self.access_system_security:
            self.access_system_security.export(outfile, level, namespace_, name_='access_system_security')
        if self.generic_read:
            self.generic_read.export(outfile, level, namespace_, name_='generic_read')
        if self.generic_write:
            self.generic_write.export(outfile, level, namespace_, name_='generic_write')
        if self.generic_execute:
            self.generic_execute.export(outfile, level, namespace_, name_='generic_execute')
        if self.generic_all:
            self.generic_all.export(outfile, level, namespace_, name_='generic_all')
        if self.file_read_data:
            self.file_read_data.export(outfile, level, namespace_, name_='file_read_data')
        if self.file_write_data:
            self.file_write_data.export(outfile, level, namespace_, name_='file_write_data')
        if self.file_append_data:
            self.file_append_data.export(outfile, level, namespace_, name_='file_append_data')
        if self.file_read_ea:
            self.file_read_ea.export(outfile, level, namespace_, name_='file_read_ea')
        if self.file_write_ea:
            self.file_write_ea.export(outfile, level, namespace_, name_='file_write_ea')
        if self.file_execute:
            self.file_execute.export(outfile, level, namespace_, name_='file_execute')
        if self.file_delete_child:
            self.file_delete_child.export(outfile, level, namespace_, name_='file_delete_child')
        if self.file_read_attributes:
            self.file_read_attributes.export(outfile, level, namespace_, name_='file_read_attributes')
        if self.file_write_attributes:
            self.file_write_attributes.export(outfile, level, namespace_, name_='file_write_attributes')
    def hasContent_(self):
        if (
            self.filepath is not None or
            self.path is not None or
            self.filename is not None or
            self.trustee_sid is not None or
            self.standard_delete is not None or
            self.standard_read_control is not None or
            self.standard_write_dac is not None or
            self.standard_write_owner is not None or
            self.standard_synchronize is not None or
            self.access_system_security is not None or
            self.generic_read is not None or
            self.generic_write is not None or
            self.generic_execute is not None or
            self.generic_all is not None or
            self.file_read_data is not None or
            self.file_write_data is not None or
            self.file_append_data is not None or
            self.file_read_ea is not None or
            self.file_write_ea is not None or
            self.file_execute is not None or
            self.file_delete_child is not None or
            self.file_read_attributes is not None or
            self.file_write_attributes is not None or
            super(fileeffectiverights53_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileeffectiverights53_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileeffectiverights53_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileeffectiverights53_state, self).exportLiteralChildren(outfile, level, name_)
        if self.filepath is not None:
            showIndent(outfile, level)
            outfile.write('filepath=%s,\n' % quote_python(self.filepath).encode(ExternalEncoding))
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
        if self.standard_delete is not None:
            showIndent(outfile, level)
            outfile.write('standard_delete=model_.EntityStateBoolType(\n')
            self.standard_delete.exportLiteral(outfile, level, name_='standard_delete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_read_control is not None:
            showIndent(outfile, level)
            outfile.write('standard_read_control=model_.EntityStateBoolType(\n')
            self.standard_read_control.exportLiteral(outfile, level, name_='standard_read_control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_dac is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_dac=model_.EntityStateBoolType(\n')
            self.standard_write_dac.exportLiteral(outfile, level, name_='standard_write_dac')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_owner is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_owner=model_.EntityStateBoolType(\n')
            self.standard_write_owner.exportLiteral(outfile, level, name_='standard_write_owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_synchronize is not None:
            showIndent(outfile, level)
            outfile.write('standard_synchronize=model_.EntityStateBoolType(\n')
            self.standard_synchronize.exportLiteral(outfile, level, name_='standard_synchronize')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_system_security is not None:
            showIndent(outfile, level)
            outfile.write('access_system_security=model_.EntityStateBoolType(\n')
            self.access_system_security.exportLiteral(outfile, level, name_='access_system_security')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_read is not None:
            showIndent(outfile, level)
            outfile.write('generic_read=model_.EntityStateBoolType(\n')
            self.generic_read.exportLiteral(outfile, level, name_='generic_read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_write is not None:
            showIndent(outfile, level)
            outfile.write('generic_write=model_.EntityStateBoolType(\n')
            self.generic_write.exportLiteral(outfile, level, name_='generic_write')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_execute is not None:
            showIndent(outfile, level)
            outfile.write('generic_execute=model_.EntityStateBoolType(\n')
            self.generic_execute.exportLiteral(outfile, level, name_='generic_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_all is not None:
            showIndent(outfile, level)
            outfile.write('generic_all=model_.EntityStateBoolType(\n')
            self.generic_all.exportLiteral(outfile, level, name_='generic_all')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_data is not None:
            showIndent(outfile, level)
            outfile.write('file_read_data=model_.EntityStateBoolType(\n')
            self.file_read_data.exportLiteral(outfile, level, name_='file_read_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_data is not None:
            showIndent(outfile, level)
            outfile.write('file_write_data=model_.EntityStateBoolType(\n')
            self.file_write_data.exportLiteral(outfile, level, name_='file_write_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_append_data is not None:
            showIndent(outfile, level)
            outfile.write('file_append_data=model_.EntityStateBoolType(\n')
            self.file_append_data.exportLiteral(outfile, level, name_='file_append_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_ea is not None:
            showIndent(outfile, level)
            outfile.write('file_read_ea=model_.EntityStateBoolType(\n')
            self.file_read_ea.exportLiteral(outfile, level, name_='file_read_ea')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_ea is not None:
            showIndent(outfile, level)
            outfile.write('file_write_ea=model_.EntityStateBoolType(\n')
            self.file_write_ea.exportLiteral(outfile, level, name_='file_write_ea')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_execute is not None:
            showIndent(outfile, level)
            outfile.write('file_execute=model_.EntityStateBoolType(\n')
            self.file_execute.exportLiteral(outfile, level, name_='file_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_delete_child is not None:
            showIndent(outfile, level)
            outfile.write('file_delete_child=model_.EntityStateBoolType(\n')
            self.file_delete_child.exportLiteral(outfile, level, name_='file_delete_child')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_attributes is not None:
            showIndent(outfile, level)
            outfile.write('file_read_attributes=model_.EntityStateBoolType(\n')
            self.file_read_attributes.exportLiteral(outfile, level, name_='file_read_attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_attributes is not None:
            showIndent(outfile, level)
            outfile.write('file_write_attributes=model_.EntityStateBoolType(\n')
            self.file_write_attributes.exportLiteral(outfile, level, name_='file_write_attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileeffectiverights53_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'filepath':
            filepath_ = child_.text
            self.filepath = filepath_
            self.validate_filepath(self.filepath)    # validate type filepath
        elif nodeName_ == 'path':
            path_ = child_.text
            self.path = path_
            self.validate_path(self.path)    # validate type path
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        elif nodeName_ == 'standard_delete': 
            obj_ = None
            self.set_standard_delete(obj_)
            self.validate_standard_delete(self.standard_delete)    # validate type standard_delete
        elif nodeName_ == 'standard_read_control': 
            obj_ = None
            self.set_standard_read_control(obj_)
            self.validate_standard_read_control(self.standard_read_control)    # validate type standard_read_control
        elif nodeName_ == 'standard_write_dac': 
            obj_ = None
            self.set_standard_write_dac(obj_)
            self.validate_standard_write_dac(self.standard_write_dac)    # validate type standard_write_dac
        elif nodeName_ == 'standard_write_owner': 
            obj_ = None
            self.set_standard_write_owner(obj_)
            self.validate_standard_write_owner(self.standard_write_owner)    # validate type standard_write_owner
        elif nodeName_ == 'standard_synchronize': 
            obj_ = None
            self.set_standard_synchronize(obj_)
            self.validate_standard_synchronize(self.standard_synchronize)    # validate type standard_synchronize
        elif nodeName_ == 'access_system_security': 
            obj_ = None
            self.set_access_system_security(obj_)
            self.validate_access_system_security(self.access_system_security)    # validate type access_system_security
        elif nodeName_ == 'generic_read': 
            obj_ = None
            self.set_generic_read(obj_)
            self.validate_generic_read(self.generic_read)    # validate type generic_read
        elif nodeName_ == 'generic_write': 
            obj_ = None
            self.set_generic_write(obj_)
            self.validate_generic_write(self.generic_write)    # validate type generic_write
        elif nodeName_ == 'generic_execute': 
            obj_ = None
            self.set_generic_execute(obj_)
            self.validate_generic_execute(self.generic_execute)    # validate type generic_execute
        elif nodeName_ == 'generic_all': 
            obj_ = None
            self.set_generic_all(obj_)
            self.validate_generic_all(self.generic_all)    # validate type generic_all
        elif nodeName_ == 'file_read_data': 
            obj_ = None
            self.set_file_read_data(obj_)
            self.validate_file_read_data(self.file_read_data)    # validate type file_read_data
        elif nodeName_ == 'file_write_data': 
            obj_ = None
            self.set_file_write_data(obj_)
            self.validate_file_write_data(self.file_write_data)    # validate type file_write_data
        elif nodeName_ == 'file_append_data': 
            obj_ = None
            self.set_file_append_data(obj_)
            self.validate_file_append_data(self.file_append_data)    # validate type file_append_data
        elif nodeName_ == 'file_read_ea': 
            obj_ = None
            self.set_file_read_ea(obj_)
            self.validate_file_read_ea(self.file_read_ea)    # validate type file_read_ea
        elif nodeName_ == 'file_write_ea': 
            obj_ = None
            self.set_file_write_ea(obj_)
            self.validate_file_write_ea(self.file_write_ea)    # validate type file_write_ea
        elif nodeName_ == 'file_execute': 
            obj_ = None
            self.set_file_execute(obj_)
            self.validate_file_execute(self.file_execute)    # validate type file_execute
        elif nodeName_ == 'file_delete_child': 
            obj_ = None
            self.set_file_delete_child(obj_)
            self.validate_file_delete_child(self.file_delete_child)    # validate type file_delete_child
        elif nodeName_ == 'file_read_attributes': 
            obj_ = None
            self.set_file_read_attributes(obj_)
            self.validate_file_read_attributes(self.file_read_attributes)    # validate type file_read_attributes
        elif nodeName_ == 'file_write_attributes': 
            obj_ = None
            self.set_file_write_attributes(obj_)
            self.validate_file_write_attributes(self.file_write_attributes)    # validate type file_write_attributes
        super(fileeffectiverights53_state, self).buildChildren(child_, nodeName_)
# end class fileeffectiverights53_state


class FileEffectiveRights53Behaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resolve_group=False, recurse_file_system='all', recurse_direction='none', max_depth=-1, include_group=True, valueOf_=None):
        self.resolve_group = _cast(bool, resolve_group)
        self.recurse_file_system = _cast(None, recurse_file_system)
        self.recurse_direction = _cast(None, recurse_direction)
        self.max_depth = _cast(int, max_depth)
        self.include_group = _cast(bool, include_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FileEffectiveRights53Behaviors.subclass:
            return FileEffectiveRights53Behaviors.subclass(*args_, **kwargs_)
        else:
            return FileEffectiveRights53Behaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_recurse_file_system(self): return self.recurse_file_system
    def set_recurse_file_system(self, recurse_file_system): self.recurse_file_system = recurse_file_system
    def get_recurse_direction(self): return self.recurse_direction
    def set_recurse_direction(self, recurse_direction): self.recurse_direction = recurse_direction
    def get_max_depth(self): return self.max_depth
    def set_max_depth(self, max_depth): self.max_depth = max_depth
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='FileEffectiveRights53Behaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='FileEffectiveRights53Behaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='FileEffectiveRights53Behaviors'):
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
        if self.recurse_file_system is not None:
            outfile.write(' recurse_file_system=%s' % (self.format_string(quote_attrib(self.recurse_file_system).encode(ExternalEncoding), input_name='recurse_file_system'), ))
        if self.recurse_direction is not None:
            outfile.write(' recurse_direction=%s' % (self.format_string(quote_attrib(self.recurse_direction).encode(ExternalEncoding), input_name='recurse_direction'), ))
        if self.max_depth is not None:
            outfile.write(' max_depth="%s"' % self.format_integer(self.max_depth, input_name='max_depth'))
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='FileEffectiveRights53Behaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FileEffectiveRights53Behaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
        if self.recurse_file_system is not None:
            showIndent(outfile, level)
            outfile.write('recurse_file_system = "%s",\n' % (self.recurse_file_system,))
        if self.recurse_direction is not None:
            showIndent(outfile, level)
            outfile.write('recurse_direction = "%s",\n' % (self.recurse_direction,))
        if self.max_depth is not None:
            showIndent(outfile, level)
            outfile.write('max_depth = %d,\n' % (self.max_depth,))
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('recurse_file_system')
        if value is not None:
            self.recurse_file_system = value
        value = attrs.get('recurse_direction')
        if value is not None:
            self.recurse_direction = value
        value = attrs.get('max_depth')
        if value is not None:
            try:
                self.max_depth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class FileEffectiveRights53Behaviors


class fileeffectiverights_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(fileeffectiverights_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if fileeffectiverights_test.subclass:
            return fileeffectiverights_test.subclass(*args_, **kwargs_)
        else:
            return fileeffectiverights_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileeffectiverights_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileeffectiverights_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights_test'):
        super(fileeffectiverights_test, self).exportAttributes(outfile, level, namespace_, name_='fileeffectiverights_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights_test'):
        super(fileeffectiverights_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(fileeffectiverights_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileeffectiverights_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileeffectiverights_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileeffectiverights_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileeffectiverights_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(fileeffectiverights_test, self).buildChildren(child_, nodeName_)
# end class fileeffectiverights_test


class fileeffectiverights_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, path=None, filename=None, trustee_name=None):
        super(fileeffectiverights_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.path = path
        self.filename = filename
        self.trustee_name = trustee_name
    def factory(*args_, **kwargs_):
        if fileeffectiverights_object.subclass:
            return fileeffectiverights_object.subclass(*args_, **kwargs_)
        else:
            return fileeffectiverights_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def validate_path(self, value):
        # validate type path
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileeffectiverights_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileeffectiverights_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights_object'):
        super(fileeffectiverights_object, self).exportAttributes(outfile, level, namespace_, name_='fileeffectiverights_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights_object'):
        super(fileeffectiverights_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('<%spath>%s</%spath>\n' % (namespace_, self.format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilename>%s</%sfilename>\n' % (namespace_, self.format_string(quote_xml(self.filename).encode(ExternalEncoding), input_name='filename'), namespace_))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.path is not None or
            self.filename is not None or
            self.trustee_name is not None or
            super(fileeffectiverights_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileeffectiverights_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileeffectiverights_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileeffectiverights_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.FileEffectiveRightsBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileeffectiverights_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = FileEffectiveRightsBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'path':
            path_ = child_.text
            self.path = path_
            self.validate_path(self.path)    # validate type path
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
        elif nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        super(fileeffectiverights_object, self).buildChildren(child_, nodeName_)
# end class fileeffectiverights_object


class fileeffectiverights_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, path=None, filename=None, trustee_name=None, standard_delete=None, standard_read_control=None, standard_write_dac=None, standard_write_owner=None, standard_synchronize=None, access_system_security=None, generic_read=None, generic_write=None, generic_execute=None, generic_all=None, file_read_data=None, file_write_data=None, file_append_data=None, file_read_ea=None, file_write_ea=None, file_execute=None, file_delete_child=None, file_read_attributes=None, file_write_attributes=None):
        super(fileeffectiverights_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.path = path
        self.filename = filename
        self.trustee_name = trustee_name
        self.standard_delete = standard_delete
        self.standard_read_control = standard_read_control
        self.standard_write_dac = standard_write_dac
        self.standard_write_owner = standard_write_owner
        self.standard_synchronize = standard_synchronize
        self.access_system_security = access_system_security
        self.generic_read = generic_read
        self.generic_write = generic_write
        self.generic_execute = generic_execute
        self.generic_all = generic_all
        self.file_read_data = file_read_data
        self.file_write_data = file_write_data
        self.file_append_data = file_append_data
        self.file_read_ea = file_read_ea
        self.file_write_ea = file_write_ea
        self.file_execute = file_execute
        self.file_delete_child = file_delete_child
        self.file_read_attributes = file_read_attributes
        self.file_write_attributes = file_write_attributes
    def factory(*args_, **kwargs_):
        if fileeffectiverights_state.subclass:
            return fileeffectiverights_state.subclass(*args_, **kwargs_)
        else:
            return fileeffectiverights_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def validate_path(self, value):
        # validate type path
        pass
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def validate_filename(self, value):
        # validate type filename
        pass
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def get_standard_delete(self): return self.standard_delete
    def set_standard_delete(self, standard_delete): self.standard_delete = standard_delete
    def validate_standard_delete(self, value):
        # validate type standard_delete
        pass
    def get_standard_read_control(self): return self.standard_read_control
    def set_standard_read_control(self, standard_read_control): self.standard_read_control = standard_read_control
    def validate_standard_read_control(self, value):
        # validate type standard_read_control
        pass
    def get_standard_write_dac(self): return self.standard_write_dac
    def set_standard_write_dac(self, standard_write_dac): self.standard_write_dac = standard_write_dac
    def validate_standard_write_dac(self, value):
        # validate type standard_write_dac
        pass
    def get_standard_write_owner(self): return self.standard_write_owner
    def set_standard_write_owner(self, standard_write_owner): self.standard_write_owner = standard_write_owner
    def validate_standard_write_owner(self, value):
        # validate type standard_write_owner
        pass
    def get_standard_synchronize(self): return self.standard_synchronize
    def set_standard_synchronize(self, standard_synchronize): self.standard_synchronize = standard_synchronize
    def validate_standard_synchronize(self, value):
        # validate type standard_synchronize
        pass
    def get_access_system_security(self): return self.access_system_security
    def set_access_system_security(self, access_system_security): self.access_system_security = access_system_security
    def validate_access_system_security(self, value):
        # validate type access_system_security
        pass
    def get_generic_read(self): return self.generic_read
    def set_generic_read(self, generic_read): self.generic_read = generic_read
    def validate_generic_read(self, value):
        # validate type generic_read
        pass
    def get_generic_write(self): return self.generic_write
    def set_generic_write(self, generic_write): self.generic_write = generic_write
    def validate_generic_write(self, value):
        # validate type generic_write
        pass
    def get_generic_execute(self): return self.generic_execute
    def set_generic_execute(self, generic_execute): self.generic_execute = generic_execute
    def validate_generic_execute(self, value):
        # validate type generic_execute
        pass
    def get_generic_all(self): return self.generic_all
    def set_generic_all(self, generic_all): self.generic_all = generic_all
    def validate_generic_all(self, value):
        # validate type generic_all
        pass
    def get_file_read_data(self): return self.file_read_data
    def set_file_read_data(self, file_read_data): self.file_read_data = file_read_data
    def validate_file_read_data(self, value):
        # validate type file_read_data
        pass
    def get_file_write_data(self): return self.file_write_data
    def set_file_write_data(self, file_write_data): self.file_write_data = file_write_data
    def validate_file_write_data(self, value):
        # validate type file_write_data
        pass
    def get_file_append_data(self): return self.file_append_data
    def set_file_append_data(self, file_append_data): self.file_append_data = file_append_data
    def validate_file_append_data(self, value):
        # validate type file_append_data
        pass
    def get_file_read_ea(self): return self.file_read_ea
    def set_file_read_ea(self, file_read_ea): self.file_read_ea = file_read_ea
    def validate_file_read_ea(self, value):
        # validate type file_read_ea
        pass
    def get_file_write_ea(self): return self.file_write_ea
    def set_file_write_ea(self, file_write_ea): self.file_write_ea = file_write_ea
    def validate_file_write_ea(self, value):
        # validate type file_write_ea
        pass
    def get_file_execute(self): return self.file_execute
    def set_file_execute(self, file_execute): self.file_execute = file_execute
    def validate_file_execute(self, value):
        # validate type file_execute
        pass
    def get_file_delete_child(self): return self.file_delete_child
    def set_file_delete_child(self, file_delete_child): self.file_delete_child = file_delete_child
    def validate_file_delete_child(self, value):
        # validate type file_delete_child
        pass
    def get_file_read_attributes(self): return self.file_read_attributes
    def set_file_read_attributes(self, file_read_attributes): self.file_read_attributes = file_read_attributes
    def validate_file_read_attributes(self, value):
        # validate type file_read_attributes
        pass
    def get_file_write_attributes(self): return self.file_write_attributes
    def set_file_write_attributes(self, file_write_attributes): self.file_write_attributes = file_write_attributes
    def validate_file_write_attributes(self, value):
        # validate type file_write_attributes
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='fileeffectiverights_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="fileeffectiverights_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights_state'):
        super(fileeffectiverights_state, self).exportAttributes(outfile, level, namespace_, name_='fileeffectiverights_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='fileeffectiverights_state'):
        super(fileeffectiverights_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('<%spath>%s</%spath>\n' % (namespace_, self.format_string(quote_xml(self.path).encode(ExternalEncoding), input_name='path'), namespace_))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('<%sfilename>%s</%sfilename>\n' % (namespace_, self.format_string(quote_xml(self.filename).encode(ExternalEncoding), input_name='filename'), namespace_))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
        if self.standard_delete:
            self.standard_delete.export(outfile, level, namespace_, name_='standard_delete')
        if self.standard_read_control:
            self.standard_read_control.export(outfile, level, namespace_, name_='standard_read_control')
        if self.standard_write_dac:
            self.standard_write_dac.export(outfile, level, namespace_, name_='standard_write_dac')
        if self.standard_write_owner:
            self.standard_write_owner.export(outfile, level, namespace_, name_='standard_write_owner')
        if self.standard_synchronize:
            self.standard_synchronize.export(outfile, level, namespace_, name_='standard_synchronize')
        if self.access_system_security:
            self.access_system_security.export(outfile, level, namespace_, name_='access_system_security')
        if self.generic_read:
            self.generic_read.export(outfile, level, namespace_, name_='generic_read')
        if self.generic_write:
            self.generic_write.export(outfile, level, namespace_, name_='generic_write')
        if self.generic_execute:
            self.generic_execute.export(outfile, level, namespace_, name_='generic_execute')
        if self.generic_all:
            self.generic_all.export(outfile, level, namespace_, name_='generic_all')
        if self.file_read_data:
            self.file_read_data.export(outfile, level, namespace_, name_='file_read_data')
        if self.file_write_data:
            self.file_write_data.export(outfile, level, namespace_, name_='file_write_data')
        if self.file_append_data:
            self.file_append_data.export(outfile, level, namespace_, name_='file_append_data')
        if self.file_read_ea:
            self.file_read_ea.export(outfile, level, namespace_, name_='file_read_ea')
        if self.file_write_ea:
            self.file_write_ea.export(outfile, level, namespace_, name_='file_write_ea')
        if self.file_execute:
            self.file_execute.export(outfile, level, namespace_, name_='file_execute')
        if self.file_delete_child:
            self.file_delete_child.export(outfile, level, namespace_, name_='file_delete_child')
        if self.file_read_attributes:
            self.file_read_attributes.export(outfile, level, namespace_, name_='file_read_attributes')
        if self.file_write_attributes:
            self.file_write_attributes.export(outfile, level, namespace_, name_='file_write_attributes')
    def hasContent_(self):
        if (
            self.path is not None or
            self.filename is not None or
            self.trustee_name is not None or
            self.standard_delete is not None or
            self.standard_read_control is not None or
            self.standard_write_dac is not None or
            self.standard_write_owner is not None or
            self.standard_synchronize is not None or
            self.access_system_security is not None or
            self.generic_read is not None or
            self.generic_write is not None or
            self.generic_execute is not None or
            self.generic_all is not None or
            self.file_read_data is not None or
            self.file_write_data is not None or
            self.file_append_data is not None or
            self.file_read_ea is not None or
            self.file_write_ea is not None or
            self.file_execute is not None or
            self.file_delete_child is not None or
            self.file_read_attributes is not None or
            self.file_write_attributes is not None or
            super(fileeffectiverights_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='fileeffectiverights_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(fileeffectiverights_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(fileeffectiverights_state, self).exportLiteralChildren(outfile, level, name_)
        if self.path is not None:
            showIndent(outfile, level)
            outfile.write('path=%s,\n' % quote_python(self.path).encode(ExternalEncoding))
        if self.filename is not None:
            showIndent(outfile, level)
            outfile.write('filename=%s,\n' % quote_python(self.filename).encode(ExternalEncoding))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
        if self.standard_delete is not None:
            showIndent(outfile, level)
            outfile.write('standard_delete=model_.EntityStateBoolType(\n')
            self.standard_delete.exportLiteral(outfile, level, name_='standard_delete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_read_control is not None:
            showIndent(outfile, level)
            outfile.write('standard_read_control=model_.EntityStateBoolType(\n')
            self.standard_read_control.exportLiteral(outfile, level, name_='standard_read_control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_dac is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_dac=model_.EntityStateBoolType(\n')
            self.standard_write_dac.exportLiteral(outfile, level, name_='standard_write_dac')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_owner is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_owner=model_.EntityStateBoolType(\n')
            self.standard_write_owner.exportLiteral(outfile, level, name_='standard_write_owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_synchronize is not None:
            showIndent(outfile, level)
            outfile.write('standard_synchronize=model_.EntityStateBoolType(\n')
            self.standard_synchronize.exportLiteral(outfile, level, name_='standard_synchronize')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_system_security is not None:
            showIndent(outfile, level)
            outfile.write('access_system_security=model_.EntityStateBoolType(\n')
            self.access_system_security.exportLiteral(outfile, level, name_='access_system_security')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_read is not None:
            showIndent(outfile, level)
            outfile.write('generic_read=model_.EntityStateBoolType(\n')
            self.generic_read.exportLiteral(outfile, level, name_='generic_read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_write is not None:
            showIndent(outfile, level)
            outfile.write('generic_write=model_.EntityStateBoolType(\n')
            self.generic_write.exportLiteral(outfile, level, name_='generic_write')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_execute is not None:
            showIndent(outfile, level)
            outfile.write('generic_execute=model_.EntityStateBoolType(\n')
            self.generic_execute.exportLiteral(outfile, level, name_='generic_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_all is not None:
            showIndent(outfile, level)
            outfile.write('generic_all=model_.EntityStateBoolType(\n')
            self.generic_all.exportLiteral(outfile, level, name_='generic_all')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_data is not None:
            showIndent(outfile, level)
            outfile.write('file_read_data=model_.EntityStateBoolType(\n')
            self.file_read_data.exportLiteral(outfile, level, name_='file_read_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_data is not None:
            showIndent(outfile, level)
            outfile.write('file_write_data=model_.EntityStateBoolType(\n')
            self.file_write_data.exportLiteral(outfile, level, name_='file_write_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_append_data is not None:
            showIndent(outfile, level)
            outfile.write('file_append_data=model_.EntityStateBoolType(\n')
            self.file_append_data.exportLiteral(outfile, level, name_='file_append_data')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_ea is not None:
            showIndent(outfile, level)
            outfile.write('file_read_ea=model_.EntityStateBoolType(\n')
            self.file_read_ea.exportLiteral(outfile, level, name_='file_read_ea')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_ea is not None:
            showIndent(outfile, level)
            outfile.write('file_write_ea=model_.EntityStateBoolType(\n')
            self.file_write_ea.exportLiteral(outfile, level, name_='file_write_ea')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_execute is not None:
            showIndent(outfile, level)
            outfile.write('file_execute=model_.EntityStateBoolType(\n')
            self.file_execute.exportLiteral(outfile, level, name_='file_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_delete_child is not None:
            showIndent(outfile, level)
            outfile.write('file_delete_child=model_.EntityStateBoolType(\n')
            self.file_delete_child.exportLiteral(outfile, level, name_='file_delete_child')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_attributes is not None:
            showIndent(outfile, level)
            outfile.write('file_read_attributes=model_.EntityStateBoolType(\n')
            self.file_read_attributes.exportLiteral(outfile, level, name_='file_read_attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_write_attributes is not None:
            showIndent(outfile, level)
            outfile.write('file_write_attributes=model_.EntityStateBoolType(\n')
            self.file_write_attributes.exportLiteral(outfile, level, name_='file_write_attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(fileeffectiverights_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'path':
            path_ = child_.text
            self.path = path_
            self.validate_path(self.path)    # validate type path
        elif nodeName_ == 'filename':
            filename_ = child_.text
            self.filename = filename_
            self.validate_filename(self.filename)    # validate type filename
        elif nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        elif nodeName_ == 'standard_delete': 
            obj_ = None
            self.set_standard_delete(obj_)
            self.validate_standard_delete(self.standard_delete)    # validate type standard_delete
        elif nodeName_ == 'standard_read_control': 
            obj_ = None
            self.set_standard_read_control(obj_)
            self.validate_standard_read_control(self.standard_read_control)    # validate type standard_read_control
        elif nodeName_ == 'standard_write_dac': 
            obj_ = None
            self.set_standard_write_dac(obj_)
            self.validate_standard_write_dac(self.standard_write_dac)    # validate type standard_write_dac
        elif nodeName_ == 'standard_write_owner': 
            obj_ = None
            self.set_standard_write_owner(obj_)
            self.validate_standard_write_owner(self.standard_write_owner)    # validate type standard_write_owner
        elif nodeName_ == 'standard_synchronize': 
            obj_ = None
            self.set_standard_synchronize(obj_)
            self.validate_standard_synchronize(self.standard_synchronize)    # validate type standard_synchronize
        elif nodeName_ == 'access_system_security': 
            obj_ = None
            self.set_access_system_security(obj_)
            self.validate_access_system_security(self.access_system_security)    # validate type access_system_security
        elif nodeName_ == 'generic_read': 
            obj_ = None
            self.set_generic_read(obj_)
            self.validate_generic_read(self.generic_read)    # validate type generic_read
        elif nodeName_ == 'generic_write': 
            obj_ = None
            self.set_generic_write(obj_)
            self.validate_generic_write(self.generic_write)    # validate type generic_write
        elif nodeName_ == 'generic_execute': 
            obj_ = None
            self.set_generic_execute(obj_)
            self.validate_generic_execute(self.generic_execute)    # validate type generic_execute
        elif nodeName_ == 'generic_all': 
            obj_ = None
            self.set_generic_all(obj_)
            self.validate_generic_all(self.generic_all)    # validate type generic_all
        elif nodeName_ == 'file_read_data': 
            obj_ = None
            self.set_file_read_data(obj_)
            self.validate_file_read_data(self.file_read_data)    # validate type file_read_data
        elif nodeName_ == 'file_write_data': 
            obj_ = None
            self.set_file_write_data(obj_)
            self.validate_file_write_data(self.file_write_data)    # validate type file_write_data
        elif nodeName_ == 'file_append_data': 
            obj_ = None
            self.set_file_append_data(obj_)
            self.validate_file_append_data(self.file_append_data)    # validate type file_append_data
        elif nodeName_ == 'file_read_ea': 
            obj_ = None
            self.set_file_read_ea(obj_)
            self.validate_file_read_ea(self.file_read_ea)    # validate type file_read_ea
        elif nodeName_ == 'file_write_ea': 
            obj_ = None
            self.set_file_write_ea(obj_)
            self.validate_file_write_ea(self.file_write_ea)    # validate type file_write_ea
        elif nodeName_ == 'file_execute': 
            obj_ = None
            self.set_file_execute(obj_)
            self.validate_file_execute(self.file_execute)    # validate type file_execute
        elif nodeName_ == 'file_delete_child': 
            obj_ = None
            self.set_file_delete_child(obj_)
            self.validate_file_delete_child(self.file_delete_child)    # validate type file_delete_child
        elif nodeName_ == 'file_read_attributes': 
            obj_ = None
            self.set_file_read_attributes(obj_)
            self.validate_file_read_attributes(self.file_read_attributes)    # validate type file_read_attributes
        elif nodeName_ == 'file_write_attributes': 
            obj_ = None
            self.set_file_write_attributes(obj_)
            self.validate_file_write_attributes(self.file_write_attributes)    # validate type file_write_attributes
        super(fileeffectiverights_state, self).buildChildren(child_, nodeName_)
# end class fileeffectiverights_state


class FileEffectiveRightsBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resolve_group=False, recurse_direction='none', max_depth=-1, include_group=True, valueOf_=None):
        self.resolve_group = _cast(bool, resolve_group)
        self.recurse_direction = _cast(None, recurse_direction)
        self.max_depth = _cast(int, max_depth)
        self.include_group = _cast(bool, include_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FileEffectiveRightsBehaviors.subclass:
            return FileEffectiveRightsBehaviors.subclass(*args_, **kwargs_)
        else:
            return FileEffectiveRightsBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_recurse_direction(self): return self.recurse_direction
    def set_recurse_direction(self, recurse_direction): self.recurse_direction = recurse_direction
    def get_max_depth(self): return self.max_depth
    def set_max_depth(self, max_depth): self.max_depth = max_depth
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='FileEffectiveRightsBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='FileEffectiveRightsBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='FileEffectiveRightsBehaviors'):
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
        if self.recurse_direction is not None:
            outfile.write(' recurse_direction=%s' % (self.format_string(quote_attrib(self.recurse_direction).encode(ExternalEncoding), input_name='recurse_direction'), ))
        if self.max_depth is not None:
            outfile.write(' max_depth="%s"' % self.format_integer(self.max_depth, input_name='max_depth'))
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='FileEffectiveRightsBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FileEffectiveRightsBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
        if self.recurse_direction is not None:
            showIndent(outfile, level)
            outfile.write('recurse_direction = "%s",\n' % (self.recurse_direction,))
        if self.max_depth is not None:
            showIndent(outfile, level)
            outfile.write('max_depth = %d,\n' % (self.max_depth,))
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('recurse_direction')
        if value is not None:
            self.recurse_direction = value
        value = attrs.get('max_depth')
        if value is not None:
            try:
                self.max_depth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class FileEffectiveRightsBehaviors


class group_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(group_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if group_test.subclass:
            return group_test.subclass(*args_, **kwargs_)
        else:
            return group_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='group_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='group_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="group_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='group_test'):
        super(group_test, self).exportAttributes(outfile, level, namespace_, name_='group_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='group_test'):
        super(group_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(group_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='group_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(group_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(group_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(group_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(group_test, self).buildChildren(child_, nodeName_)
# end class group_test


class group_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, group=None):
        super(group_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.group = group
    def factory(*args_, **kwargs_):
        if group_object.subclass:
            return group_object.subclass(*args_, **kwargs_)
        else:
            return group_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def validate_group(self, value):
        # validate type group
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='group_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='group_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="group_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='group_object'):
        super(group_object, self).exportAttributes(outfile, level, namespace_, name_='group_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='group_object'):
        super(group_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.format_string(quote_xml(self.group).encode(ExternalEncoding), input_name='group'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.group is not None or
            super(group_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='group_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(group_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(group_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('group=%s,\n' % quote_python(self.group).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(group_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'group':
            group_ = child_.text
            self.group = group_
            self.validate_group(self.group)    # validate type group
        super(group_object, self).buildChildren(child_, nodeName_)
# end class group_object


class group_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, group=None, user=None, subgroup=None):
        super(group_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.group = group
        self.user = user
        self.subgroup = subgroup
    def factory(*args_, **kwargs_):
        if group_state.subclass:
            return group_state.subclass(*args_, **kwargs_)
        else:
            return group_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def validate_group(self, value):
        # validate type group
        pass
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def validate_user(self, value):
        # validate type user
        pass
    def get_subgroup(self): return self.subgroup
    def set_subgroup(self, subgroup): self.subgroup = subgroup
    def validate_subgroup(self, value):
        # validate type subgroup
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='group_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='group_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="group_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='group_state'):
        super(group_state, self).exportAttributes(outfile, level, namespace_, name_='group_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='group_state'):
        super(group_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.format_string(quote_xml(self.group).encode(ExternalEncoding), input_name='group'), namespace_))
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('<%suser>%s</%suser>\n' % (namespace_, self.format_string(quote_xml(self.user).encode(ExternalEncoding), input_name='user'), namespace_))
        if self.subgroup is not None:
            showIndent(outfile, level)
            outfile.write('<%ssubgroup>%s</%ssubgroup>\n' % (namespace_, self.format_string(quote_xml(self.subgroup).encode(ExternalEncoding), input_name='subgroup'), namespace_))
    def hasContent_(self):
        if (
            self.group is not None or
            self.user is not None or
            self.subgroup is not None or
            super(group_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='group_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(group_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(group_state, self).exportLiteralChildren(outfile, level, name_)
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('group=%s,\n' % quote_python(self.group).encode(ExternalEncoding))
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user=%s,\n' % quote_python(self.user).encode(ExternalEncoding))
        if self.subgroup is not None:
            showIndent(outfile, level)
            outfile.write('subgroup=%s,\n' % quote_python(self.subgroup).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(group_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'group':
            group_ = child_.text
            self.group = group_
            self.validate_group(self.group)    # validate type group
        elif nodeName_ == 'user':
            user_ = child_.text
            self.user = user_
            self.validate_user(self.user)    # validate type user
        elif nodeName_ == 'subgroup':
            subgroup_ = child_.text
            self.subgroup = subgroup_
            self.validate_subgroup(self.subgroup)    # validate type subgroup
        super(group_state, self).buildChildren(child_, nodeName_)
# end class group_state


class group_sid_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(group_sid_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if group_sid_test.subclass:
            return group_sid_test.subclass(*args_, **kwargs_)
        else:
            return group_sid_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='group_sid_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='group_sid_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="group_sid_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='group_sid_test'):
        super(group_sid_test, self).exportAttributes(outfile, level, namespace_, name_='group_sid_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='group_sid_test'):
        super(group_sid_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(group_sid_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='group_sid_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(group_sid_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(group_sid_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(group_sid_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(group_sid_test, self).buildChildren(child_, nodeName_)
# end class group_sid_test


class group_sid_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, group_sid=None):
        super(group_sid_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.group_sid = group_sid
    def factory(*args_, **kwargs_):
        if group_sid_object.subclass:
            return group_sid_object.subclass(*args_, **kwargs_)
        else:
            return group_sid_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_group_sid(self): return self.group_sid
    def set_group_sid(self, group_sid): self.group_sid = group_sid
    def validate_group_sid(self, value):
        # validate type group_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='group_sid_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='group_sid_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="group_sid_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='group_sid_object'):
        super(group_sid_object, self).exportAttributes(outfile, level, namespace_, name_='group_sid_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='group_sid_object'):
        super(group_sid_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.group_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroup_sid>%s</%sgroup_sid>\n' % (namespace_, self.format_string(quote_xml(self.group_sid).encode(ExternalEncoding), input_name='group_sid'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.group_sid is not None or
            super(group_sid_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='group_sid_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(group_sid_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(group_sid_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.group_sid is not None:
            showIndent(outfile, level)
            outfile.write('group_sid=%s,\n' % quote_python(self.group_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(group_sid_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'group_sid':
            group_sid_ = child_.text
            self.group_sid = group_sid_
            self.validate_group_sid(self.group_sid)    # validate type group_sid
        super(group_sid_object, self).buildChildren(child_, nodeName_)
# end class group_sid_object


class group_sid_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, group_sid=None, user_sid=None, subgroup_sid=None):
        super(group_sid_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.group_sid = group_sid
        self.user_sid = user_sid
        self.subgroup_sid = subgroup_sid
    def factory(*args_, **kwargs_):
        if group_sid_state.subclass:
            return group_sid_state.subclass(*args_, **kwargs_)
        else:
            return group_sid_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_group_sid(self): return self.group_sid
    def set_group_sid(self, group_sid): self.group_sid = group_sid
    def validate_group_sid(self, value):
        # validate type group_sid
        pass
    def get_user_sid(self): return self.user_sid
    def set_user_sid(self, user_sid): self.user_sid = user_sid
    def validate_user_sid(self, value):
        # validate type user_sid
        pass
    def get_subgroup_sid(self): return self.subgroup_sid
    def set_subgroup_sid(self, subgroup_sid): self.subgroup_sid = subgroup_sid
    def validate_subgroup_sid(self, value):
        # validate type subgroup_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='group_sid_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='group_sid_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="group_sid_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='group_sid_state'):
        super(group_sid_state, self).exportAttributes(outfile, level, namespace_, name_='group_sid_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='group_sid_state'):
        super(group_sid_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.group_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroup_sid>%s</%sgroup_sid>\n' % (namespace_, self.format_string(quote_xml(self.group_sid).encode(ExternalEncoding), input_name='group_sid'), namespace_))
        if self.user_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%suser_sid>%s</%suser_sid>\n' % (namespace_, self.format_string(quote_xml(self.user_sid).encode(ExternalEncoding), input_name='user_sid'), namespace_))
        if self.subgroup_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%ssubgroup_sid>%s</%ssubgroup_sid>\n' % (namespace_, self.format_string(quote_xml(self.subgroup_sid).encode(ExternalEncoding), input_name='subgroup_sid'), namespace_))
    def hasContent_(self):
        if (
            self.group_sid is not None or
            self.user_sid is not None or
            self.subgroup_sid is not None or
            super(group_sid_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='group_sid_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(group_sid_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(group_sid_state, self).exportLiteralChildren(outfile, level, name_)
        if self.group_sid is not None:
            showIndent(outfile, level)
            outfile.write('group_sid=%s,\n' % quote_python(self.group_sid).encode(ExternalEncoding))
        if self.user_sid is not None:
            showIndent(outfile, level)
            outfile.write('user_sid=%s,\n' % quote_python(self.user_sid).encode(ExternalEncoding))
        if self.subgroup_sid is not None:
            showIndent(outfile, level)
            outfile.write('subgroup_sid=%s,\n' % quote_python(self.subgroup_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(group_sid_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'group_sid':
            group_sid_ = child_.text
            self.group_sid = group_sid_
            self.validate_group_sid(self.group_sid)    # validate type group_sid
        elif nodeName_ == 'user_sid':
            user_sid_ = child_.text
            self.user_sid = user_sid_
            self.validate_user_sid(self.user_sid)    # validate type user_sid
        elif nodeName_ == 'subgroup_sid':
            subgroup_sid_ = child_.text
            self.subgroup_sid = subgroup_sid_
            self.validate_subgroup_sid(self.subgroup_sid)    # validate type subgroup_sid
        super(group_sid_state, self).buildChildren(child_, nodeName_)
# end class group_sid_state


class interface_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(interface_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if interface_test.subclass:
            return interface_test.subclass(*args_, **kwargs_)
        else:
            return interface_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='interface_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='interface_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="interface_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='interface_test'):
        super(interface_test, self).exportAttributes(outfile, level, namespace_, name_='interface_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='interface_test'):
        super(interface_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(interface_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='interface_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(interface_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(interface_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(interface_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(interface_test, self).buildChildren(child_, nodeName_)
# end class interface_test


class interface_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, name=None):
        super(interface_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.name = name
    def factory(*args_, **kwargs_):
        if interface_object.subclass:
            return interface_object.subclass(*args_, **kwargs_)
        else:
            return interface_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_name(self, value):
        # validate type name
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='interface_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='interface_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="interface_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='interface_object'):
        super(interface_object, self).exportAttributes(outfile, level, namespace_, name_='interface_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='interface_object'):
        super(interface_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.name is not None or
            super(interface_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='interface_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(interface_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(interface_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(interface_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'name':
            name_ = child_.text
            self.name = name_
            self.validate_name(self.name)    # validate type name
        super(interface_object, self).buildChildren(child_, nodeName_)
# end class interface_object


class interface_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, name=None, index=None, type_=None, hardware_addr=None, inet_addr=None, broadcast_addr=None, netmask=None, addr_type=None):
        super(interface_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.name = name
        self.index = index
        self.type_ = type_
        self.hardware_addr = hardware_addr
        self.inet_addr = inet_addr
        self.broadcast_addr = broadcast_addr
        self.netmask = netmask
        self.addr_type = addr_type
    def factory(*args_, **kwargs_):
        if interface_state.subclass:
            return interface_state.subclass(*args_, **kwargs_)
        else:
            return interface_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_name(self, value):
        # validate type name
        pass
    def get_index(self): return self.index
    def set_index(self, index): self.index = index
    def validate_index(self, value):
        # validate type index
        pass
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_hardware_addr(self): return self.hardware_addr
    def set_hardware_addr(self, hardware_addr): self.hardware_addr = hardware_addr
    def validate_hardware_addr(self, value):
        # validate type hardware_addr
        pass
    def get_inet_addr(self): return self.inet_addr
    def set_inet_addr(self, inet_addr): self.inet_addr = inet_addr
    def validate_inet_addr(self, value):
        # validate type inet_addr
        pass
    def get_broadcast_addr(self): return self.broadcast_addr
    def set_broadcast_addr(self, broadcast_addr): self.broadcast_addr = broadcast_addr
    def validate_broadcast_addr(self, value):
        # validate type broadcast_addr
        pass
    def get_netmask(self): return self.netmask
    def set_netmask(self, netmask): self.netmask = netmask
    def validate_netmask(self, value):
        # validate type netmask
        pass
    def get_addr_type(self): return self.addr_type
    def set_addr_type(self, addr_type): self.addr_type = addr_type
    def export(self, outfile, level, namespace_='win-def:', name_='interface_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='interface_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="interface_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='interface_state'):
        super(interface_state, self).exportAttributes(outfile, level, namespace_, name_='interface_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='interface_state'):
        super(interface_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.index:
            self.index.export(outfile, level, namespace_, name_='index')
        if self.type_:
            self.type_.export(outfile, level, namespace_, name_='type')
        if self.hardware_addr is not None:
            showIndent(outfile, level)
            outfile.write('<%shardware_addr>%s</%shardware_addr>\n' % (namespace_, self.format_string(quote_xml(self.hardware_addr).encode(ExternalEncoding), input_name='hardware_addr'), namespace_))
        if self.inet_addr is not None:
            showIndent(outfile, level)
            outfile.write('<%sinet_addr>%s</%sinet_addr>\n' % (namespace_, self.format_string(quote_xml(self.inet_addr).encode(ExternalEncoding), input_name='inet_addr'), namespace_))
        if self.broadcast_addr is not None:
            showIndent(outfile, level)
            outfile.write('<%sbroadcast_addr>%s</%sbroadcast_addr>\n' % (namespace_, self.format_string(quote_xml(self.broadcast_addr).encode(ExternalEncoding), input_name='broadcast_addr'), namespace_))
        if self.netmask is not None:
            showIndent(outfile, level)
            outfile.write('<%snetmask>%s</%snetmask>\n' % (namespace_, self.format_string(quote_xml(self.netmask).encode(ExternalEncoding), input_name='netmask'), namespace_))
        if self.addr_type:
            self.addr_type.export(outfile, level, namespace_, name_='addr_type')
    def hasContent_(self):
        if (
            self.name is not None or
            self.index is not None or
            self.type_ is not None or
            self.hardware_addr is not None or
            self.inet_addr is not None or
            self.broadcast_addr is not None or
            self.netmask is not None or
            self.addr_type is not None or
            super(interface_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='interface_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(interface_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(interface_state, self).exportLiteralChildren(outfile, level, name_)
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.index is not None:
            showIndent(outfile, level)
            outfile.write('index=model_.EntityStateIntType(\n')
            self.index.exportLiteral(outfile, level, name_='index')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.EntityStateInterfaceTypeType(\n')
            self.type_.exportLiteral(outfile, level, name_='type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.hardware_addr is not None:
            showIndent(outfile, level)
            outfile.write('hardware_addr=%s,\n' % quote_python(self.hardware_addr).encode(ExternalEncoding))
        if self.inet_addr is not None:
            showIndent(outfile, level)
            outfile.write('inet_addr=%s,\n' % quote_python(self.inet_addr).encode(ExternalEncoding))
        if self.broadcast_addr is not None:
            showIndent(outfile, level)
            outfile.write('broadcast_addr=%s,\n' % quote_python(self.broadcast_addr).encode(ExternalEncoding))
        if self.netmask is not None:
            showIndent(outfile, level)
            outfile.write('netmask=%s,\n' % quote_python(self.netmask).encode(ExternalEncoding))
        if self.addr_type is not None:
            showIndent(outfile, level)
            outfile.write('addr_type=model_.EntityStateAddrTypeType(\n')
            self.addr_type.exportLiteral(outfile, level, name_='addr_type')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(interface_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'name':
            name_ = child_.text
            self.name = name_
            self.validate_name(self.name)    # validate type name
        elif nodeName_ == 'index': 
            obj_ = None
            self.set_index(obj_)
            self.validate_index(self.index)    # validate type index
        elif nodeName_ == 'type': 
            obj_ = EntityStateInterfaceTypeType.factory()
            obj_.build(child_)
            self.set_type(obj_)
        elif nodeName_ == 'hardware_addr':
            hardware_addr_ = child_.text
            self.hardware_addr = hardware_addr_
            self.validate_hardware_addr(self.hardware_addr)    # validate type hardware_addr
        elif nodeName_ == 'inet_addr':
            inet_addr_ = child_.text
            self.inet_addr = inet_addr_
            self.validate_inet_addr(self.inet_addr)    # validate type inet_addr
        elif nodeName_ == 'broadcast_addr':
            broadcast_addr_ = child_.text
            self.broadcast_addr = broadcast_addr_
            self.validate_broadcast_addr(self.broadcast_addr)    # validate type broadcast_addr
        elif nodeName_ == 'netmask':
            netmask_ = child_.text
            self.netmask = netmask_
            self.validate_netmask(self.netmask)    # validate type netmask
        elif nodeName_ == 'addr_type': 
            obj_ = EntityStateAddrTypeType.factory()
            obj_.build(child_)
            self.set_addr_type(obj_)
        super(interface_state, self).buildChildren(child_, nodeName_)
# end class interface_state


class lockoutpolicy_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(lockoutpolicy_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if lockoutpolicy_test.subclass:
            return lockoutpolicy_test.subclass(*args_, **kwargs_)
        else:
            return lockoutpolicy_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='lockoutpolicy_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='lockoutpolicy_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="lockoutpolicy_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='lockoutpolicy_test'):
        super(lockoutpolicy_test, self).exportAttributes(outfile, level, namespace_, name_='lockoutpolicy_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='lockoutpolicy_test'):
        super(lockoutpolicy_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(lockoutpolicy_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='lockoutpolicy_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(lockoutpolicy_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(lockoutpolicy_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(lockoutpolicy_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(lockoutpolicy_test, self).buildChildren(child_, nodeName_)
# end class lockoutpolicy_test


class lockoutpolicy_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None):
        super(lockoutpolicy_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        pass
    def factory(*args_, **kwargs_):
        if lockoutpolicy_object.subclass:
            return lockoutpolicy_object.subclass(*args_, **kwargs_)
        else:
            return lockoutpolicy_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='win-def:', name_='lockoutpolicy_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='lockoutpolicy_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="lockoutpolicy_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='lockoutpolicy_object'):
        super(lockoutpolicy_object, self).exportAttributes(outfile, level, namespace_, name_='lockoutpolicy_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='lockoutpolicy_object'):
        super(lockoutpolicy_object, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            super(lockoutpolicy_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='lockoutpolicy_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(lockoutpolicy_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(lockoutpolicy_object, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(lockoutpolicy_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        super(lockoutpolicy_object, self).buildChildren(child_, nodeName_)
        pass
# end class lockoutpolicy_object


class lockoutpolicy_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, force_logoff=None, lockout_duration=None, lockout_observation_window=None, lockout_threshold=None):
        super(lockoutpolicy_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.force_logoff = force_logoff
        self.lockout_duration = lockout_duration
        self.lockout_observation_window = lockout_observation_window
        self.lockout_threshold = lockout_threshold
    def factory(*args_, **kwargs_):
        if lockoutpolicy_state.subclass:
            return lockoutpolicy_state.subclass(*args_, **kwargs_)
        else:
            return lockoutpolicy_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_force_logoff(self): return self.force_logoff
    def set_force_logoff(self, force_logoff): self.force_logoff = force_logoff
    def validate_force_logoff(self, value):
        # validate type force_logoff
        pass
    def get_lockout_duration(self): return self.lockout_duration
    def set_lockout_duration(self, lockout_duration): self.lockout_duration = lockout_duration
    def validate_lockout_duration(self, value):
        # validate type lockout_duration
        pass
    def get_lockout_observation_window(self): return self.lockout_observation_window
    def set_lockout_observation_window(self, lockout_observation_window): self.lockout_observation_window = lockout_observation_window
    def validate_lockout_observation_window(self, value):
        # validate type lockout_observation_window
        pass
    def get_lockout_threshold(self): return self.lockout_threshold
    def set_lockout_threshold(self, lockout_threshold): self.lockout_threshold = lockout_threshold
    def validate_lockout_threshold(self, value):
        # validate type lockout_threshold
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='lockoutpolicy_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='lockoutpolicy_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="lockoutpolicy_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='lockoutpolicy_state'):
        super(lockoutpolicy_state, self).exportAttributes(outfile, level, namespace_, name_='lockoutpolicy_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='lockoutpolicy_state'):
        super(lockoutpolicy_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.force_logoff:
            self.force_logoff.export(outfile, level, namespace_, name_='force_logoff')
        if self.lockout_duration:
            self.lockout_duration.export(outfile, level, namespace_, name_='lockout_duration')
        if self.lockout_observation_window:
            self.lockout_observation_window.export(outfile, level, namespace_, name_='lockout_observation_window')
        if self.lockout_threshold:
            self.lockout_threshold.export(outfile, level, namespace_, name_='lockout_threshold')
    def hasContent_(self):
        if (
            self.force_logoff is not None or
            self.lockout_duration is not None or
            self.lockout_observation_window is not None or
            self.lockout_threshold is not None or
            super(lockoutpolicy_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='lockoutpolicy_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(lockoutpolicy_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(lockoutpolicy_state, self).exportLiteralChildren(outfile, level, name_)
        if self.force_logoff is not None:
            showIndent(outfile, level)
            outfile.write('force_logoff=model_.EntityStateIntType(\n')
            self.force_logoff.exportLiteral(outfile, level, name_='force_logoff')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lockout_duration is not None:
            showIndent(outfile, level)
            outfile.write('lockout_duration=model_.EntityStateIntType(\n')
            self.lockout_duration.exportLiteral(outfile, level, name_='lockout_duration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lockout_observation_window is not None:
            showIndent(outfile, level)
            outfile.write('lockout_observation_window=model_.EntityStateIntType(\n')
            self.lockout_observation_window.exportLiteral(outfile, level, name_='lockout_observation_window')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lockout_threshold is not None:
            showIndent(outfile, level)
            outfile.write('lockout_threshold=model_.EntityStateIntType(\n')
            self.lockout_threshold.exportLiteral(outfile, level, name_='lockout_threshold')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(lockoutpolicy_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'force_logoff': 
            obj_ = None
            self.set_force_logoff(obj_)
            self.validate_force_logoff(self.force_logoff)    # validate type force_logoff
        elif nodeName_ == 'lockout_duration': 
            obj_ = None
            self.set_lockout_duration(obj_)
            self.validate_lockout_duration(self.lockout_duration)    # validate type lockout_duration
        elif nodeName_ == 'lockout_observation_window': 
            obj_ = None
            self.set_lockout_observation_window(obj_)
            self.validate_lockout_observation_window(self.lockout_observation_window)    # validate type lockout_observation_window
        elif nodeName_ == 'lockout_threshold': 
            obj_ = None
            self.set_lockout_threshold(obj_)
            self.validate_lockout_threshold(self.lockout_threshold)    # validate type lockout_threshold
        super(lockoutpolicy_state, self).buildChildren(child_, nodeName_)
# end class lockoutpolicy_state


class metabase_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(metabase_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if metabase_test.subclass:
            return metabase_test.subclass(*args_, **kwargs_)
        else:
            return metabase_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='metabase_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='metabase_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="metabase_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='metabase_test'):
        super(metabase_test, self).exportAttributes(outfile, level, namespace_, name_='metabase_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='metabase_test'):
        super(metabase_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(metabase_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metabase_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(metabase_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(metabase_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(metabase_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(metabase_test, self).buildChildren(child_, nodeName_)
# end class metabase_test


class metabase_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, key=None):
        super(metabase_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.key = key
        self.id = id
    def factory(*args_, **kwargs_):
        if metabase_object.subclass:
            return metabase_object.subclass(*args_, **kwargs_)
        else:
            return metabase_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_id(self, value):
        # validate type id
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='metabase_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='metabase_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="metabase_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='metabase_object'):
        super(metabase_object, self).exportAttributes(outfile, level, namespace_, name_='metabase_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='metabase_object'):
        super(metabase_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.id:
            self.id.export(outfile, level, namespace_, name_='id', )
    def hasContent_(self):
        if (
            self.set is not None or
            self.key is not None or
            self.id is not None or
            super(metabase_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metabase_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(metabase_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(metabase_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=model_.EntityObjectIntType(\n')
            self.id.exportLiteral(outfile, level, name_='id')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(metabase_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'id': 
            obj_ = None
            self.set_id(obj_)
            self.validate_id(self.id)    # validate type id
        super(metabase_object, self).buildChildren(child_, nodeName_)
# end class metabase_object


class metabase_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, key=None, name=None, user_type=None, data_type=None, data=None):
        super(metabase_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.key = key
        self.id = id
        self.name = name
        self.user_type = user_type
        self.data_type = data_type
        self.data = data
    def factory(*args_, **kwargs_):
        if metabase_state.subclass:
            return metabase_state.subclass(*args_, **kwargs_)
        else:
            return metabase_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_id(self, value):
        # validate type id
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_name(self, value):
        # validate type name
        pass
    def get_user_type(self): return self.user_type
    def set_user_type(self, user_type): self.user_type = user_type
    def validate_user_type(self, value):
        # validate type user_type
        pass
    def get_data_type(self): return self.data_type
    def set_data_type(self, data_type): self.data_type = data_type
    def validate_data_type(self, value):
        # validate type data_type
        pass
    def get_data(self): return self.data
    def set_data(self, data): self.data = data
    def validate_data(self, value):
        # validate type data
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='metabase_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='metabase_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="metabase_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='metabase_state'):
        super(metabase_state, self).exportAttributes(outfile, level, namespace_, name_='metabase_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='metabase_state'):
        super(metabase_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.id:
            self.id.export(outfile, level, namespace_, name_='id')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.user_type is not None:
            showIndent(outfile, level)
            outfile.write('<%suser_type>%s</%suser_type>\n' % (namespace_, self.format_string(quote_xml(self.user_type).encode(ExternalEncoding), input_name='user_type'), namespace_))
        if self.data_type is not None:
            showIndent(outfile, level)
            outfile.write('<%sdata_type>%s</%sdata_type>\n' % (namespace_, self.format_string(quote_xml(self.data_type).encode(ExternalEncoding), input_name='data_type'), namespace_))
        if self.data is not None:
            showIndent(outfile, level)
            outfile.write('<%sdata>%s</%sdata>\n' % (namespace_, self.format_string(quote_xml(self.data).encode(ExternalEncoding), input_name='data'), namespace_))
    def hasContent_(self):
        if (
            self.key is not None or
            self.id is not None or
            self.name is not None or
            self.user_type is not None or
            self.data_type is not None or
            self.data is not None or
            super(metabase_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metabase_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(metabase_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(metabase_state, self).exportLiteralChildren(outfile, level, name_)
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=model_.EntityStateIntType(\n')
            self.id.exportLiteral(outfile, level, name_='id')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.user_type is not None:
            showIndent(outfile, level)
            outfile.write('user_type=%s,\n' % quote_python(self.user_type).encode(ExternalEncoding))
        if self.data_type is not None:
            showIndent(outfile, level)
            outfile.write('data_type=%s,\n' % quote_python(self.data_type).encode(ExternalEncoding))
        if self.data is not None:
            showIndent(outfile, level)
            outfile.write('data=%s,\n' % quote_python(self.data).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(metabase_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'id': 
            obj_ = None
            self.set_id(obj_)
            self.validate_id(self.id)    # validate type id
        elif nodeName_ == 'name':
            name_ = child_.text
            self.name = name_
            self.validate_name(self.name)    # validate type name
        elif nodeName_ == 'user_type':
            user_type_ = child_.text
            self.user_type = user_type_
            self.validate_user_type(self.user_type)    # validate type user_type
        elif nodeName_ == 'data_type':
            data_type_ = child_.text
            self.data_type = data_type_
            self.validate_data_type(self.data_type)    # validate type data_type
        elif nodeName_ == 'data':
            data_ = child_.text
            self.data = data_
            self.validate_data(self.data)    # validate type data
        super(metabase_state, self).buildChildren(child_, nodeName_)
# end class metabase_state


class passwordpolicy_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(passwordpolicy_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if passwordpolicy_test.subclass:
            return passwordpolicy_test.subclass(*args_, **kwargs_)
        else:
            return passwordpolicy_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='passwordpolicy_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='passwordpolicy_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="passwordpolicy_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='passwordpolicy_test'):
        super(passwordpolicy_test, self).exportAttributes(outfile, level, namespace_, name_='passwordpolicy_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='passwordpolicy_test'):
        super(passwordpolicy_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(passwordpolicy_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='passwordpolicy_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(passwordpolicy_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(passwordpolicy_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(passwordpolicy_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(passwordpolicy_test, self).buildChildren(child_, nodeName_)
# end class passwordpolicy_test


class passwordpolicy_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None):
        super(passwordpolicy_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        pass
    def factory(*args_, **kwargs_):
        if passwordpolicy_object.subclass:
            return passwordpolicy_object.subclass(*args_, **kwargs_)
        else:
            return passwordpolicy_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='win-def:', name_='passwordpolicy_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='passwordpolicy_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="passwordpolicy_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='passwordpolicy_object'):
        super(passwordpolicy_object, self).exportAttributes(outfile, level, namespace_, name_='passwordpolicy_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='passwordpolicy_object'):
        super(passwordpolicy_object, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            super(passwordpolicy_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='passwordpolicy_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(passwordpolicy_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(passwordpolicy_object, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(passwordpolicy_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        super(passwordpolicy_object, self).buildChildren(child_, nodeName_)
        pass
# end class passwordpolicy_object


class passwordpolicy_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, max_passwd_age=None, min_passwd_age=None, min_passwd_len=None, password_hist_len=None, password_complexity=None, reversible_encryption=None):
        super(passwordpolicy_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.max_passwd_age = max_passwd_age
        self.min_passwd_age = min_passwd_age
        self.min_passwd_len = min_passwd_len
        self.password_hist_len = password_hist_len
        self.password_complexity = password_complexity
        self.reversible_encryption = reversible_encryption
    def factory(*args_, **kwargs_):
        if passwordpolicy_state.subclass:
            return passwordpolicy_state.subclass(*args_, **kwargs_)
        else:
            return passwordpolicy_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max_passwd_age(self): return self.max_passwd_age
    def set_max_passwd_age(self, max_passwd_age): self.max_passwd_age = max_passwd_age
    def validate_max_passwd_age(self, value):
        # validate type max_passwd_age
        pass
    def get_min_passwd_age(self): return self.min_passwd_age
    def set_min_passwd_age(self, min_passwd_age): self.min_passwd_age = min_passwd_age
    def validate_min_passwd_age(self, value):
        # validate type min_passwd_age
        pass
    def get_min_passwd_len(self): return self.min_passwd_len
    def set_min_passwd_len(self, min_passwd_len): self.min_passwd_len = min_passwd_len
    def validate_min_passwd_len(self, value):
        # validate type min_passwd_len
        pass
    def get_password_hist_len(self): return self.password_hist_len
    def set_password_hist_len(self, password_hist_len): self.password_hist_len = password_hist_len
    def validate_password_hist_len(self, value):
        # validate type password_hist_len
        pass
    def get_password_complexity(self): return self.password_complexity
    def set_password_complexity(self, password_complexity): self.password_complexity = password_complexity
    def validate_password_complexity(self, value):
        # validate type password_complexity
        pass
    def get_reversible_encryption(self): return self.reversible_encryption
    def set_reversible_encryption(self, reversible_encryption): self.reversible_encryption = reversible_encryption
    def validate_reversible_encryption(self, value):
        # validate type reversible_encryption
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='passwordpolicy_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='passwordpolicy_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="passwordpolicy_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='passwordpolicy_state'):
        super(passwordpolicy_state, self).exportAttributes(outfile, level, namespace_, name_='passwordpolicy_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='passwordpolicy_state'):
        super(passwordpolicy_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.max_passwd_age:
            self.max_passwd_age.export(outfile, level, namespace_, name_='max_passwd_age')
        if self.min_passwd_age:
            self.min_passwd_age.export(outfile, level, namespace_, name_='min_passwd_age')
        if self.min_passwd_len:
            self.min_passwd_len.export(outfile, level, namespace_, name_='min_passwd_len')
        if self.password_hist_len:
            self.password_hist_len.export(outfile, level, namespace_, name_='password_hist_len')
        if self.password_complexity:
            self.password_complexity.export(outfile, level, namespace_, name_='password_complexity')
        if self.reversible_encryption:
            self.reversible_encryption.export(outfile, level, namespace_, name_='reversible_encryption')
    def hasContent_(self):
        if (
            self.max_passwd_age is not None or
            self.min_passwd_age is not None or
            self.min_passwd_len is not None or
            self.password_hist_len is not None or
            self.password_complexity is not None or
            self.reversible_encryption is not None or
            super(passwordpolicy_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='passwordpolicy_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(passwordpolicy_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(passwordpolicy_state, self).exportLiteralChildren(outfile, level, name_)
        if self.max_passwd_age is not None:
            showIndent(outfile, level)
            outfile.write('max_passwd_age=model_.EntityStateIntType(\n')
            self.max_passwd_age.exportLiteral(outfile, level, name_='max_passwd_age')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.min_passwd_age is not None:
            showIndent(outfile, level)
            outfile.write('min_passwd_age=model_.EntityStateIntType(\n')
            self.min_passwd_age.exportLiteral(outfile, level, name_='min_passwd_age')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.min_passwd_len is not None:
            showIndent(outfile, level)
            outfile.write('min_passwd_len=model_.EntityStateIntType(\n')
            self.min_passwd_len.exportLiteral(outfile, level, name_='min_passwd_len')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.password_hist_len is not None:
            showIndent(outfile, level)
            outfile.write('password_hist_len=model_.EntityStateIntType(\n')
            self.password_hist_len.exportLiteral(outfile, level, name_='password_hist_len')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.password_complexity is not None:
            showIndent(outfile, level)
            outfile.write('password_complexity=model_.EntityStateBoolType(\n')
            self.password_complexity.exportLiteral(outfile, level, name_='password_complexity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.reversible_encryption is not None:
            showIndent(outfile, level)
            outfile.write('reversible_encryption=model_.EntityStateBoolType(\n')
            self.reversible_encryption.exportLiteral(outfile, level, name_='reversible_encryption')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(passwordpolicy_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'max_passwd_age': 
            obj_ = None
            self.set_max_passwd_age(obj_)
            self.validate_max_passwd_age(self.max_passwd_age)    # validate type max_passwd_age
        elif nodeName_ == 'min_passwd_age': 
            obj_ = None
            self.set_min_passwd_age(obj_)
            self.validate_min_passwd_age(self.min_passwd_age)    # validate type min_passwd_age
        elif nodeName_ == 'min_passwd_len': 
            obj_ = None
            self.set_min_passwd_len(obj_)
            self.validate_min_passwd_len(self.min_passwd_len)    # validate type min_passwd_len
        elif nodeName_ == 'password_hist_len': 
            obj_ = None
            self.set_password_hist_len(obj_)
            self.validate_password_hist_len(self.password_hist_len)    # validate type password_hist_len
        elif nodeName_ == 'password_complexity': 
            obj_ = None
            self.set_password_complexity(obj_)
            self.validate_password_complexity(self.password_complexity)    # validate type password_complexity
        elif nodeName_ == 'reversible_encryption': 
            obj_ = None
            self.set_reversible_encryption(obj_)
            self.validate_reversible_encryption(self.reversible_encryption)    # validate type reversible_encryption
        super(passwordpolicy_state, self).buildChildren(child_, nodeName_)
# end class passwordpolicy_state


class port_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(port_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if port_test.subclass:
            return port_test.subclass(*args_, **kwargs_)
        else:
            return port_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='port_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='port_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="port_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='port_test'):
        super(port_test, self).exportAttributes(outfile, level, namespace_, name_='port_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='port_test'):
        super(port_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(port_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='port_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(port_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(port_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(port_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(port_test, self).buildChildren(child_, nodeName_)
# end class port_test


class port_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, local_address=None, local_port=None, protocol=None):
        super(port_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.local_address = local_address
        self.local_port = local_port
        self.protocol = protocol
    def factory(*args_, **kwargs_):
        if port_object.subclass:
            return port_object.subclass(*args_, **kwargs_)
        else:
            return port_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_local_address(self): return self.local_address
    def set_local_address(self, local_address): self.local_address = local_address
    def validate_local_address(self, value):
        # validate type local_address
        pass
    def get_local_port(self): return self.local_port
    def set_local_port(self, local_port): self.local_port = local_port
    def validate_local_port(self, value):
        # validate type local_port
        pass
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def export(self, outfile, level, namespace_='win-def:', name_='port_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='port_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="port_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='port_object'):
        super(port_object, self).exportAttributes(outfile, level, namespace_, name_='port_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='port_object'):
        super(port_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.local_address is not None:
            showIndent(outfile, level)
            outfile.write('<%slocal_address>%s</%slocal_address>\n' % (namespace_, self.format_string(quote_xml(self.local_address).encode(ExternalEncoding), input_name='local_address'), namespace_))
        if self.local_port:
            self.local_port.export(outfile, level, namespace_, name_='local_port', )
        if self.protocol:
            self.protocol.export(outfile, level, namespace_, name_='protocol', )
    def hasContent_(self):
        if (
            self.set is not None or
            self.local_address is not None or
            self.local_port is not None or
            self.protocol is not None or
            super(port_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='port_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(port_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(port_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.local_address is not None:
            showIndent(outfile, level)
            outfile.write('local_address=%s,\n' % quote_python(self.local_address).encode(ExternalEncoding))
        if self.local_port is not None:
            showIndent(outfile, level)
            outfile.write('local_port=model_.EntityObjectIntType(\n')
            self.local_port.exportLiteral(outfile, level, name_='local_port')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=model_.EntityObjectProtocolType(\n')
            self.protocol.exportLiteral(outfile, level, name_='protocol')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(port_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'local_address':
            local_address_ = child_.text
            self.local_address = local_address_
            self.validate_local_address(self.local_address)    # validate type local_address
        elif nodeName_ == 'local_port': 
            obj_ = None
            self.set_local_port(obj_)
            self.validate_local_port(self.local_port)    # validate type local_port
        elif nodeName_ == 'protocol': 
            obj_ = EntityObjectProtocolType.factory()
            obj_.build(child_)
            self.set_protocol(obj_)
        super(port_object, self).buildChildren(child_, nodeName_)
# end class port_object


class port_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, local_address=None, local_port=None, protocol=None, pid=None):
        super(port_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.local_address = local_address
        self.local_port = local_port
        self.protocol = protocol
        self.pid = pid
    def factory(*args_, **kwargs_):
        if port_state.subclass:
            return port_state.subclass(*args_, **kwargs_)
        else:
            return port_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_local_address(self): return self.local_address
    def set_local_address(self, local_address): self.local_address = local_address
    def validate_local_address(self, value):
        # validate type local_address
        pass
    def get_local_port(self): return self.local_port
    def set_local_port(self, local_port): self.local_port = local_port
    def validate_local_port(self, value):
        # validate type local_port
        pass
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_pid(self): return self.pid
    def set_pid(self, pid): self.pid = pid
    def validate_pid(self, value):
        # validate type pid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='port_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='port_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="port_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='port_state'):
        super(port_state, self).exportAttributes(outfile, level, namespace_, name_='port_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='port_state'):
        super(port_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.local_address is not None:
            showIndent(outfile, level)
            outfile.write('<%slocal_address>%s</%slocal_address>\n' % (namespace_, self.format_string(quote_xml(self.local_address).encode(ExternalEncoding), input_name='local_address'), namespace_))
        if self.local_port:
            self.local_port.export(outfile, level, namespace_, name_='local_port')
        if self.protocol:
            self.protocol.export(outfile, level, namespace_, name_='protocol')
        if self.pid:
            self.pid.export(outfile, level, namespace_, name_='pid')
    def hasContent_(self):
        if (
            self.local_address is not None or
            self.local_port is not None or
            self.protocol is not None or
            self.pid is not None or
            super(port_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='port_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(port_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(port_state, self).exportLiteralChildren(outfile, level, name_)
        if self.local_address is not None:
            showIndent(outfile, level)
            outfile.write('local_address=%s,\n' % quote_python(self.local_address).encode(ExternalEncoding))
        if self.local_port is not None:
            showIndent(outfile, level)
            outfile.write('local_port=model_.EntityStateIntType(\n')
            self.local_port.exportLiteral(outfile, level, name_='local_port')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.protocol is not None:
            showIndent(outfile, level)
            outfile.write('protocol=model_.EntityStateProtocolType(\n')
            self.protocol.exportLiteral(outfile, level, name_='protocol')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pid is not None:
            showIndent(outfile, level)
            outfile.write('pid=model_.EntityStateIntType(\n')
            self.pid.exportLiteral(outfile, level, name_='pid')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(port_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'local_address':
            local_address_ = child_.text
            self.local_address = local_address_
            self.validate_local_address(self.local_address)    # validate type local_address
        elif nodeName_ == 'local_port': 
            obj_ = None
            self.set_local_port(obj_)
            self.validate_local_port(self.local_port)    # validate type local_port
        elif nodeName_ == 'protocol': 
            obj_ = EntityStateProtocolType.factory()
            obj_.build(child_)
            self.set_protocol(obj_)
        elif nodeName_ == 'pid': 
            obj_ = None
            self.set_pid(obj_)
            self.validate_pid(self.pid)    # validate type pid
        super(port_state, self).buildChildren(child_, nodeName_)
# end class port_state


class printereffectiverights_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(printereffectiverights_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if printereffectiverights_test.subclass:
            return printereffectiverights_test.subclass(*args_, **kwargs_)
        else:
            return printereffectiverights_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='printereffectiverights_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='printereffectiverights_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="printereffectiverights_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='printereffectiverights_test'):
        super(printereffectiverights_test, self).exportAttributes(outfile, level, namespace_, name_='printereffectiverights_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='printereffectiverights_test'):
        super(printereffectiverights_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(printereffectiverights_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='printereffectiverights_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(printereffectiverights_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(printereffectiverights_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(printereffectiverights_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(printereffectiverights_test, self).buildChildren(child_, nodeName_)
# end class printereffectiverights_test


class printereffectiverights_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, printer_name=None, trustee_sid=None):
        super(printereffectiverights_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.printer_name = printer_name
        self.trustee_sid = trustee_sid
    def factory(*args_, **kwargs_):
        if printereffectiverights_object.subclass:
            return printereffectiverights_object.subclass(*args_, **kwargs_)
        else:
            return printereffectiverights_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_printer_name(self): return self.printer_name
    def set_printer_name(self, printer_name): self.printer_name = printer_name
    def validate_printer_name(self, value):
        # validate type printer_name
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='printereffectiverights_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='printereffectiverights_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="printereffectiverights_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='printereffectiverights_object'):
        super(printereffectiverights_object, self).exportAttributes(outfile, level, namespace_, name_='printereffectiverights_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='printereffectiverights_object'):
        super(printereffectiverights_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.printer_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sprinter_name>%s</%sprinter_name>\n' % (namespace_, self.format_string(quote_xml(self.printer_name).encode(ExternalEncoding), input_name='printer_name'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.printer_name is not None or
            self.trustee_sid is not None or
            super(printereffectiverights_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='printereffectiverights_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(printereffectiverights_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(printereffectiverights_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.PrinterEffectiveRightsBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.printer_name is not None:
            showIndent(outfile, level)
            outfile.write('printer_name=%s,\n' % quote_python(self.printer_name).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(printereffectiverights_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = PrinterEffectiveRightsBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'printer_name':
            printer_name_ = child_.text
            self.printer_name = printer_name_
            self.validate_printer_name(self.printer_name)    # validate type printer_name
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        super(printereffectiverights_object, self).buildChildren(child_, nodeName_)
# end class printereffectiverights_object


class printereffectiverights_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, printer_name=None, trustee_sid=None, standard_delete=None, standard_read_control=None, standard_write_dac=None, standard_write_owner=None, standard_synchronize=None, access_system_security=None, generic_read=None, generic_write=None, generic_execute=None, generic_all=None, printer_access_administer=None, printer_access_use=None, job_access_administer=None, job_access_read=None):
        super(printereffectiverights_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.printer_name = printer_name
        self.trustee_sid = trustee_sid
        self.standard_delete = standard_delete
        self.standard_read_control = standard_read_control
        self.standard_write_dac = standard_write_dac
        self.standard_write_owner = standard_write_owner
        self.standard_synchronize = standard_synchronize
        self.access_system_security = access_system_security
        self.generic_read = generic_read
        self.generic_write = generic_write
        self.generic_execute = generic_execute
        self.generic_all = generic_all
        self.printer_access_administer = printer_access_administer
        self.printer_access_use = printer_access_use
        self.job_access_administer = job_access_administer
        self.job_access_read = job_access_read
    def factory(*args_, **kwargs_):
        if printereffectiverights_state.subclass:
            return printereffectiverights_state.subclass(*args_, **kwargs_)
        else:
            return printereffectiverights_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_printer_name(self): return self.printer_name
    def set_printer_name(self, printer_name): self.printer_name = printer_name
    def validate_printer_name(self, value):
        # validate type printer_name
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def get_standard_delete(self): return self.standard_delete
    def set_standard_delete(self, standard_delete): self.standard_delete = standard_delete
    def validate_standard_delete(self, value):
        # validate type standard_delete
        pass
    def get_standard_read_control(self): return self.standard_read_control
    def set_standard_read_control(self, standard_read_control): self.standard_read_control = standard_read_control
    def validate_standard_read_control(self, value):
        # validate type standard_read_control
        pass
    def get_standard_write_dac(self): return self.standard_write_dac
    def set_standard_write_dac(self, standard_write_dac): self.standard_write_dac = standard_write_dac
    def validate_standard_write_dac(self, value):
        # validate type standard_write_dac
        pass
    def get_standard_write_owner(self): return self.standard_write_owner
    def set_standard_write_owner(self, standard_write_owner): self.standard_write_owner = standard_write_owner
    def validate_standard_write_owner(self, value):
        # validate type standard_write_owner
        pass
    def get_standard_synchronize(self): return self.standard_synchronize
    def set_standard_synchronize(self, standard_synchronize): self.standard_synchronize = standard_synchronize
    def validate_standard_synchronize(self, value):
        # validate type standard_synchronize
        pass
    def get_access_system_security(self): return self.access_system_security
    def set_access_system_security(self, access_system_security): self.access_system_security = access_system_security
    def validate_access_system_security(self, value):
        # validate type access_system_security
        pass
    def get_generic_read(self): return self.generic_read
    def set_generic_read(self, generic_read): self.generic_read = generic_read
    def validate_generic_read(self, value):
        # validate type generic_read
        pass
    def get_generic_write(self): return self.generic_write
    def set_generic_write(self, generic_write): self.generic_write = generic_write
    def validate_generic_write(self, value):
        # validate type generic_write
        pass
    def get_generic_execute(self): return self.generic_execute
    def set_generic_execute(self, generic_execute): self.generic_execute = generic_execute
    def validate_generic_execute(self, value):
        # validate type generic_execute
        pass
    def get_generic_all(self): return self.generic_all
    def set_generic_all(self, generic_all): self.generic_all = generic_all
    def validate_generic_all(self, value):
        # validate type generic_all
        pass
    def get_printer_access_administer(self): return self.printer_access_administer
    def set_printer_access_administer(self, printer_access_administer): self.printer_access_administer = printer_access_administer
    def validate_printer_access_administer(self, value):
        # validate type printer_access_administer
        pass
    def get_printer_access_use(self): return self.printer_access_use
    def set_printer_access_use(self, printer_access_use): self.printer_access_use = printer_access_use
    def validate_printer_access_use(self, value):
        # validate type printer_access_use
        pass
    def get_job_access_administer(self): return self.job_access_administer
    def set_job_access_administer(self, job_access_administer): self.job_access_administer = job_access_administer
    def validate_job_access_administer(self, value):
        # validate type job_access_administer
        pass
    def get_job_access_read(self): return self.job_access_read
    def set_job_access_read(self, job_access_read): self.job_access_read = job_access_read
    def validate_job_access_read(self, value):
        # validate type job_access_read
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='printereffectiverights_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='printereffectiverights_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="printereffectiverights_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='printereffectiverights_state'):
        super(printereffectiverights_state, self).exportAttributes(outfile, level, namespace_, name_='printereffectiverights_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='printereffectiverights_state'):
        super(printereffectiverights_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.printer_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sprinter_name>%s</%sprinter_name>\n' % (namespace_, self.format_string(quote_xml(self.printer_name).encode(ExternalEncoding), input_name='printer_name'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
        if self.standard_delete:
            self.standard_delete.export(outfile, level, namespace_, name_='standard_delete')
        if self.standard_read_control:
            self.standard_read_control.export(outfile, level, namespace_, name_='standard_read_control')
        if self.standard_write_dac:
            self.standard_write_dac.export(outfile, level, namespace_, name_='standard_write_dac')
        if self.standard_write_owner:
            self.standard_write_owner.export(outfile, level, namespace_, name_='standard_write_owner')
        if self.standard_synchronize:
            self.standard_synchronize.export(outfile, level, namespace_, name_='standard_synchronize')
        if self.access_system_security:
            self.access_system_security.export(outfile, level, namespace_, name_='access_system_security')
        if self.generic_read:
            self.generic_read.export(outfile, level, namespace_, name_='generic_read')
        if self.generic_write:
            self.generic_write.export(outfile, level, namespace_, name_='generic_write')
        if self.generic_execute:
            self.generic_execute.export(outfile, level, namespace_, name_='generic_execute')
        if self.generic_all:
            self.generic_all.export(outfile, level, namespace_, name_='generic_all')
        if self.printer_access_administer:
            self.printer_access_administer.export(outfile, level, namespace_, name_='printer_access_administer')
        if self.printer_access_use:
            self.printer_access_use.export(outfile, level, namespace_, name_='printer_access_use')
        if self.job_access_administer:
            self.job_access_administer.export(outfile, level, namespace_, name_='job_access_administer')
        if self.job_access_read:
            self.job_access_read.export(outfile, level, namespace_, name_='job_access_read')
    def hasContent_(self):
        if (
            self.printer_name is not None or
            self.trustee_sid is not None or
            self.standard_delete is not None or
            self.standard_read_control is not None or
            self.standard_write_dac is not None or
            self.standard_write_owner is not None or
            self.standard_synchronize is not None or
            self.access_system_security is not None or
            self.generic_read is not None or
            self.generic_write is not None or
            self.generic_execute is not None or
            self.generic_all is not None or
            self.printer_access_administer is not None or
            self.printer_access_use is not None or
            self.job_access_administer is not None or
            self.job_access_read is not None or
            super(printereffectiverights_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='printereffectiverights_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(printereffectiverights_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(printereffectiverights_state, self).exportLiteralChildren(outfile, level, name_)
        if self.printer_name is not None:
            showIndent(outfile, level)
            outfile.write('printer_name=%s,\n' % quote_python(self.printer_name).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
        if self.standard_delete is not None:
            showIndent(outfile, level)
            outfile.write('standard_delete=model_.EntityStateBoolType(\n')
            self.standard_delete.exportLiteral(outfile, level, name_='standard_delete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_read_control is not None:
            showIndent(outfile, level)
            outfile.write('standard_read_control=model_.EntityStateBoolType(\n')
            self.standard_read_control.exportLiteral(outfile, level, name_='standard_read_control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_dac is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_dac=model_.EntityStateBoolType(\n')
            self.standard_write_dac.exportLiteral(outfile, level, name_='standard_write_dac')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_owner is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_owner=model_.EntityStateBoolType(\n')
            self.standard_write_owner.exportLiteral(outfile, level, name_='standard_write_owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_synchronize is not None:
            showIndent(outfile, level)
            outfile.write('standard_synchronize=model_.EntityStateBoolType(\n')
            self.standard_synchronize.exportLiteral(outfile, level, name_='standard_synchronize')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_system_security is not None:
            showIndent(outfile, level)
            outfile.write('access_system_security=model_.EntityStateBoolType(\n')
            self.access_system_security.exportLiteral(outfile, level, name_='access_system_security')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_read is not None:
            showIndent(outfile, level)
            outfile.write('generic_read=model_.EntityStateBoolType(\n')
            self.generic_read.exportLiteral(outfile, level, name_='generic_read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_write is not None:
            showIndent(outfile, level)
            outfile.write('generic_write=model_.EntityStateBoolType(\n')
            self.generic_write.exportLiteral(outfile, level, name_='generic_write')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_execute is not None:
            showIndent(outfile, level)
            outfile.write('generic_execute=model_.EntityStateBoolType(\n')
            self.generic_execute.exportLiteral(outfile, level, name_='generic_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_all is not None:
            showIndent(outfile, level)
            outfile.write('generic_all=model_.EntityStateBoolType(\n')
            self.generic_all.exportLiteral(outfile, level, name_='generic_all')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.printer_access_administer is not None:
            showIndent(outfile, level)
            outfile.write('printer_access_administer=model_.EntityStateBoolType(\n')
            self.printer_access_administer.exportLiteral(outfile, level, name_='printer_access_administer')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.printer_access_use is not None:
            showIndent(outfile, level)
            outfile.write('printer_access_use=model_.EntityStateBoolType(\n')
            self.printer_access_use.exportLiteral(outfile, level, name_='printer_access_use')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.job_access_administer is not None:
            showIndent(outfile, level)
            outfile.write('job_access_administer=model_.EntityStateBoolType(\n')
            self.job_access_administer.exportLiteral(outfile, level, name_='job_access_administer')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.job_access_read is not None:
            showIndent(outfile, level)
            outfile.write('job_access_read=model_.EntityStateBoolType(\n')
            self.job_access_read.exportLiteral(outfile, level, name_='job_access_read')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(printereffectiverights_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'printer_name':
            printer_name_ = child_.text
            self.printer_name = printer_name_
            self.validate_printer_name(self.printer_name)    # validate type printer_name
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        elif nodeName_ == 'standard_delete': 
            obj_ = None
            self.set_standard_delete(obj_)
            self.validate_standard_delete(self.standard_delete)    # validate type standard_delete
        elif nodeName_ == 'standard_read_control': 
            obj_ = None
            self.set_standard_read_control(obj_)
            self.validate_standard_read_control(self.standard_read_control)    # validate type standard_read_control
        elif nodeName_ == 'standard_write_dac': 
            obj_ = None
            self.set_standard_write_dac(obj_)
            self.validate_standard_write_dac(self.standard_write_dac)    # validate type standard_write_dac
        elif nodeName_ == 'standard_write_owner': 
            obj_ = None
            self.set_standard_write_owner(obj_)
            self.validate_standard_write_owner(self.standard_write_owner)    # validate type standard_write_owner
        elif nodeName_ == 'standard_synchronize': 
            obj_ = None
            self.set_standard_synchronize(obj_)
            self.validate_standard_synchronize(self.standard_synchronize)    # validate type standard_synchronize
        elif nodeName_ == 'access_system_security': 
            obj_ = None
            self.set_access_system_security(obj_)
            self.validate_access_system_security(self.access_system_security)    # validate type access_system_security
        elif nodeName_ == 'generic_read': 
            obj_ = None
            self.set_generic_read(obj_)
            self.validate_generic_read(self.generic_read)    # validate type generic_read
        elif nodeName_ == 'generic_write': 
            obj_ = None
            self.set_generic_write(obj_)
            self.validate_generic_write(self.generic_write)    # validate type generic_write
        elif nodeName_ == 'generic_execute': 
            obj_ = None
            self.set_generic_execute(obj_)
            self.validate_generic_execute(self.generic_execute)    # validate type generic_execute
        elif nodeName_ == 'generic_all': 
            obj_ = None
            self.set_generic_all(obj_)
            self.validate_generic_all(self.generic_all)    # validate type generic_all
        elif nodeName_ == 'printer_access_administer': 
            obj_ = None
            self.set_printer_access_administer(obj_)
            self.validate_printer_access_administer(self.printer_access_administer)    # validate type printer_access_administer
        elif nodeName_ == 'printer_access_use': 
            obj_ = None
            self.set_printer_access_use(obj_)
            self.validate_printer_access_use(self.printer_access_use)    # validate type printer_access_use
        elif nodeName_ == 'job_access_administer': 
            obj_ = None
            self.set_job_access_administer(obj_)
            self.validate_job_access_administer(self.job_access_administer)    # validate type job_access_administer
        elif nodeName_ == 'job_access_read': 
            obj_ = None
            self.set_job_access_read(obj_)
            self.validate_job_access_read(self.job_access_read)    # validate type job_access_read
        super(printereffectiverights_state, self).buildChildren(child_, nodeName_)
# end class printereffectiverights_state


class PrinterEffectiveRightsBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, include_group=True, resolve_group=False, valueOf_=None):
        self.include_group = _cast(bool, include_group)
        self.resolve_group = _cast(bool, resolve_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PrinterEffectiveRightsBehaviors.subclass:
            return PrinterEffectiveRightsBehaviors.subclass(*args_, **kwargs_)
        else:
            return PrinterEffectiveRightsBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='PrinterEffectiveRightsBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='PrinterEffectiveRightsBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='PrinterEffectiveRightsBehaviors'):
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='PrinterEffectiveRightsBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PrinterEffectiveRightsBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class PrinterEffectiveRightsBehaviors


class process_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(process_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if process_test.subclass:
            return process_test.subclass(*args_, **kwargs_)
        else:
            return process_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='process_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='process_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="process_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='process_test'):
        super(process_test, self).exportAttributes(outfile, level, namespace_, name_='process_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='process_test'):
        super(process_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(process_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='process_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(process_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(process_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(process_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(process_test, self).buildChildren(child_, nodeName_)
# end class process_test


class process_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, command_line=None):
        super(process_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.command_line = command_line
    def factory(*args_, **kwargs_):
        if process_object.subclass:
            return process_object.subclass(*args_, **kwargs_)
        else:
            return process_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_command_line(self): return self.command_line
    def set_command_line(self, command_line): self.command_line = command_line
    def validate_command_line(self, value):
        # validate type command_line
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='process_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='process_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="process_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='process_object'):
        super(process_object, self).exportAttributes(outfile, level, namespace_, name_='process_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='process_object'):
        super(process_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.command_line is not None:
            showIndent(outfile, level)
            outfile.write('<%scommand_line>%s</%scommand_line>\n' % (namespace_, self.format_string(quote_xml(self.command_line).encode(ExternalEncoding), input_name='command_line'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.command_line is not None or
            super(process_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='process_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(process_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(process_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.command_line is not None:
            showIndent(outfile, level)
            outfile.write('command_line=%s,\n' % quote_python(self.command_line).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(process_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'command_line':
            command_line_ = child_.text
            self.command_line = command_line_
            self.validate_command_line(self.command_line)    # validate type command_line
        super(process_object, self).buildChildren(child_, nodeName_)
# end class process_object


class process_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, command_line=None, pid=None, ppid=None, priority=None, image_path=None, current_dir=None):
        super(process_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.command_line = command_line
        self.pid = pid
        self.ppid = ppid
        self.priority = priority
        self.image_path = image_path
        self.current_dir = current_dir
    def factory(*args_, **kwargs_):
        if process_state.subclass:
            return process_state.subclass(*args_, **kwargs_)
        else:
            return process_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_command_line(self): return self.command_line
    def set_command_line(self, command_line): self.command_line = command_line
    def validate_command_line(self, value):
        # validate type command_line
        pass
    def get_pid(self): return self.pid
    def set_pid(self, pid): self.pid = pid
    def validate_pid(self, value):
        # validate type pid
        pass
    def get_ppid(self): return self.ppid
    def set_ppid(self, ppid): self.ppid = ppid
    def validate_ppid(self, value):
        # validate type ppid
        pass
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def validate_priority(self, value):
        # validate type priority
        pass
    def get_image_path(self): return self.image_path
    def set_image_path(self, image_path): self.image_path = image_path
    def validate_image_path(self, value):
        # validate type image_path
        pass
    def get_current_dir(self): return self.current_dir
    def set_current_dir(self, current_dir): self.current_dir = current_dir
    def validate_current_dir(self, value):
        # validate type current_dir
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='process_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='process_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="process_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='process_state'):
        super(process_state, self).exportAttributes(outfile, level, namespace_, name_='process_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='process_state'):
        super(process_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.command_line is not None:
            showIndent(outfile, level)
            outfile.write('<%scommand_line>%s</%scommand_line>\n' % (namespace_, self.format_string(quote_xml(self.command_line).encode(ExternalEncoding), input_name='command_line'), namespace_))
        if self.pid:
            self.pid.export(outfile, level, namespace_, name_='pid')
        if self.ppid:
            self.ppid.export(outfile, level, namespace_, name_='ppid')
        if self.priority is not None:
            showIndent(outfile, level)
            outfile.write('<%spriority>%s</%spriority>\n' % (namespace_, self.format_string(quote_xml(self.priority).encode(ExternalEncoding), input_name='priority'), namespace_))
        if self.image_path is not None:
            showIndent(outfile, level)
            outfile.write('<%simage_path>%s</%simage_path>\n' % (namespace_, self.format_string(quote_xml(self.image_path).encode(ExternalEncoding), input_name='image_path'), namespace_))
        if self.current_dir is not None:
            showIndent(outfile, level)
            outfile.write('<%scurrent_dir>%s</%scurrent_dir>\n' % (namespace_, self.format_string(quote_xml(self.current_dir).encode(ExternalEncoding), input_name='current_dir'), namespace_))
    def hasContent_(self):
        if (
            self.command_line is not None or
            self.pid is not None or
            self.ppid is not None or
            self.priority is not None or
            self.image_path is not None or
            self.current_dir is not None or
            super(process_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='process_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(process_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(process_state, self).exportLiteralChildren(outfile, level, name_)
        if self.command_line is not None:
            showIndent(outfile, level)
            outfile.write('command_line=%s,\n' % quote_python(self.command_line).encode(ExternalEncoding))
        if self.pid is not None:
            showIndent(outfile, level)
            outfile.write('pid=model_.EntityStateIntType(\n')
            self.pid.exportLiteral(outfile, level, name_='pid')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ppid is not None:
            showIndent(outfile, level)
            outfile.write('ppid=model_.EntityStateIntType(\n')
            self.ppid.exportLiteral(outfile, level, name_='ppid')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.priority is not None:
            showIndent(outfile, level)
            outfile.write('priority=%s,\n' % quote_python(self.priority).encode(ExternalEncoding))
        if self.image_path is not None:
            showIndent(outfile, level)
            outfile.write('image_path=%s,\n' % quote_python(self.image_path).encode(ExternalEncoding))
        if self.current_dir is not None:
            showIndent(outfile, level)
            outfile.write('current_dir=%s,\n' % quote_python(self.current_dir).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(process_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'command_line':
            command_line_ = child_.text
            self.command_line = command_line_
            self.validate_command_line(self.command_line)    # validate type command_line
        elif nodeName_ == 'pid': 
            obj_ = None
            self.set_pid(obj_)
            self.validate_pid(self.pid)    # validate type pid
        elif nodeName_ == 'ppid': 
            obj_ = None
            self.set_ppid(obj_)
            self.validate_ppid(self.ppid)    # validate type ppid
        elif nodeName_ == 'priority':
            priority_ = child_.text
            self.priority = priority_
            self.validate_priority(self.priority)    # validate type priority
        elif nodeName_ == 'image_path':
            image_path_ = child_.text
            self.image_path = image_path_
            self.validate_image_path(self.image_path)    # validate type image_path
        elif nodeName_ == 'current_dir':
            current_dir_ = child_.text
            self.current_dir = current_dir_
            self.validate_current_dir(self.current_dir)    # validate type current_dir
        super(process_state, self).buildChildren(child_, nodeName_)
# end class process_state


class registry_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(registry_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if registry_test.subclass:
            return registry_test.subclass(*args_, **kwargs_)
        else:
            return registry_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='registry_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<win-def:registry_test')
        self.exportAttributes(outfile, level, namespace_, name_='registry_test')
        #outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        #outfile.write(' xsi:type="registry_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</win-def:registry_test>\n')
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='registry_test'):
        super(registry_test, self).exportAttributes(outfile, level, namespace_, name_='registry_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='registry_test'):
        super(registry_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, 'win-def:', name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, 'win-def:', name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(registry_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='registry_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(registry_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(registry_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(registry_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(registry_test, self).buildChildren(child_, nodeName_)
# end class registry_test


class registry_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, hive=None, key=None, name=None):
        super(registry_object, self).__init__(comment, deprecated, version, id)
        self.set = set
        self.behaviors = behaviors
        self.hive = hive
        self.key = key
        self.name = name
    def factory(*args_, **kwargs_):
        if registry_object.subclass:
            return registry_object.subclass(*args_, **kwargs_)
        else:
            return registry_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_hive(self): return self.hive
    def set_hive(self, hive): self.hive = hive
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_name(self, value):
        # validate type name
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='registry_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<win-def:registry_object')
        self.exportAttributes(outfile, level, namespace_, name_='registry_object')
        #outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        #outfile.write(' xsi:type="registry_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</win-def:registry_object>\n')
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='registry_object'):
        super(registry_object, self).exportAttributes(outfile, level, namespace_, name_='registry_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='registry_object'):
        #super(registry_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.hive is not None:
            self.hive.export(outfile, level, 'win-def:', name_='hive')
        if self.key is not None:
            self.key.export(outfile, level, 'win-def:', name_='key')
        if self.name is not None:
            self.name.export(outfile, level, 'win-def:', name_='name')
        else:
          showIndent(outfile, level)
          outfile.write('<win-def:name xsi:nil="true"/>\n')
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.hive is not None or
            self.key is not None or
            self.name is not None or
            super(registry_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='registry_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(registry_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(registry_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.RegistryBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.hive is not None:
            showIndent(outfile, level)
            outfile.write('hive=model_.EntityObjectRegistryHiveType(\n')
            self.hive.exportLiteral(outfile, level, name_='hive')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(registry_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = RegistryBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'hive': 
            obj_ = EntityObjectRegistryHiveType.factory()
            obj_.build(child_)
            self.set_hive(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'name':
            name_ = child_.text
            self.name = name_
            self.validate_name(self.name)    # validate type name
        super(registry_object, self).buildChildren(child_, nodeName_)
# end class registry_object


class registry_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, hive=None, key=None, name=None, type_=None, value=None):
        super(registry_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.hive = hive
        self.key = key
        self.name = name
        self.type_ = type_
        self.value = value
    def factory(*args_, **kwargs_):
        if registry_state.subclass:
            return registry_state.subclass(*args_, **kwargs_)
        else:
            return registry_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hive(self): return self.hive
    def set_hive(self, hive): self.hive = hive
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_name(self, value):
        # validate type name
        pass
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_value(self, value):
        # validate type value
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='registry_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % ('win-def:', 'registry_state', namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='registry_state')
        #outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        #outfile.write(' xsi:type="registry_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % ('win-def:', 'registry_state'))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='registry_state'):
        super(registry_state, self).exportAttributes(outfile, level, namespace_, name_='registry_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='registry_state'):
        super(registry_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.hive:
            self.hive.export(outfile, level, 'win-def:', name_='hive')
        if self.key is not None:
            self.key.export(outfile, level, 'win-def:', name_='key')
        if self.name is not None:
            self.name.export(outfile, level, 'win-def:', name_='name')
        if self.type_:
            self.type_.export(outfile, level, 'win-def:', name_='type')
        if self.value is not None:
            self.value.export(outfile, level, 'win-def:', name_='value')
    def hasContent_(self):
        if (
            self.hive is not None or
            self.key is not None or
            self.name is not None or
            self.type_ is not None or
            self.value is not None or
            super(registry_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='registry_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(registry_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(registry_state, self).exportLiteralChildren(outfile, level, name_)
        if self.hive is not None:
            showIndent(outfile, level)
            outfile.write('hive=model_.EntityStateRegistryHiveType(\n')
            self.hive.exportLiteral(outfile, level, name_='hive')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.EntityStateRegistryTypeType(\n')
            self.type_.exportLiteral(outfile, level, name_='type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(registry_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'hive': 
            obj_ = EntityStateRegistryHiveType.factory()
            obj_.build(child_)
            self.set_hive(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'name':
            name_ = child_.text
            self.name = name_
            self.validate_name(self.name)    # validate type name
        elif nodeName_ == 'type': 
            obj_ = EntityStateRegistryTypeType.factory()
            obj_.build(child_)
            self.set_type(obj_)
        elif nodeName_ == 'value':
            value_ = child_.text
            self.value = value_
            self.validate_value(self.value)    # validate type value
        super(registry_state, self).buildChildren(child_, nodeName_)
# end class registry_state


class RegistryBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, recurse_direction='none', max_depth=-1, valueOf_=None):
        self.recurse_direction = _cast(None, recurse_direction)
        self.max_depth = _cast(int, max_depth)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RegistryBehaviors.subclass:
            return RegistryBehaviors.subclass(*args_, **kwargs_)
        else:
            return RegistryBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_recurse_direction(self): return self.recurse_direction
    def set_recurse_direction(self, recurse_direction): self.recurse_direction = recurse_direction
    def get_max_depth(self): return self.max_depth
    def set_max_depth(self, max_depth): self.max_depth = max_depth
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='RegistryBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RegistryBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='RegistryBehaviors'):
        if self.recurse_direction is not None:
            outfile.write(' recurse_direction=%s' % (self.format_string(quote_attrib(self.recurse_direction).encode(ExternalEncoding), input_name='recurse_direction'), ))
        if self.max_depth is not None:
            outfile.write(' max_depth="%s"' % self.format_integer(self.max_depth, input_name='max_depth'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='RegistryBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegistryBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.recurse_direction is not None:
            showIndent(outfile, level)
            outfile.write('recurse_direction = "%s",\n' % (self.recurse_direction,))
        if self.max_depth is not None:
            showIndent(outfile, level)
            outfile.write('max_depth = %d,\n' % (self.max_depth,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('recurse_direction')
        if value is not None:
            self.recurse_direction = value
        value = attrs.get('max_depth')
        if value is not None:
            try:
                self.max_depth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, nodeName_):
        pass
# end class RegistryBehaviors


class regkeyauditedpermissions53_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(regkeyauditedpermissions53_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if regkeyauditedpermissions53_test.subclass:
            return regkeyauditedpermissions53_test.subclass(*args_, **kwargs_)
        else:
            return regkeyauditedpermissions53_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions53_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions53_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyauditedpermissions53_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions53_test'):
        super(regkeyauditedpermissions53_test, self).exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions53_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions53_test'):
        super(regkeyauditedpermissions53_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(regkeyauditedpermissions53_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyauditedpermissions53_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyauditedpermissions53_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyauditedpermissions53_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyauditedpermissions53_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(regkeyauditedpermissions53_test, self).buildChildren(child_, nodeName_)
# end class regkeyauditedpermissions53_test


class regkeyauditedpermissions53_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, hive=None, key=None, trustee_sid=None):
        super(regkeyauditedpermissions53_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.hive = hive
        self.key = key
        self.trustee_sid = trustee_sid
    def factory(*args_, **kwargs_):
        if regkeyauditedpermissions53_object.subclass:
            return regkeyauditedpermissions53_object.subclass(*args_, **kwargs_)
        else:
            return regkeyauditedpermissions53_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_hive(self): return self.hive
    def set_hive(self, hive): self.hive = hive
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions53_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions53_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyauditedpermissions53_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions53_object'):
        super(regkeyauditedpermissions53_object, self).exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions53_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions53_object'):
        super(regkeyauditedpermissions53_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.hive:
            self.hive.export(outfile, level, namespace_, name_='hive', )
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.hive is not None or
            self.key is not None or
            self.trustee_sid is not None or
            super(regkeyauditedpermissions53_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyauditedpermissions53_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyauditedpermissions53_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyauditedpermissions53_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.RegkeyAuditPermissions53Behaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.hive is not None:
            showIndent(outfile, level)
            outfile.write('hive=model_.EntityObjectRegistryHiveType(\n')
            self.hive.exportLiteral(outfile, level, name_='hive')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyauditedpermissions53_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = RegkeyAuditPermissions53Behaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'hive': 
            obj_ = EntityObjectRegistryHiveType.factory()
            obj_.build(child_)
            self.set_hive(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        super(regkeyauditedpermissions53_object, self).buildChildren(child_, nodeName_)
# end class regkeyauditedpermissions53_object


class regkeyauditedpermissions53_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, hive=None, key=None, trustee_sid=None, standard_delete=None, standard_read_control=None, standard_write_dac=None, standard_write_owner=None, standard_synchronize=None, access_system_security=None, generic_read=None, generic_write=None, generic_execute=None, generic_all=None, key_query_value=None, key_set_value=None, key_create_sub_key=None, key_enumerate_sub_keys=None, key_notify=None, key_create_link=None, key_wow64_64key=None, key_wow64_32key=None, key_wow64_res=None):
        super(regkeyauditedpermissions53_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.hive = hive
        self.key = key
        self.trustee_sid = trustee_sid
        self.standard_delete = standard_delete
        self.standard_read_control = standard_read_control
        self.standard_write_dac = standard_write_dac
        self.standard_write_owner = standard_write_owner
        self.standard_synchronize = standard_synchronize
        self.access_system_security = access_system_security
        self.generic_read = generic_read
        self.generic_write = generic_write
        self.generic_execute = generic_execute
        self.generic_all = generic_all
        self.key_query_value = key_query_value
        self.key_set_value = key_set_value
        self.key_create_sub_key = key_create_sub_key
        self.key_enumerate_sub_keys = key_enumerate_sub_keys
        self.key_notify = key_notify
        self.key_create_link = key_create_link
        self.key_wow64_64key = key_wow64_64key
        self.key_wow64_32key = key_wow64_32key
        self.key_wow64_res = key_wow64_res
    def factory(*args_, **kwargs_):
        if regkeyauditedpermissions53_state.subclass:
            return regkeyauditedpermissions53_state.subclass(*args_, **kwargs_)
        else:
            return regkeyauditedpermissions53_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hive(self): return self.hive
    def set_hive(self, hive): self.hive = hive
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def get_standard_delete(self): return self.standard_delete
    def set_standard_delete(self, standard_delete): self.standard_delete = standard_delete
    def get_standard_read_control(self): return self.standard_read_control
    def set_standard_read_control(self, standard_read_control): self.standard_read_control = standard_read_control
    def get_standard_write_dac(self): return self.standard_write_dac
    def set_standard_write_dac(self, standard_write_dac): self.standard_write_dac = standard_write_dac
    def get_standard_write_owner(self): return self.standard_write_owner
    def set_standard_write_owner(self, standard_write_owner): self.standard_write_owner = standard_write_owner
    def get_standard_synchronize(self): return self.standard_synchronize
    def set_standard_synchronize(self, standard_synchronize): self.standard_synchronize = standard_synchronize
    def get_access_system_security(self): return self.access_system_security
    def set_access_system_security(self, access_system_security): self.access_system_security = access_system_security
    def get_generic_read(self): return self.generic_read
    def set_generic_read(self, generic_read): self.generic_read = generic_read
    def get_generic_write(self): return self.generic_write
    def set_generic_write(self, generic_write): self.generic_write = generic_write
    def get_generic_execute(self): return self.generic_execute
    def set_generic_execute(self, generic_execute): self.generic_execute = generic_execute
    def get_generic_all(self): return self.generic_all
    def set_generic_all(self, generic_all): self.generic_all = generic_all
    def get_key_query_value(self): return self.key_query_value
    def set_key_query_value(self, key_query_value): self.key_query_value = key_query_value
    def get_key_set_value(self): return self.key_set_value
    def set_key_set_value(self, key_set_value): self.key_set_value = key_set_value
    def get_key_create_sub_key(self): return self.key_create_sub_key
    def set_key_create_sub_key(self, key_create_sub_key): self.key_create_sub_key = key_create_sub_key
    def get_key_enumerate_sub_keys(self): return self.key_enumerate_sub_keys
    def set_key_enumerate_sub_keys(self, key_enumerate_sub_keys): self.key_enumerate_sub_keys = key_enumerate_sub_keys
    def get_key_notify(self): return self.key_notify
    def set_key_notify(self, key_notify): self.key_notify = key_notify
    def get_key_create_link(self): return self.key_create_link
    def set_key_create_link(self, key_create_link): self.key_create_link = key_create_link
    def get_key_wow64_64key(self): return self.key_wow64_64key
    def set_key_wow64_64key(self, key_wow64_64key): self.key_wow64_64key = key_wow64_64key
    def get_key_wow64_32key(self): return self.key_wow64_32key
    def set_key_wow64_32key(self, key_wow64_32key): self.key_wow64_32key = key_wow64_32key
    def get_key_wow64_res(self): return self.key_wow64_res
    def set_key_wow64_res(self, key_wow64_res): self.key_wow64_res = key_wow64_res
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions53_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions53_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyauditedpermissions53_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions53_state'):
        super(regkeyauditedpermissions53_state, self).exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions53_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions53_state'):
        super(regkeyauditedpermissions53_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.hive:
            self.hive.export(outfile, level, namespace_, name_='hive')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
        if self.standard_delete:
            self.standard_delete.export(outfile, level, namespace_, name_='standard_delete')
        if self.standard_read_control:
            self.standard_read_control.export(outfile, level, namespace_, name_='standard_read_control')
        if self.standard_write_dac:
            self.standard_write_dac.export(outfile, level, namespace_, name_='standard_write_dac')
        if self.standard_write_owner:
            self.standard_write_owner.export(outfile, level, namespace_, name_='standard_write_owner')
        if self.standard_synchronize:
            self.standard_synchronize.export(outfile, level, namespace_, name_='standard_synchronize')
        if self.access_system_security:
            self.access_system_security.export(outfile, level, namespace_, name_='access_system_security')
        if self.generic_read:
            self.generic_read.export(outfile, level, namespace_, name_='generic_read')
        if self.generic_write:
            self.generic_write.export(outfile, level, namespace_, name_='generic_write')
        if self.generic_execute:
            self.generic_execute.export(outfile, level, namespace_, name_='generic_execute')
        if self.generic_all:
            self.generic_all.export(outfile, level, namespace_, name_='generic_all')
        if self.key_query_value:
            self.key_query_value.export(outfile, level, namespace_, name_='key_query_value')
        if self.key_set_value:
            self.key_set_value.export(outfile, level, namespace_, name_='key_set_value')
        if self.key_create_sub_key:
            self.key_create_sub_key.export(outfile, level, namespace_, name_='key_create_sub_key')
        if self.key_enumerate_sub_keys:
            self.key_enumerate_sub_keys.export(outfile, level, namespace_, name_='key_enumerate_sub_keys')
        if self.key_notify:
            self.key_notify.export(outfile, level, namespace_, name_='key_notify')
        if self.key_create_link:
            self.key_create_link.export(outfile, level, namespace_, name_='key_create_link')
        if self.key_wow64_64key:
            self.key_wow64_64key.export(outfile, level, namespace_, name_='key_wow64_64key')
        if self.key_wow64_32key:
            self.key_wow64_32key.export(outfile, level, namespace_, name_='key_wow64_32key')
        if self.key_wow64_res:
            self.key_wow64_res.export(outfile, level, namespace_, name_='key_wow64_res')
    def hasContent_(self):
        if (
            self.hive is not None or
            self.key is not None or
            self.trustee_sid is not None or
            self.standard_delete is not None or
            self.standard_read_control is not None or
            self.standard_write_dac is not None or
            self.standard_write_owner is not None or
            self.standard_synchronize is not None or
            self.access_system_security is not None or
            self.generic_read is not None or
            self.generic_write is not None or
            self.generic_execute is not None or
            self.generic_all is not None or
            self.key_query_value is not None or
            self.key_set_value is not None or
            self.key_create_sub_key is not None or
            self.key_enumerate_sub_keys is not None or
            self.key_notify is not None or
            self.key_create_link is not None or
            self.key_wow64_64key is not None or
            self.key_wow64_32key is not None or
            self.key_wow64_res is not None or
            super(regkeyauditedpermissions53_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyauditedpermissions53_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyauditedpermissions53_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyauditedpermissions53_state, self).exportLiteralChildren(outfile, level, name_)
        if self.hive is not None:
            showIndent(outfile, level)
            outfile.write('hive=model_.EntityStateRegistryHiveType(\n')
            self.hive.exportLiteral(outfile, level, name_='hive')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
        if self.standard_delete is not None:
            showIndent(outfile, level)
            outfile.write('standard_delete=model_.EntityStateAuditType(\n')
            self.standard_delete.exportLiteral(outfile, level, name_='standard_delete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_read_control is not None:
            showIndent(outfile, level)
            outfile.write('standard_read_control=model_.EntityStateAuditType(\n')
            self.standard_read_control.exportLiteral(outfile, level, name_='standard_read_control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_dac is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_dac=model_.EntityStateAuditType(\n')
            self.standard_write_dac.exportLiteral(outfile, level, name_='standard_write_dac')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_owner is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_owner=model_.EntityStateAuditType(\n')
            self.standard_write_owner.exportLiteral(outfile, level, name_='standard_write_owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_synchronize is not None:
            showIndent(outfile, level)
            outfile.write('standard_synchronize=model_.EntityStateAuditType(\n')
            self.standard_synchronize.exportLiteral(outfile, level, name_='standard_synchronize')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_system_security is not None:
            showIndent(outfile, level)
            outfile.write('access_system_security=model_.EntityStateAuditType(\n')
            self.access_system_security.exportLiteral(outfile, level, name_='access_system_security')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_read is not None:
            showIndent(outfile, level)
            outfile.write('generic_read=model_.EntityStateAuditType(\n')
            self.generic_read.exportLiteral(outfile, level, name_='generic_read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_write is not None:
            showIndent(outfile, level)
            outfile.write('generic_write=model_.EntityStateAuditType(\n')
            self.generic_write.exportLiteral(outfile, level, name_='generic_write')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_execute is not None:
            showIndent(outfile, level)
            outfile.write('generic_execute=model_.EntityStateAuditType(\n')
            self.generic_execute.exportLiteral(outfile, level, name_='generic_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_all is not None:
            showIndent(outfile, level)
            outfile.write('generic_all=model_.EntityStateAuditType(\n')
            self.generic_all.exportLiteral(outfile, level, name_='generic_all')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_query_value is not None:
            showIndent(outfile, level)
            outfile.write('key_query_value=model_.EntityStateAuditType(\n')
            self.key_query_value.exportLiteral(outfile, level, name_='key_query_value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_set_value is not None:
            showIndent(outfile, level)
            outfile.write('key_set_value=model_.EntityStateAuditType(\n')
            self.key_set_value.exportLiteral(outfile, level, name_='key_set_value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_create_sub_key is not None:
            showIndent(outfile, level)
            outfile.write('key_create_sub_key=model_.EntityStateAuditType(\n')
            self.key_create_sub_key.exportLiteral(outfile, level, name_='key_create_sub_key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_enumerate_sub_keys is not None:
            showIndent(outfile, level)
            outfile.write('key_enumerate_sub_keys=model_.EntityStateAuditType(\n')
            self.key_enumerate_sub_keys.exportLiteral(outfile, level, name_='key_enumerate_sub_keys')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_notify is not None:
            showIndent(outfile, level)
            outfile.write('key_notify=model_.EntityStateAuditType(\n')
            self.key_notify.exportLiteral(outfile, level, name_='key_notify')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_create_link is not None:
            showIndent(outfile, level)
            outfile.write('key_create_link=model_.EntityStateAuditType(\n')
            self.key_create_link.exportLiteral(outfile, level, name_='key_create_link')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_64key is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_64key=model_.EntityStateAuditType(\n')
            self.key_wow64_64key.exportLiteral(outfile, level, name_='key_wow64_64key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_32key is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_32key=model_.EntityStateAuditType(\n')
            self.key_wow64_32key.exportLiteral(outfile, level, name_='key_wow64_32key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_res is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_res=model_.EntityStateAuditType(\n')
            self.key_wow64_res.exportLiteral(outfile, level, name_='key_wow64_res')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyauditedpermissions53_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'hive': 
            obj_ = EntityStateRegistryHiveType.factory()
            obj_.build(child_)
            self.set_hive(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        elif nodeName_ == 'standard_delete': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_delete(obj_)
        elif nodeName_ == 'standard_read_control': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_read_control(obj_)
        elif nodeName_ == 'standard_write_dac': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_write_dac(obj_)
        elif nodeName_ == 'standard_write_owner': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_write_owner(obj_)
        elif nodeName_ == 'standard_synchronize': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_synchronize(obj_)
        elif nodeName_ == 'access_system_security': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_access_system_security(obj_)
        elif nodeName_ == 'generic_read': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_read(obj_)
        elif nodeName_ == 'generic_write': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_write(obj_)
        elif nodeName_ == 'generic_execute': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_execute(obj_)
        elif nodeName_ == 'generic_all': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_all(obj_)
        elif nodeName_ == 'key_query_value': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_query_value(obj_)
        elif nodeName_ == 'key_set_value': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_set_value(obj_)
        elif nodeName_ == 'key_create_sub_key': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_create_sub_key(obj_)
        elif nodeName_ == 'key_enumerate_sub_keys': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_enumerate_sub_keys(obj_)
        elif nodeName_ == 'key_notify': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_notify(obj_)
        elif nodeName_ == 'key_create_link': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_create_link(obj_)
        elif nodeName_ == 'key_wow64_64key': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_wow64_64key(obj_)
        elif nodeName_ == 'key_wow64_32key': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_wow64_32key(obj_)
        elif nodeName_ == 'key_wow64_res': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_wow64_res(obj_)
        super(regkeyauditedpermissions53_state, self).buildChildren(child_, nodeName_)
# end class regkeyauditedpermissions53_state


class RegkeyAuditPermissions53Behaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resolve_group=False, recurse_direction='none', max_depth=-1, include_group=True, valueOf_=None):
        self.resolve_group = _cast(bool, resolve_group)
        self.recurse_direction = _cast(None, recurse_direction)
        self.max_depth = _cast(int, max_depth)
        self.include_group = _cast(bool, include_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RegkeyAuditPermissions53Behaviors.subclass:
            return RegkeyAuditPermissions53Behaviors.subclass(*args_, **kwargs_)
        else:
            return RegkeyAuditPermissions53Behaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_recurse_direction(self): return self.recurse_direction
    def set_recurse_direction(self, recurse_direction): self.recurse_direction = recurse_direction
    def get_max_depth(self): return self.max_depth
    def set_max_depth(self, max_depth): self.max_depth = max_depth
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='RegkeyAuditPermissions53Behaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RegkeyAuditPermissions53Behaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='RegkeyAuditPermissions53Behaviors'):
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
        if self.recurse_direction is not None:
            outfile.write(' recurse_direction=%s' % (self.format_string(quote_attrib(self.recurse_direction).encode(ExternalEncoding), input_name='recurse_direction'), ))
        if self.max_depth is not None:
            outfile.write(' max_depth="%s"' % self.format_integer(self.max_depth, input_name='max_depth'))
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='RegkeyAuditPermissions53Behaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegkeyAuditPermissions53Behaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
        if self.recurse_direction is not None:
            showIndent(outfile, level)
            outfile.write('recurse_direction = "%s",\n' % (self.recurse_direction,))
        if self.max_depth is not None:
            showIndent(outfile, level)
            outfile.write('max_depth = %d,\n' % (self.max_depth,))
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('recurse_direction')
        if value is not None:
            self.recurse_direction = value
        value = attrs.get('max_depth')
        if value is not None:
            try:
                self.max_depth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class RegkeyAuditPermissions53Behaviors


class regkeyauditedpermissions_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(regkeyauditedpermissions_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if regkeyauditedpermissions_test.subclass:
            return regkeyauditedpermissions_test.subclass(*args_, **kwargs_)
        else:
            return regkeyauditedpermissions_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyauditedpermissions_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions_test'):
        super(regkeyauditedpermissions_test, self).exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions_test'):
        super(regkeyauditedpermissions_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(regkeyauditedpermissions_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyauditedpermissions_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyauditedpermissions_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyauditedpermissions_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyauditedpermissions_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(regkeyauditedpermissions_test, self).buildChildren(child_, nodeName_)
# end class regkeyauditedpermissions_test


class regkeyauditedpermissions_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, hive=None, key=None, trustee_name=None):
        super(regkeyauditedpermissions_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.hive = hive
        self.key = key
        self.trustee_name = trustee_name
    def factory(*args_, **kwargs_):
        if regkeyauditedpermissions_object.subclass:
            return regkeyauditedpermissions_object.subclass(*args_, **kwargs_)
        else:
            return regkeyauditedpermissions_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_hive(self): return self.hive
    def set_hive(self, hive): self.hive = hive
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyauditedpermissions_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions_object'):
        super(regkeyauditedpermissions_object, self).exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions_object'):
        super(regkeyauditedpermissions_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.hive:
            self.hive.export(outfile, level, namespace_, name_='hive', )
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.hive is not None or
            self.key is not None or
            self.trustee_name is not None or
            super(regkeyauditedpermissions_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyauditedpermissions_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyauditedpermissions_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyauditedpermissions_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.RegkeyAuditPermissionsBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.hive is not None:
            showIndent(outfile, level)
            outfile.write('hive=model_.EntityObjectRegistryHiveType(\n')
            self.hive.exportLiteral(outfile, level, name_='hive')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyauditedpermissions_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = RegkeyAuditPermissionsBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'hive': 
            obj_ = EntityObjectRegistryHiveType.factory()
            obj_.build(child_)
            self.set_hive(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        super(regkeyauditedpermissions_object, self).buildChildren(child_, nodeName_)
# end class regkeyauditedpermissions_object


class regkeyauditedpermissions_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, hive=None, key=None, trustee_name=None, standard_delete=None, standard_read_control=None, standard_write_dac=None, standard_write_owner=None, standard_synchronize=None, access_system_security=None, generic_read=None, generic_write=None, generic_execute=None, generic_all=None, key_query_value=None, key_set_value=None, key_create_sub_key=None, key_enumerate_sub_keys=None, key_notify=None, key_create_link=None, key_wow64_64key=None, key_wow64_32key=None, key_wow64_res=None):
        super(regkeyauditedpermissions_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.hive = hive
        self.key = key
        self.trustee_name = trustee_name
        self.standard_delete = standard_delete
        self.standard_read_control = standard_read_control
        self.standard_write_dac = standard_write_dac
        self.standard_write_owner = standard_write_owner
        self.standard_synchronize = standard_synchronize
        self.access_system_security = access_system_security
        self.generic_read = generic_read
        self.generic_write = generic_write
        self.generic_execute = generic_execute
        self.generic_all = generic_all
        self.key_query_value = key_query_value
        self.key_set_value = key_set_value
        self.key_create_sub_key = key_create_sub_key
        self.key_enumerate_sub_keys = key_enumerate_sub_keys
        self.key_notify = key_notify
        self.key_create_link = key_create_link
        self.key_wow64_64key = key_wow64_64key
        self.key_wow64_32key = key_wow64_32key
        self.key_wow64_res = key_wow64_res
    def factory(*args_, **kwargs_):
        if regkeyauditedpermissions_state.subclass:
            return regkeyauditedpermissions_state.subclass(*args_, **kwargs_)
        else:
            return regkeyauditedpermissions_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hive(self): return self.hive
    def set_hive(self, hive): self.hive = hive
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def get_standard_delete(self): return self.standard_delete
    def set_standard_delete(self, standard_delete): self.standard_delete = standard_delete
    def get_standard_read_control(self): return self.standard_read_control
    def set_standard_read_control(self, standard_read_control): self.standard_read_control = standard_read_control
    def get_standard_write_dac(self): return self.standard_write_dac
    def set_standard_write_dac(self, standard_write_dac): self.standard_write_dac = standard_write_dac
    def get_standard_write_owner(self): return self.standard_write_owner
    def set_standard_write_owner(self, standard_write_owner): self.standard_write_owner = standard_write_owner
    def get_standard_synchronize(self): return self.standard_synchronize
    def set_standard_synchronize(self, standard_synchronize): self.standard_synchronize = standard_synchronize
    def get_access_system_security(self): return self.access_system_security
    def set_access_system_security(self, access_system_security): self.access_system_security = access_system_security
    def get_generic_read(self): return self.generic_read
    def set_generic_read(self, generic_read): self.generic_read = generic_read
    def get_generic_write(self): return self.generic_write
    def set_generic_write(self, generic_write): self.generic_write = generic_write
    def get_generic_execute(self): return self.generic_execute
    def set_generic_execute(self, generic_execute): self.generic_execute = generic_execute
    def get_generic_all(self): return self.generic_all
    def set_generic_all(self, generic_all): self.generic_all = generic_all
    def get_key_query_value(self): return self.key_query_value
    def set_key_query_value(self, key_query_value): self.key_query_value = key_query_value
    def get_key_set_value(self): return self.key_set_value
    def set_key_set_value(self, key_set_value): self.key_set_value = key_set_value
    def get_key_create_sub_key(self): return self.key_create_sub_key
    def set_key_create_sub_key(self, key_create_sub_key): self.key_create_sub_key = key_create_sub_key
    def get_key_enumerate_sub_keys(self): return self.key_enumerate_sub_keys
    def set_key_enumerate_sub_keys(self, key_enumerate_sub_keys): self.key_enumerate_sub_keys = key_enumerate_sub_keys
    def get_key_notify(self): return self.key_notify
    def set_key_notify(self, key_notify): self.key_notify = key_notify
    def get_key_create_link(self): return self.key_create_link
    def set_key_create_link(self, key_create_link): self.key_create_link = key_create_link
    def get_key_wow64_64key(self): return self.key_wow64_64key
    def set_key_wow64_64key(self, key_wow64_64key): self.key_wow64_64key = key_wow64_64key
    def get_key_wow64_32key(self): return self.key_wow64_32key
    def set_key_wow64_32key(self, key_wow64_32key): self.key_wow64_32key = key_wow64_32key
    def get_key_wow64_res(self): return self.key_wow64_res
    def set_key_wow64_res(self, key_wow64_res): self.key_wow64_res = key_wow64_res
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyauditedpermissions_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions_state'):
        super(regkeyauditedpermissions_state, self).exportAttributes(outfile, level, namespace_, name_='regkeyauditedpermissions_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyauditedpermissions_state'):
        super(regkeyauditedpermissions_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.hive:
            self.hive.export(outfile, level, namespace_, name_='hive')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
        if self.standard_delete:
            self.standard_delete.export(outfile, level, namespace_, name_='standard_delete')
        if self.standard_read_control:
            self.standard_read_control.export(outfile, level, namespace_, name_='standard_read_control')
        if self.standard_write_dac:
            self.standard_write_dac.export(outfile, level, namespace_, name_='standard_write_dac')
        if self.standard_write_owner:
            self.standard_write_owner.export(outfile, level, namespace_, name_='standard_write_owner')
        if self.standard_synchronize:
            self.standard_synchronize.export(outfile, level, namespace_, name_='standard_synchronize')
        if self.access_system_security:
            self.access_system_security.export(outfile, level, namespace_, name_='access_system_security')
        if self.generic_read:
            self.generic_read.export(outfile, level, namespace_, name_='generic_read')
        if self.generic_write:
            self.generic_write.export(outfile, level, namespace_, name_='generic_write')
        if self.generic_execute:
            self.generic_execute.export(outfile, level, namespace_, name_='generic_execute')
        if self.generic_all:
            self.generic_all.export(outfile, level, namespace_, name_='generic_all')
        if self.key_query_value:
            self.key_query_value.export(outfile, level, namespace_, name_='key_query_value')
        if self.key_set_value:
            self.key_set_value.export(outfile, level, namespace_, name_='key_set_value')
        if self.key_create_sub_key:
            self.key_create_sub_key.export(outfile, level, namespace_, name_='key_create_sub_key')
        if self.key_enumerate_sub_keys:
            self.key_enumerate_sub_keys.export(outfile, level, namespace_, name_='key_enumerate_sub_keys')
        if self.key_notify:
            self.key_notify.export(outfile, level, namespace_, name_='key_notify')
        if self.key_create_link:
            self.key_create_link.export(outfile, level, namespace_, name_='key_create_link')
        if self.key_wow64_64key:
            self.key_wow64_64key.export(outfile, level, namespace_, name_='key_wow64_64key')
        if self.key_wow64_32key:
            self.key_wow64_32key.export(outfile, level, namespace_, name_='key_wow64_32key')
        if self.key_wow64_res:
            self.key_wow64_res.export(outfile, level, namespace_, name_='key_wow64_res')
    def hasContent_(self):
        if (
            self.hive is not None or
            self.key is not None or
            self.trustee_name is not None or
            self.standard_delete is not None or
            self.standard_read_control is not None or
            self.standard_write_dac is not None or
            self.standard_write_owner is not None or
            self.standard_synchronize is not None or
            self.access_system_security is not None or
            self.generic_read is not None or
            self.generic_write is not None or
            self.generic_execute is not None or
            self.generic_all is not None or
            self.key_query_value is not None or
            self.key_set_value is not None or
            self.key_create_sub_key is not None or
            self.key_enumerate_sub_keys is not None or
            self.key_notify is not None or
            self.key_create_link is not None or
            self.key_wow64_64key is not None or
            self.key_wow64_32key is not None or
            self.key_wow64_res is not None or
            super(regkeyauditedpermissions_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyauditedpermissions_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyauditedpermissions_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyauditedpermissions_state, self).exportLiteralChildren(outfile, level, name_)
        if self.hive is not None:
            showIndent(outfile, level)
            outfile.write('hive=model_.EntityStateRegistryHiveType(\n')
            self.hive.exportLiteral(outfile, level, name_='hive')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
        if self.standard_delete is not None:
            showIndent(outfile, level)
            outfile.write('standard_delete=model_.EntityStateAuditType(\n')
            self.standard_delete.exportLiteral(outfile, level, name_='standard_delete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_read_control is not None:
            showIndent(outfile, level)
            outfile.write('standard_read_control=model_.EntityStateAuditType(\n')
            self.standard_read_control.exportLiteral(outfile, level, name_='standard_read_control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_dac is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_dac=model_.EntityStateAuditType(\n')
            self.standard_write_dac.exportLiteral(outfile, level, name_='standard_write_dac')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_owner is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_owner=model_.EntityStateAuditType(\n')
            self.standard_write_owner.exportLiteral(outfile, level, name_='standard_write_owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_synchronize is not None:
            showIndent(outfile, level)
            outfile.write('standard_synchronize=model_.EntityStateAuditType(\n')
            self.standard_synchronize.exportLiteral(outfile, level, name_='standard_synchronize')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_system_security is not None:
            showIndent(outfile, level)
            outfile.write('access_system_security=model_.EntityStateAuditType(\n')
            self.access_system_security.exportLiteral(outfile, level, name_='access_system_security')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_read is not None:
            showIndent(outfile, level)
            outfile.write('generic_read=model_.EntityStateAuditType(\n')
            self.generic_read.exportLiteral(outfile, level, name_='generic_read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_write is not None:
            showIndent(outfile, level)
            outfile.write('generic_write=model_.EntityStateAuditType(\n')
            self.generic_write.exportLiteral(outfile, level, name_='generic_write')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_execute is not None:
            showIndent(outfile, level)
            outfile.write('generic_execute=model_.EntityStateAuditType(\n')
            self.generic_execute.exportLiteral(outfile, level, name_='generic_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_all is not None:
            showIndent(outfile, level)
            outfile.write('generic_all=model_.EntityStateAuditType(\n')
            self.generic_all.exportLiteral(outfile, level, name_='generic_all')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_query_value is not None:
            showIndent(outfile, level)
            outfile.write('key_query_value=model_.EntityStateAuditType(\n')
            self.key_query_value.exportLiteral(outfile, level, name_='key_query_value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_set_value is not None:
            showIndent(outfile, level)
            outfile.write('key_set_value=model_.EntityStateAuditType(\n')
            self.key_set_value.exportLiteral(outfile, level, name_='key_set_value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_create_sub_key is not None:
            showIndent(outfile, level)
            outfile.write('key_create_sub_key=model_.EntityStateAuditType(\n')
            self.key_create_sub_key.exportLiteral(outfile, level, name_='key_create_sub_key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_enumerate_sub_keys is not None:
            showIndent(outfile, level)
            outfile.write('key_enumerate_sub_keys=model_.EntityStateAuditType(\n')
            self.key_enumerate_sub_keys.exportLiteral(outfile, level, name_='key_enumerate_sub_keys')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_notify is not None:
            showIndent(outfile, level)
            outfile.write('key_notify=model_.EntityStateAuditType(\n')
            self.key_notify.exportLiteral(outfile, level, name_='key_notify')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_create_link is not None:
            showIndent(outfile, level)
            outfile.write('key_create_link=model_.EntityStateAuditType(\n')
            self.key_create_link.exportLiteral(outfile, level, name_='key_create_link')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_64key is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_64key=model_.EntityStateAuditType(\n')
            self.key_wow64_64key.exportLiteral(outfile, level, name_='key_wow64_64key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_32key is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_32key=model_.EntityStateAuditType(\n')
            self.key_wow64_32key.exportLiteral(outfile, level, name_='key_wow64_32key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_res is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_res=model_.EntityStateAuditType(\n')
            self.key_wow64_res.exportLiteral(outfile, level, name_='key_wow64_res')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyauditedpermissions_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'hive': 
            obj_ = EntityStateRegistryHiveType.factory()
            obj_.build(child_)
            self.set_hive(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        elif nodeName_ == 'standard_delete': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_delete(obj_)
        elif nodeName_ == 'standard_read_control': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_read_control(obj_)
        elif nodeName_ == 'standard_write_dac': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_write_dac(obj_)
        elif nodeName_ == 'standard_write_owner': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_write_owner(obj_)
        elif nodeName_ == 'standard_synchronize': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_standard_synchronize(obj_)
        elif nodeName_ == 'access_system_security': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_access_system_security(obj_)
        elif nodeName_ == 'generic_read': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_read(obj_)
        elif nodeName_ == 'generic_write': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_write(obj_)
        elif nodeName_ == 'generic_execute': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_execute(obj_)
        elif nodeName_ == 'generic_all': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_generic_all(obj_)
        elif nodeName_ == 'key_query_value': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_query_value(obj_)
        elif nodeName_ == 'key_set_value': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_set_value(obj_)
        elif nodeName_ == 'key_create_sub_key': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_create_sub_key(obj_)
        elif nodeName_ == 'key_enumerate_sub_keys': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_enumerate_sub_keys(obj_)
        elif nodeName_ == 'key_notify': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_notify(obj_)
        elif nodeName_ == 'key_create_link': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_create_link(obj_)
        elif nodeName_ == 'key_wow64_64key': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_wow64_64key(obj_)
        elif nodeName_ == 'key_wow64_32key': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_wow64_32key(obj_)
        elif nodeName_ == 'key_wow64_res': 
            obj_ = EntityStateAuditType.factory()
            obj_.build(child_)
            self.set_key_wow64_res(obj_)
        super(regkeyauditedpermissions_state, self).buildChildren(child_, nodeName_)
# end class regkeyauditedpermissions_state


class RegkeyAuditPermissionsBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resolve_group=False, recurse_direction='none', max_depth=-1, include_group=True, valueOf_=None):
        self.resolve_group = _cast(bool, resolve_group)
        self.recurse_direction = _cast(None, recurse_direction)
        self.max_depth = _cast(int, max_depth)
        self.include_group = _cast(bool, include_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RegkeyAuditPermissionsBehaviors.subclass:
            return RegkeyAuditPermissionsBehaviors.subclass(*args_, **kwargs_)
        else:
            return RegkeyAuditPermissionsBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_recurse_direction(self): return self.recurse_direction
    def set_recurse_direction(self, recurse_direction): self.recurse_direction = recurse_direction
    def get_max_depth(self): return self.max_depth
    def set_max_depth(self, max_depth): self.max_depth = max_depth
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='RegkeyAuditPermissionsBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RegkeyAuditPermissionsBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='RegkeyAuditPermissionsBehaviors'):
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
        if self.recurse_direction is not None:
            outfile.write(' recurse_direction=%s' % (self.format_string(quote_attrib(self.recurse_direction).encode(ExternalEncoding), input_name='recurse_direction'), ))
        if self.max_depth is not None:
            outfile.write(' max_depth="%s"' % self.format_integer(self.max_depth, input_name='max_depth'))
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='RegkeyAuditPermissionsBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegkeyAuditPermissionsBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
        if self.recurse_direction is not None:
            showIndent(outfile, level)
            outfile.write('recurse_direction = "%s",\n' % (self.recurse_direction,))
        if self.max_depth is not None:
            showIndent(outfile, level)
            outfile.write('max_depth = %d,\n' % (self.max_depth,))
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('recurse_direction')
        if value is not None:
            self.recurse_direction = value
        value = attrs.get('max_depth')
        if value is not None:
            try:
                self.max_depth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class RegkeyAuditPermissionsBehaviors


class regkeyeffectiverights53_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(regkeyeffectiverights53_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if regkeyeffectiverights53_test.subclass:
            return regkeyeffectiverights53_test.subclass(*args_, **kwargs_)
        else:
            return regkeyeffectiverights53_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights53_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights53_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyeffectiverights53_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights53_test'):
        super(regkeyeffectiverights53_test, self).exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights53_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights53_test'):
        super(regkeyeffectiverights53_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(regkeyeffectiverights53_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyeffectiverights53_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyeffectiverights53_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyeffectiverights53_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyeffectiverights53_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(regkeyeffectiverights53_test, self).buildChildren(child_, nodeName_)
# end class regkeyeffectiverights53_test


class regkeyeffectiverights53_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, hive=None, key=None, trustee_sid=None):
        super(regkeyeffectiverights53_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.hive = hive
        self.key = key
        self.trustee_sid = trustee_sid
    def factory(*args_, **kwargs_):
        if regkeyeffectiverights53_object.subclass:
            return regkeyeffectiverights53_object.subclass(*args_, **kwargs_)
        else:
            return regkeyeffectiverights53_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_hive(self): return self.hive
    def set_hive(self, hive): self.hive = hive
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights53_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights53_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyeffectiverights53_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights53_object'):
        super(regkeyeffectiverights53_object, self).exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights53_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights53_object'):
        super(regkeyeffectiverights53_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.hive:
            self.hive.export(outfile, level, namespace_, name_='hive', )
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.hive is not None or
            self.key is not None or
            self.trustee_sid is not None or
            super(regkeyeffectiverights53_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyeffectiverights53_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyeffectiverights53_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyeffectiverights53_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.RegkeyEffectiveRights53Behaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.hive is not None:
            showIndent(outfile, level)
            outfile.write('hive=model_.EntityObjectRegistryHiveType(\n')
            self.hive.exportLiteral(outfile, level, name_='hive')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyeffectiverights53_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = RegkeyEffectiveRights53Behaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'hive': 
            obj_ = EntityObjectRegistryHiveType.factory()
            obj_.build(child_)
            self.set_hive(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        super(regkeyeffectiverights53_object, self).buildChildren(child_, nodeName_)
# end class regkeyeffectiverights53_object


class regkeyeffectiverights53_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, hive=None, key=None, trustee_sid=None, standard_delete=None, standard_read_control=None, standard_write_dac=None, standard_write_owner=None, standard_synchronize=None, access_system_security=None, generic_read=None, generic_write=None, generic_execute=None, generic_all=None, key_query_value=None, key_set_value=None, key_create_sub_key=None, key_enumerate_sub_keys=None, key_notify=None, key_create_link=None, key_wow64_64key=None, key_wow64_32key=None, key_wow64_res=None):
        super(regkeyeffectiverights53_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.hive = hive
        self.key = key
        self.trustee_sid = trustee_sid
        self.standard_delete = standard_delete
        self.standard_read_control = standard_read_control
        self.standard_write_dac = standard_write_dac
        self.standard_write_owner = standard_write_owner
        self.standard_synchronize = standard_synchronize
        self.access_system_security = access_system_security
        self.generic_read = generic_read
        self.generic_write = generic_write
        self.generic_execute = generic_execute
        self.generic_all = generic_all
        self.key_query_value = key_query_value
        self.key_set_value = key_set_value
        self.key_create_sub_key = key_create_sub_key
        self.key_enumerate_sub_keys = key_enumerate_sub_keys
        self.key_notify = key_notify
        self.key_create_link = key_create_link
        self.key_wow64_64key = key_wow64_64key
        self.key_wow64_32key = key_wow64_32key
        self.key_wow64_res = key_wow64_res
    def factory(*args_, **kwargs_):
        if regkeyeffectiverights53_state.subclass:
            return regkeyeffectiverights53_state.subclass(*args_, **kwargs_)
        else:
            return regkeyeffectiverights53_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hive(self): return self.hive
    def set_hive(self, hive): self.hive = hive
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def get_standard_delete(self): return self.standard_delete
    def set_standard_delete(self, standard_delete): self.standard_delete = standard_delete
    def validate_standard_delete(self, value):
        # validate type standard_delete
        pass
    def get_standard_read_control(self): return self.standard_read_control
    def set_standard_read_control(self, standard_read_control): self.standard_read_control = standard_read_control
    def validate_standard_read_control(self, value):
        # validate type standard_read_control
        pass
    def get_standard_write_dac(self): return self.standard_write_dac
    def set_standard_write_dac(self, standard_write_dac): self.standard_write_dac = standard_write_dac
    def validate_standard_write_dac(self, value):
        # validate type standard_write_dac
        pass
    def get_standard_write_owner(self): return self.standard_write_owner
    def set_standard_write_owner(self, standard_write_owner): self.standard_write_owner = standard_write_owner
    def validate_standard_write_owner(self, value):
        # validate type standard_write_owner
        pass
    def get_standard_synchronize(self): return self.standard_synchronize
    def set_standard_synchronize(self, standard_synchronize): self.standard_synchronize = standard_synchronize
    def validate_standard_synchronize(self, value):
        # validate type standard_synchronize
        pass
    def get_access_system_security(self): return self.access_system_security
    def set_access_system_security(self, access_system_security): self.access_system_security = access_system_security
    def validate_access_system_security(self, value):
        # validate type access_system_security
        pass
    def get_generic_read(self): return self.generic_read
    def set_generic_read(self, generic_read): self.generic_read = generic_read
    def validate_generic_read(self, value):
        # validate type generic_read
        pass
    def get_generic_write(self): return self.generic_write
    def set_generic_write(self, generic_write): self.generic_write = generic_write
    def validate_generic_write(self, value):
        # validate type generic_write
        pass
    def get_generic_execute(self): return self.generic_execute
    def set_generic_execute(self, generic_execute): self.generic_execute = generic_execute
    def validate_generic_execute(self, value):
        # validate type generic_execute
        pass
    def get_generic_all(self): return self.generic_all
    def set_generic_all(self, generic_all): self.generic_all = generic_all
    def validate_generic_all(self, value):
        # validate type generic_all
        pass
    def get_key_query_value(self): return self.key_query_value
    def set_key_query_value(self, key_query_value): self.key_query_value = key_query_value
    def validate_key_query_value(self, value):
        # validate type key_query_value
        pass
    def get_key_set_value(self): return self.key_set_value
    def set_key_set_value(self, key_set_value): self.key_set_value = key_set_value
    def validate_key_set_value(self, value):
        # validate type key_set_value
        pass
    def get_key_create_sub_key(self): return self.key_create_sub_key
    def set_key_create_sub_key(self, key_create_sub_key): self.key_create_sub_key = key_create_sub_key
    def validate_key_create_sub_key(self, value):
        # validate type key_create_sub_key
        pass
    def get_key_enumerate_sub_keys(self): return self.key_enumerate_sub_keys
    def set_key_enumerate_sub_keys(self, key_enumerate_sub_keys): self.key_enumerate_sub_keys = key_enumerate_sub_keys
    def validate_key_enumerate_sub_keys(self, value):
        # validate type key_enumerate_sub_keys
        pass
    def get_key_notify(self): return self.key_notify
    def set_key_notify(self, key_notify): self.key_notify = key_notify
    def validate_key_notify(self, value):
        # validate type key_notify
        pass
    def get_key_create_link(self): return self.key_create_link
    def set_key_create_link(self, key_create_link): self.key_create_link = key_create_link
    def validate_key_create_link(self, value):
        # validate type key_create_link
        pass
    def get_key_wow64_64key(self): return self.key_wow64_64key
    def set_key_wow64_64key(self, key_wow64_64key): self.key_wow64_64key = key_wow64_64key
    def validate_key_wow64_64key(self, value):
        # validate type key_wow64_64key
        pass
    def get_key_wow64_32key(self): return self.key_wow64_32key
    def set_key_wow64_32key(self, key_wow64_32key): self.key_wow64_32key = key_wow64_32key
    def validate_key_wow64_32key(self, value):
        # validate type key_wow64_32key
        pass
    def get_key_wow64_res(self): return self.key_wow64_res
    def set_key_wow64_res(self, key_wow64_res): self.key_wow64_res = key_wow64_res
    def validate_key_wow64_res(self, value):
        # validate type key_wow64_res
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights53_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights53_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyeffectiverights53_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights53_state'):
        super(regkeyeffectiverights53_state, self).exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights53_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights53_state'):
        super(regkeyeffectiverights53_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.hive:
            self.hive.export(outfile, level, namespace_, name_='hive')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
        if self.standard_delete:
            self.standard_delete.export(outfile, level, namespace_, name_='standard_delete')
        if self.standard_read_control:
            self.standard_read_control.export(outfile, level, namespace_, name_='standard_read_control')
        if self.standard_write_dac:
            self.standard_write_dac.export(outfile, level, namespace_, name_='standard_write_dac')
        if self.standard_write_owner:
            self.standard_write_owner.export(outfile, level, namespace_, name_='standard_write_owner')
        if self.standard_synchronize:
            self.standard_synchronize.export(outfile, level, namespace_, name_='standard_synchronize')
        if self.access_system_security:
            self.access_system_security.export(outfile, level, namespace_, name_='access_system_security')
        if self.generic_read:
            self.generic_read.export(outfile, level, namespace_, name_='generic_read')
        if self.generic_write:
            self.generic_write.export(outfile, level, namespace_, name_='generic_write')
        if self.generic_execute:
            self.generic_execute.export(outfile, level, namespace_, name_='generic_execute')
        if self.generic_all:
            self.generic_all.export(outfile, level, namespace_, name_='generic_all')
        if self.key_query_value:
            self.key_query_value.export(outfile, level, namespace_, name_='key_query_value')
        if self.key_set_value:
            self.key_set_value.export(outfile, level, namespace_, name_='key_set_value')
        if self.key_create_sub_key:
            self.key_create_sub_key.export(outfile, level, namespace_, name_='key_create_sub_key')
        if self.key_enumerate_sub_keys:
            self.key_enumerate_sub_keys.export(outfile, level, namespace_, name_='key_enumerate_sub_keys')
        if self.key_notify:
            self.key_notify.export(outfile, level, namespace_, name_='key_notify')
        if self.key_create_link:
            self.key_create_link.export(outfile, level, namespace_, name_='key_create_link')
        if self.key_wow64_64key:
            self.key_wow64_64key.export(outfile, level, namespace_, name_='key_wow64_64key')
        if self.key_wow64_32key:
            self.key_wow64_32key.export(outfile, level, namespace_, name_='key_wow64_32key')
        if self.key_wow64_res:
            self.key_wow64_res.export(outfile, level, namespace_, name_='key_wow64_res')
    def hasContent_(self):
        if (
            self.hive is not None or
            self.key is not None or
            self.trustee_sid is not None or
            self.standard_delete is not None or
            self.standard_read_control is not None or
            self.standard_write_dac is not None or
            self.standard_write_owner is not None or
            self.standard_synchronize is not None or
            self.access_system_security is not None or
            self.generic_read is not None or
            self.generic_write is not None or
            self.generic_execute is not None or
            self.generic_all is not None or
            self.key_query_value is not None or
            self.key_set_value is not None or
            self.key_create_sub_key is not None or
            self.key_enumerate_sub_keys is not None or
            self.key_notify is not None or
            self.key_create_link is not None or
            self.key_wow64_64key is not None or
            self.key_wow64_32key is not None or
            self.key_wow64_res is not None or
            super(regkeyeffectiverights53_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyeffectiverights53_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyeffectiverights53_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyeffectiverights53_state, self).exportLiteralChildren(outfile, level, name_)
        if self.hive is not None:
            showIndent(outfile, level)
            outfile.write('hive=model_.EntityStateRegistryHiveType(\n')
            self.hive.exportLiteral(outfile, level, name_='hive')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
        if self.standard_delete is not None:
            showIndent(outfile, level)
            outfile.write('standard_delete=model_.EntityStateBoolType(\n')
            self.standard_delete.exportLiteral(outfile, level, name_='standard_delete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_read_control is not None:
            showIndent(outfile, level)
            outfile.write('standard_read_control=model_.EntityStateBoolType(\n')
            self.standard_read_control.exportLiteral(outfile, level, name_='standard_read_control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_dac is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_dac=model_.EntityStateBoolType(\n')
            self.standard_write_dac.exportLiteral(outfile, level, name_='standard_write_dac')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_owner is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_owner=model_.EntityStateBoolType(\n')
            self.standard_write_owner.exportLiteral(outfile, level, name_='standard_write_owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_synchronize is not None:
            showIndent(outfile, level)
            outfile.write('standard_synchronize=model_.EntityStateBoolType(\n')
            self.standard_synchronize.exportLiteral(outfile, level, name_='standard_synchronize')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_system_security is not None:
            showIndent(outfile, level)
            outfile.write('access_system_security=model_.EntityStateBoolType(\n')
            self.access_system_security.exportLiteral(outfile, level, name_='access_system_security')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_read is not None:
            showIndent(outfile, level)
            outfile.write('generic_read=model_.EntityStateBoolType(\n')
            self.generic_read.exportLiteral(outfile, level, name_='generic_read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_write is not None:
            showIndent(outfile, level)
            outfile.write('generic_write=model_.EntityStateBoolType(\n')
            self.generic_write.exportLiteral(outfile, level, name_='generic_write')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_execute is not None:
            showIndent(outfile, level)
            outfile.write('generic_execute=model_.EntityStateBoolType(\n')
            self.generic_execute.exportLiteral(outfile, level, name_='generic_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_all is not None:
            showIndent(outfile, level)
            outfile.write('generic_all=model_.EntityStateBoolType(\n')
            self.generic_all.exportLiteral(outfile, level, name_='generic_all')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_query_value is not None:
            showIndent(outfile, level)
            outfile.write('key_query_value=model_.EntityStateBoolType(\n')
            self.key_query_value.exportLiteral(outfile, level, name_='key_query_value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_set_value is not None:
            showIndent(outfile, level)
            outfile.write('key_set_value=model_.EntityStateBoolType(\n')
            self.key_set_value.exportLiteral(outfile, level, name_='key_set_value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_create_sub_key is not None:
            showIndent(outfile, level)
            outfile.write('key_create_sub_key=model_.EntityStateBoolType(\n')
            self.key_create_sub_key.exportLiteral(outfile, level, name_='key_create_sub_key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_enumerate_sub_keys is not None:
            showIndent(outfile, level)
            outfile.write('key_enumerate_sub_keys=model_.EntityStateBoolType(\n')
            self.key_enumerate_sub_keys.exportLiteral(outfile, level, name_='key_enumerate_sub_keys')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_notify is not None:
            showIndent(outfile, level)
            outfile.write('key_notify=model_.EntityStateBoolType(\n')
            self.key_notify.exportLiteral(outfile, level, name_='key_notify')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_create_link is not None:
            showIndent(outfile, level)
            outfile.write('key_create_link=model_.EntityStateBoolType(\n')
            self.key_create_link.exportLiteral(outfile, level, name_='key_create_link')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_64key is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_64key=model_.EntityStateBoolType(\n')
            self.key_wow64_64key.exportLiteral(outfile, level, name_='key_wow64_64key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_32key is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_32key=model_.EntityStateBoolType(\n')
            self.key_wow64_32key.exportLiteral(outfile, level, name_='key_wow64_32key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_res is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_res=model_.EntityStateBoolType(\n')
            self.key_wow64_res.exportLiteral(outfile, level, name_='key_wow64_res')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyeffectiverights53_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'hive': 
            obj_ = EntityStateRegistryHiveType.factory()
            obj_.build(child_)
            self.set_hive(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        elif nodeName_ == 'standard_delete': 
            obj_ = None
            self.set_standard_delete(obj_)
            self.validate_standard_delete(self.standard_delete)    # validate type standard_delete
        elif nodeName_ == 'standard_read_control': 
            obj_ = None
            self.set_standard_read_control(obj_)
            self.validate_standard_read_control(self.standard_read_control)    # validate type standard_read_control
        elif nodeName_ == 'standard_write_dac': 
            obj_ = None
            self.set_standard_write_dac(obj_)
            self.validate_standard_write_dac(self.standard_write_dac)    # validate type standard_write_dac
        elif nodeName_ == 'standard_write_owner': 
            obj_ = None
            self.set_standard_write_owner(obj_)
            self.validate_standard_write_owner(self.standard_write_owner)    # validate type standard_write_owner
        elif nodeName_ == 'standard_synchronize': 
            obj_ = None
            self.set_standard_synchronize(obj_)
            self.validate_standard_synchronize(self.standard_synchronize)    # validate type standard_synchronize
        elif nodeName_ == 'access_system_security': 
            obj_ = None
            self.set_access_system_security(obj_)
            self.validate_access_system_security(self.access_system_security)    # validate type access_system_security
        elif nodeName_ == 'generic_read': 
            obj_ = None
            self.set_generic_read(obj_)
            self.validate_generic_read(self.generic_read)    # validate type generic_read
        elif nodeName_ == 'generic_write': 
            obj_ = None
            self.set_generic_write(obj_)
            self.validate_generic_write(self.generic_write)    # validate type generic_write
        elif nodeName_ == 'generic_execute': 
            obj_ = None
            self.set_generic_execute(obj_)
            self.validate_generic_execute(self.generic_execute)    # validate type generic_execute
        elif nodeName_ == 'generic_all': 
            obj_ = None
            self.set_generic_all(obj_)
            self.validate_generic_all(self.generic_all)    # validate type generic_all
        elif nodeName_ == 'key_query_value': 
            obj_ = None
            self.set_key_query_value(obj_)
            self.validate_key_query_value(self.key_query_value)    # validate type key_query_value
        elif nodeName_ == 'key_set_value': 
            obj_ = None
            self.set_key_set_value(obj_)
            self.validate_key_set_value(self.key_set_value)    # validate type key_set_value
        elif nodeName_ == 'key_create_sub_key': 
            obj_ = None
            self.set_key_create_sub_key(obj_)
            self.validate_key_create_sub_key(self.key_create_sub_key)    # validate type key_create_sub_key
        elif nodeName_ == 'key_enumerate_sub_keys': 
            obj_ = None
            self.set_key_enumerate_sub_keys(obj_)
            self.validate_key_enumerate_sub_keys(self.key_enumerate_sub_keys)    # validate type key_enumerate_sub_keys
        elif nodeName_ == 'key_notify': 
            obj_ = None
            self.set_key_notify(obj_)
            self.validate_key_notify(self.key_notify)    # validate type key_notify
        elif nodeName_ == 'key_create_link': 
            obj_ = None
            self.set_key_create_link(obj_)
            self.validate_key_create_link(self.key_create_link)    # validate type key_create_link
        elif nodeName_ == 'key_wow64_64key': 
            obj_ = None
            self.set_key_wow64_64key(obj_)
            self.validate_key_wow64_64key(self.key_wow64_64key)    # validate type key_wow64_64key
        elif nodeName_ == 'key_wow64_32key': 
            obj_ = None
            self.set_key_wow64_32key(obj_)
            self.validate_key_wow64_32key(self.key_wow64_32key)    # validate type key_wow64_32key
        elif nodeName_ == 'key_wow64_res': 
            obj_ = None
            self.set_key_wow64_res(obj_)
            self.validate_key_wow64_res(self.key_wow64_res)    # validate type key_wow64_res
        super(regkeyeffectiverights53_state, self).buildChildren(child_, nodeName_)
# end class regkeyeffectiverights53_state


class RegkeyEffectiveRights53Behaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resolve_group=False, recurse_direction='none', max_depth=-1, include_group=True, valueOf_=None):
        self.resolve_group = _cast(bool, resolve_group)
        self.recurse_direction = _cast(None, recurse_direction)
        self.max_depth = _cast(int, max_depth)
        self.include_group = _cast(bool, include_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RegkeyEffectiveRights53Behaviors.subclass:
            return RegkeyEffectiveRights53Behaviors.subclass(*args_, **kwargs_)
        else:
            return RegkeyEffectiveRights53Behaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_recurse_direction(self): return self.recurse_direction
    def set_recurse_direction(self, recurse_direction): self.recurse_direction = recurse_direction
    def get_max_depth(self): return self.max_depth
    def set_max_depth(self, max_depth): self.max_depth = max_depth
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='RegkeyEffectiveRights53Behaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RegkeyEffectiveRights53Behaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='RegkeyEffectiveRights53Behaviors'):
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
        if self.recurse_direction is not None:
            outfile.write(' recurse_direction=%s' % (self.format_string(quote_attrib(self.recurse_direction).encode(ExternalEncoding), input_name='recurse_direction'), ))
        if self.max_depth is not None:
            outfile.write(' max_depth="%s"' % self.format_integer(self.max_depth, input_name='max_depth'))
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='RegkeyEffectiveRights53Behaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegkeyEffectiveRights53Behaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
        if self.recurse_direction is not None:
            showIndent(outfile, level)
            outfile.write('recurse_direction = "%s",\n' % (self.recurse_direction,))
        if self.max_depth is not None:
            showIndent(outfile, level)
            outfile.write('max_depth = %d,\n' % (self.max_depth,))
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('recurse_direction')
        if value is not None:
            self.recurse_direction = value
        value = attrs.get('max_depth')
        if value is not None:
            try:
                self.max_depth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class RegkeyEffectiveRights53Behaviors


class regkeyeffectiverights_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(regkeyeffectiverights_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if regkeyeffectiverights_test.subclass:
            return regkeyeffectiverights_test.subclass(*args_, **kwargs_)
        else:
            return regkeyeffectiverights_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyeffectiverights_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights_test'):
        super(regkeyeffectiverights_test, self).exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights_test'):
        super(regkeyeffectiverights_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(regkeyeffectiverights_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyeffectiverights_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyeffectiverights_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyeffectiverights_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyeffectiverights_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(regkeyeffectiverights_test, self).buildChildren(child_, nodeName_)
# end class regkeyeffectiverights_test


class regkeyeffectiverights_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, hive=None, key=None, trustee_name=None):
        super(regkeyeffectiverights_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.hive = hive
        self.key = key
        self.trustee_name = trustee_name
    def factory(*args_, **kwargs_):
        if regkeyeffectiverights_object.subclass:
            return regkeyeffectiverights_object.subclass(*args_, **kwargs_)
        else:
            return regkeyeffectiverights_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_hive(self): return self.hive
    def set_hive(self, hive): self.hive = hive
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyeffectiverights_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights_object'):
        super(regkeyeffectiverights_object, self).exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights_object'):
        super(regkeyeffectiverights_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.hive:
            self.hive.export(outfile, level, namespace_, name_='hive', )
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.hive is not None or
            self.key is not None or
            self.trustee_name is not None or
            super(regkeyeffectiverights_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyeffectiverights_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyeffectiverights_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyeffectiverights_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.RegkeyEffectiveRightsBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.hive is not None:
            showIndent(outfile, level)
            outfile.write('hive=model_.EntityObjectRegistryHiveType(\n')
            self.hive.exportLiteral(outfile, level, name_='hive')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyeffectiverights_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = RegkeyEffectiveRightsBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'hive': 
            obj_ = EntityObjectRegistryHiveType.factory()
            obj_.build(child_)
            self.set_hive(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        super(regkeyeffectiverights_object, self).buildChildren(child_, nodeName_)
# end class regkeyeffectiverights_object


class regkeyeffectiverights_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, hive=None, key=None, trustee_name=None, standard_delete=None, standard_read_control=None, standard_write_dac=None, standard_write_owner=None, standard_synchronize=None, access_system_security=None, generic_read=None, generic_write=None, generic_execute=None, generic_all=None, key_query_value=None, key_set_value=None, key_create_sub_key=None, key_enumerate_sub_keys=None, key_notify=None, key_create_link=None, key_wow64_64key=None, key_wow64_32key=None, key_wow64_res=None):
        super(regkeyeffectiverights_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.hive = hive
        self.key = key
        self.trustee_name = trustee_name
        self.standard_delete = standard_delete
        self.standard_read_control = standard_read_control
        self.standard_write_dac = standard_write_dac
        self.standard_write_owner = standard_write_owner
        self.standard_synchronize = standard_synchronize
        self.access_system_security = access_system_security
        self.generic_read = generic_read
        self.generic_write = generic_write
        self.generic_execute = generic_execute
        self.generic_all = generic_all
        self.key_query_value = key_query_value
        self.key_set_value = key_set_value
        self.key_create_sub_key = key_create_sub_key
        self.key_enumerate_sub_keys = key_enumerate_sub_keys
        self.key_notify = key_notify
        self.key_create_link = key_create_link
        self.key_wow64_64key = key_wow64_64key
        self.key_wow64_32key = key_wow64_32key
        self.key_wow64_res = key_wow64_res
    def factory(*args_, **kwargs_):
        if regkeyeffectiverights_state.subclass:
            return regkeyeffectiverights_state.subclass(*args_, **kwargs_)
        else:
            return regkeyeffectiverights_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hive(self): return self.hive
    def set_hive(self, hive): self.hive = hive
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def validate_key(self, value):
        # validate type key
        pass
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def get_standard_delete(self): return self.standard_delete
    def set_standard_delete(self, standard_delete): self.standard_delete = standard_delete
    def validate_standard_delete(self, value):
        # validate type standard_delete
        pass
    def get_standard_read_control(self): return self.standard_read_control
    def set_standard_read_control(self, standard_read_control): self.standard_read_control = standard_read_control
    def validate_standard_read_control(self, value):
        # validate type standard_read_control
        pass
    def get_standard_write_dac(self): return self.standard_write_dac
    def set_standard_write_dac(self, standard_write_dac): self.standard_write_dac = standard_write_dac
    def validate_standard_write_dac(self, value):
        # validate type standard_write_dac
        pass
    def get_standard_write_owner(self): return self.standard_write_owner
    def set_standard_write_owner(self, standard_write_owner): self.standard_write_owner = standard_write_owner
    def validate_standard_write_owner(self, value):
        # validate type standard_write_owner
        pass
    def get_standard_synchronize(self): return self.standard_synchronize
    def set_standard_synchronize(self, standard_synchronize): self.standard_synchronize = standard_synchronize
    def validate_standard_synchronize(self, value):
        # validate type standard_synchronize
        pass
    def get_access_system_security(self): return self.access_system_security
    def set_access_system_security(self, access_system_security): self.access_system_security = access_system_security
    def validate_access_system_security(self, value):
        # validate type access_system_security
        pass
    def get_generic_read(self): return self.generic_read
    def set_generic_read(self, generic_read): self.generic_read = generic_read
    def validate_generic_read(self, value):
        # validate type generic_read
        pass
    def get_generic_write(self): return self.generic_write
    def set_generic_write(self, generic_write): self.generic_write = generic_write
    def validate_generic_write(self, value):
        # validate type generic_write
        pass
    def get_generic_execute(self): return self.generic_execute
    def set_generic_execute(self, generic_execute): self.generic_execute = generic_execute
    def validate_generic_execute(self, value):
        # validate type generic_execute
        pass
    def get_generic_all(self): return self.generic_all
    def set_generic_all(self, generic_all): self.generic_all = generic_all
    def validate_generic_all(self, value):
        # validate type generic_all
        pass
    def get_key_query_value(self): return self.key_query_value
    def set_key_query_value(self, key_query_value): self.key_query_value = key_query_value
    def validate_key_query_value(self, value):
        # validate type key_query_value
        pass
    def get_key_set_value(self): return self.key_set_value
    def set_key_set_value(self, key_set_value): self.key_set_value = key_set_value
    def validate_key_set_value(self, value):
        # validate type key_set_value
        pass
    def get_key_create_sub_key(self): return self.key_create_sub_key
    def set_key_create_sub_key(self, key_create_sub_key): self.key_create_sub_key = key_create_sub_key
    def validate_key_create_sub_key(self, value):
        # validate type key_create_sub_key
        pass
    def get_key_enumerate_sub_keys(self): return self.key_enumerate_sub_keys
    def set_key_enumerate_sub_keys(self, key_enumerate_sub_keys): self.key_enumerate_sub_keys = key_enumerate_sub_keys
    def validate_key_enumerate_sub_keys(self, value):
        # validate type key_enumerate_sub_keys
        pass
    def get_key_notify(self): return self.key_notify
    def set_key_notify(self, key_notify): self.key_notify = key_notify
    def validate_key_notify(self, value):
        # validate type key_notify
        pass
    def get_key_create_link(self): return self.key_create_link
    def set_key_create_link(self, key_create_link): self.key_create_link = key_create_link
    def validate_key_create_link(self, value):
        # validate type key_create_link
        pass
    def get_key_wow64_64key(self): return self.key_wow64_64key
    def set_key_wow64_64key(self, key_wow64_64key): self.key_wow64_64key = key_wow64_64key
    def validate_key_wow64_64key(self, value):
        # validate type key_wow64_64key
        pass
    def get_key_wow64_32key(self): return self.key_wow64_32key
    def set_key_wow64_32key(self, key_wow64_32key): self.key_wow64_32key = key_wow64_32key
    def validate_key_wow64_32key(self, value):
        # validate type key_wow64_32key
        pass
    def get_key_wow64_res(self): return self.key_wow64_res
    def set_key_wow64_res(self, key_wow64_res): self.key_wow64_res = key_wow64_res
    def validate_key_wow64_res(self, value):
        # validate type key_wow64_res
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="regkeyeffectiverights_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights_state'):
        super(regkeyeffectiverights_state, self).exportAttributes(outfile, level, namespace_, name_='regkeyeffectiverights_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='regkeyeffectiverights_state'):
        super(regkeyeffectiverights_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.hive:
            self.hive.export(outfile, level, namespace_, name_='hive')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('<%skey>%s</%skey>\n' % (namespace_, self.format_string(quote_xml(self.key).encode(ExternalEncoding), input_name='key'), namespace_))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
        if self.standard_delete:
            self.standard_delete.export(outfile, level, namespace_, name_='standard_delete')
        if self.standard_read_control:
            self.standard_read_control.export(outfile, level, namespace_, name_='standard_read_control')
        if self.standard_write_dac:
            self.standard_write_dac.export(outfile, level, namespace_, name_='standard_write_dac')
        if self.standard_write_owner:
            self.standard_write_owner.export(outfile, level, namespace_, name_='standard_write_owner')
        if self.standard_synchronize:
            self.standard_synchronize.export(outfile, level, namespace_, name_='standard_synchronize')
        if self.access_system_security:
            self.access_system_security.export(outfile, level, namespace_, name_='access_system_security')
        if self.generic_read:
            self.generic_read.export(outfile, level, namespace_, name_='generic_read')
        if self.generic_write:
            self.generic_write.export(outfile, level, namespace_, name_='generic_write')
        if self.generic_execute:
            self.generic_execute.export(outfile, level, namespace_, name_='generic_execute')
        if self.generic_all:
            self.generic_all.export(outfile, level, namespace_, name_='generic_all')
        if self.key_query_value:
            self.key_query_value.export(outfile, level, namespace_, name_='key_query_value')
        if self.key_set_value:
            self.key_set_value.export(outfile, level, namespace_, name_='key_set_value')
        if self.key_create_sub_key:
            self.key_create_sub_key.export(outfile, level, namespace_, name_='key_create_sub_key')
        if self.key_enumerate_sub_keys:
            self.key_enumerate_sub_keys.export(outfile, level, namespace_, name_='key_enumerate_sub_keys')
        if self.key_notify:
            self.key_notify.export(outfile, level, namespace_, name_='key_notify')
        if self.key_create_link:
            self.key_create_link.export(outfile, level, namespace_, name_='key_create_link')
        if self.key_wow64_64key:
            self.key_wow64_64key.export(outfile, level, namespace_, name_='key_wow64_64key')
        if self.key_wow64_32key:
            self.key_wow64_32key.export(outfile, level, namespace_, name_='key_wow64_32key')
        if self.key_wow64_res:
            self.key_wow64_res.export(outfile, level, namespace_, name_='key_wow64_res')
    def hasContent_(self):
        if (
            self.hive is not None or
            self.key is not None or
            self.trustee_name is not None or
            self.standard_delete is not None or
            self.standard_read_control is not None or
            self.standard_write_dac is not None or
            self.standard_write_owner is not None or
            self.standard_synchronize is not None or
            self.access_system_security is not None or
            self.generic_read is not None or
            self.generic_write is not None or
            self.generic_execute is not None or
            self.generic_all is not None or
            self.key_query_value is not None or
            self.key_set_value is not None or
            self.key_create_sub_key is not None or
            self.key_enumerate_sub_keys is not None or
            self.key_notify is not None or
            self.key_create_link is not None or
            self.key_wow64_64key is not None or
            self.key_wow64_32key is not None or
            self.key_wow64_res is not None or
            super(regkeyeffectiverights_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='regkeyeffectiverights_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(regkeyeffectiverights_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(regkeyeffectiverights_state, self).exportLiteralChildren(outfile, level, name_)
        if self.hive is not None:
            showIndent(outfile, level)
            outfile.write('hive=model_.EntityStateRegistryHiveType(\n')
            self.hive.exportLiteral(outfile, level, name_='hive')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key is not None:
            showIndent(outfile, level)
            outfile.write('key=%s,\n' % quote_python(self.key).encode(ExternalEncoding))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
        if self.standard_delete is not None:
            showIndent(outfile, level)
            outfile.write('standard_delete=model_.EntityStateBoolType(\n')
            self.standard_delete.exportLiteral(outfile, level, name_='standard_delete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_read_control is not None:
            showIndent(outfile, level)
            outfile.write('standard_read_control=model_.EntityStateBoolType(\n')
            self.standard_read_control.exportLiteral(outfile, level, name_='standard_read_control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_dac is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_dac=model_.EntityStateBoolType(\n')
            self.standard_write_dac.exportLiteral(outfile, level, name_='standard_write_dac')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_owner is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_owner=model_.EntityStateBoolType(\n')
            self.standard_write_owner.exportLiteral(outfile, level, name_='standard_write_owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_synchronize is not None:
            showIndent(outfile, level)
            outfile.write('standard_synchronize=model_.EntityStateBoolType(\n')
            self.standard_synchronize.exportLiteral(outfile, level, name_='standard_synchronize')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_system_security is not None:
            showIndent(outfile, level)
            outfile.write('access_system_security=model_.EntityStateBoolType(\n')
            self.access_system_security.exportLiteral(outfile, level, name_='access_system_security')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_read is not None:
            showIndent(outfile, level)
            outfile.write('generic_read=model_.EntityStateBoolType(\n')
            self.generic_read.exportLiteral(outfile, level, name_='generic_read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_write is not None:
            showIndent(outfile, level)
            outfile.write('generic_write=model_.EntityStateBoolType(\n')
            self.generic_write.exportLiteral(outfile, level, name_='generic_write')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_execute is not None:
            showIndent(outfile, level)
            outfile.write('generic_execute=model_.EntityStateBoolType(\n')
            self.generic_execute.exportLiteral(outfile, level, name_='generic_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_all is not None:
            showIndent(outfile, level)
            outfile.write('generic_all=model_.EntityStateBoolType(\n')
            self.generic_all.exportLiteral(outfile, level, name_='generic_all')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_query_value is not None:
            showIndent(outfile, level)
            outfile.write('key_query_value=model_.EntityStateBoolType(\n')
            self.key_query_value.exportLiteral(outfile, level, name_='key_query_value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_set_value is not None:
            showIndent(outfile, level)
            outfile.write('key_set_value=model_.EntityStateBoolType(\n')
            self.key_set_value.exportLiteral(outfile, level, name_='key_set_value')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_create_sub_key is not None:
            showIndent(outfile, level)
            outfile.write('key_create_sub_key=model_.EntityStateBoolType(\n')
            self.key_create_sub_key.exportLiteral(outfile, level, name_='key_create_sub_key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_enumerate_sub_keys is not None:
            showIndent(outfile, level)
            outfile.write('key_enumerate_sub_keys=model_.EntityStateBoolType(\n')
            self.key_enumerate_sub_keys.exportLiteral(outfile, level, name_='key_enumerate_sub_keys')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_notify is not None:
            showIndent(outfile, level)
            outfile.write('key_notify=model_.EntityStateBoolType(\n')
            self.key_notify.exportLiteral(outfile, level, name_='key_notify')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_create_link is not None:
            showIndent(outfile, level)
            outfile.write('key_create_link=model_.EntityStateBoolType(\n')
            self.key_create_link.exportLiteral(outfile, level, name_='key_create_link')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_64key is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_64key=model_.EntityStateBoolType(\n')
            self.key_wow64_64key.exportLiteral(outfile, level, name_='key_wow64_64key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_32key is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_32key=model_.EntityStateBoolType(\n')
            self.key_wow64_32key.exportLiteral(outfile, level, name_='key_wow64_32key')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.key_wow64_res is not None:
            showIndent(outfile, level)
            outfile.write('key_wow64_res=model_.EntityStateBoolType(\n')
            self.key_wow64_res.exportLiteral(outfile, level, name_='key_wow64_res')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(regkeyeffectiverights_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'hive': 
            obj_ = EntityStateRegistryHiveType.factory()
            obj_.build(child_)
            self.set_hive(obj_)
        elif nodeName_ == 'key':
            key_ = child_.text
            self.key = key_
            self.validate_key(self.key)    # validate type key
        elif nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        elif nodeName_ == 'standard_delete': 
            obj_ = None
            self.set_standard_delete(obj_)
            self.validate_standard_delete(self.standard_delete)    # validate type standard_delete
        elif nodeName_ == 'standard_read_control': 
            obj_ = None
            self.set_standard_read_control(obj_)
            self.validate_standard_read_control(self.standard_read_control)    # validate type standard_read_control
        elif nodeName_ == 'standard_write_dac': 
            obj_ = None
            self.set_standard_write_dac(obj_)
            self.validate_standard_write_dac(self.standard_write_dac)    # validate type standard_write_dac
        elif nodeName_ == 'standard_write_owner': 
            obj_ = None
            self.set_standard_write_owner(obj_)
            self.validate_standard_write_owner(self.standard_write_owner)    # validate type standard_write_owner
        elif nodeName_ == 'standard_synchronize': 
            obj_ = None
            self.set_standard_synchronize(obj_)
            self.validate_standard_synchronize(self.standard_synchronize)    # validate type standard_synchronize
        elif nodeName_ == 'access_system_security': 
            obj_ = None
            self.set_access_system_security(obj_)
            self.validate_access_system_security(self.access_system_security)    # validate type access_system_security
        elif nodeName_ == 'generic_read': 
            obj_ = None
            self.set_generic_read(obj_)
            self.validate_generic_read(self.generic_read)    # validate type generic_read
        elif nodeName_ == 'generic_write': 
            obj_ = None
            self.set_generic_write(obj_)
            self.validate_generic_write(self.generic_write)    # validate type generic_write
        elif nodeName_ == 'generic_execute': 
            obj_ = None
            self.set_generic_execute(obj_)
            self.validate_generic_execute(self.generic_execute)    # validate type generic_execute
        elif nodeName_ == 'generic_all': 
            obj_ = None
            self.set_generic_all(obj_)
            self.validate_generic_all(self.generic_all)    # validate type generic_all
        elif nodeName_ == 'key_query_value': 
            obj_ = None
            self.set_key_query_value(obj_)
            self.validate_key_query_value(self.key_query_value)    # validate type key_query_value
        elif nodeName_ == 'key_set_value': 
            obj_ = None
            self.set_key_set_value(obj_)
            self.validate_key_set_value(self.key_set_value)    # validate type key_set_value
        elif nodeName_ == 'key_create_sub_key': 
            obj_ = None
            self.set_key_create_sub_key(obj_)
            self.validate_key_create_sub_key(self.key_create_sub_key)    # validate type key_create_sub_key
        elif nodeName_ == 'key_enumerate_sub_keys': 
            obj_ = None
            self.set_key_enumerate_sub_keys(obj_)
            self.validate_key_enumerate_sub_keys(self.key_enumerate_sub_keys)    # validate type key_enumerate_sub_keys
        elif nodeName_ == 'key_notify': 
            obj_ = None
            self.set_key_notify(obj_)
            self.validate_key_notify(self.key_notify)    # validate type key_notify
        elif nodeName_ == 'key_create_link': 
            obj_ = None
            self.set_key_create_link(obj_)
            self.validate_key_create_link(self.key_create_link)    # validate type key_create_link
        elif nodeName_ == 'key_wow64_64key': 
            obj_ = None
            self.set_key_wow64_64key(obj_)
            self.validate_key_wow64_64key(self.key_wow64_64key)    # validate type key_wow64_64key
        elif nodeName_ == 'key_wow64_32key': 
            obj_ = None
            self.set_key_wow64_32key(obj_)
            self.validate_key_wow64_32key(self.key_wow64_32key)    # validate type key_wow64_32key
        elif nodeName_ == 'key_wow64_res': 
            obj_ = None
            self.set_key_wow64_res(obj_)
            self.validate_key_wow64_res(self.key_wow64_res)    # validate type key_wow64_res
        super(regkeyeffectiverights_state, self).buildChildren(child_, nodeName_)
# end class regkeyeffectiverights_state


class RegkeyEffectiveRightsBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, resolve_group=False, recurse_direction='none', max_depth=-1, include_group=True, valueOf_=None):
        self.resolve_group = _cast(bool, resolve_group)
        self.recurse_direction = _cast(None, recurse_direction)
        self.max_depth = _cast(int, max_depth)
        self.include_group = _cast(bool, include_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RegkeyEffectiveRightsBehaviors.subclass:
            return RegkeyEffectiveRightsBehaviors.subclass(*args_, **kwargs_)
        else:
            return RegkeyEffectiveRightsBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_recurse_direction(self): return self.recurse_direction
    def set_recurse_direction(self, recurse_direction): self.recurse_direction = recurse_direction
    def get_max_depth(self): return self.max_depth
    def set_max_depth(self, max_depth): self.max_depth = max_depth
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='RegkeyEffectiveRightsBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='RegkeyEffectiveRightsBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='RegkeyEffectiveRightsBehaviors'):
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
        if self.recurse_direction is not None:
            outfile.write(' recurse_direction=%s' % (self.format_string(quote_attrib(self.recurse_direction).encode(ExternalEncoding), input_name='recurse_direction'), ))
        if self.max_depth is not None:
            outfile.write(' max_depth="%s"' % self.format_integer(self.max_depth, input_name='max_depth'))
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='RegkeyEffectiveRightsBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='RegkeyEffectiveRightsBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
        if self.recurse_direction is not None:
            showIndent(outfile, level)
            outfile.write('recurse_direction = "%s",\n' % (self.recurse_direction,))
        if self.max_depth is not None:
            showIndent(outfile, level)
            outfile.write('max_depth = %d,\n' % (self.max_depth,))
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('recurse_direction')
        if value is not None:
            self.recurse_direction = value
        value = attrs.get('max_depth')
        if value is not None:
            try:
                self.max_depth = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class RegkeyEffectiveRightsBehaviors


class serviceeffectiverights_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(serviceeffectiverights_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if serviceeffectiverights_test.subclass:
            return serviceeffectiverights_test.subclass(*args_, **kwargs_)
        else:
            return serviceeffectiverights_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='serviceeffectiverights_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='serviceeffectiverights_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="serviceeffectiverights_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='serviceeffectiverights_test'):
        super(serviceeffectiverights_test, self).exportAttributes(outfile, level, namespace_, name_='serviceeffectiverights_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='serviceeffectiverights_test'):
        super(serviceeffectiverights_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(serviceeffectiverights_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='serviceeffectiverights_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(serviceeffectiverights_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(serviceeffectiverights_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(serviceeffectiverights_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(serviceeffectiverights_test, self).buildChildren(child_, nodeName_)
# end class serviceeffectiverights_test


class serviceeffectiverights_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, service_name=None, trustee_sid=None):
        super(serviceeffectiverights_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.service_name = service_name
        self.trustee_sid = trustee_sid
    def factory(*args_, **kwargs_):
        if serviceeffectiverights_object.subclass:
            return serviceeffectiverights_object.subclass(*args_, **kwargs_)
        else:
            return serviceeffectiverights_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_service_name(self): return self.service_name
    def set_service_name(self, service_name): self.service_name = service_name
    def validate_service_name(self, value):
        # validate type service_name
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='serviceeffectiverights_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='serviceeffectiverights_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="serviceeffectiverights_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='serviceeffectiverights_object'):
        super(serviceeffectiverights_object, self).exportAttributes(outfile, level, namespace_, name_='serviceeffectiverights_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='serviceeffectiverights_object'):
        super(serviceeffectiverights_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.service_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sservice_name>%s</%sservice_name>\n' % (namespace_, self.format_string(quote_xml(self.service_name).encode(ExternalEncoding), input_name='service_name'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.service_name is not None or
            self.trustee_sid is not None or
            super(serviceeffectiverights_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='serviceeffectiverights_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(serviceeffectiverights_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(serviceeffectiverights_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service_name is not None:
            showIndent(outfile, level)
            outfile.write('service_name=%s,\n' % quote_python(self.service_name).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(serviceeffectiverights_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'service_name':
            service_name_ = child_.text
            self.service_name = service_name_
            self.validate_service_name(self.service_name)    # validate type service_name
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        super(serviceeffectiverights_object, self).buildChildren(child_, nodeName_)
# end class serviceeffectiverights_object


class serviceeffectiverights_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, service_name=None, trustee_sid=None, standard_delete=None, standard_read_control=None, standard_write_dac=None, standard_write_owner=None, generic_read=None, generic_write=None, generic_execute=None, service_query_conf=None, service_change_conf=None, service_query_stat=None, service_enum_dependents=None, service_start=None, service_stop=None, service_pause=None, service_interrogate=None, service_user_defined=None):
        super(serviceeffectiverights_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.service_name = service_name
        self.trustee_sid = trustee_sid
        self.standard_delete = standard_delete
        self.standard_read_control = standard_read_control
        self.standard_write_dac = standard_write_dac
        self.standard_write_owner = standard_write_owner
        self.generic_read = generic_read
        self.generic_write = generic_write
        self.generic_execute = generic_execute
        self.service_query_conf = service_query_conf
        self.service_change_conf = service_change_conf
        self.service_query_stat = service_query_stat
        self.service_enum_dependents = service_enum_dependents
        self.service_start = service_start
        self.service_stop = service_stop
        self.service_pause = service_pause
        self.service_interrogate = service_interrogate
        self.service_user_defined = service_user_defined
    def factory(*args_, **kwargs_):
        if serviceeffectiverights_state.subclass:
            return serviceeffectiverights_state.subclass(*args_, **kwargs_)
        else:
            return serviceeffectiverights_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service_name(self): return self.service_name
    def set_service_name(self, service_name): self.service_name = service_name
    def validate_service_name(self, value):
        # validate type service_name
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def get_standard_delete(self): return self.standard_delete
    def set_standard_delete(self, standard_delete): self.standard_delete = standard_delete
    def validate_standard_delete(self, value):
        # validate type standard_delete
        pass
    def get_standard_read_control(self): return self.standard_read_control
    def set_standard_read_control(self, standard_read_control): self.standard_read_control = standard_read_control
    def validate_standard_read_control(self, value):
        # validate type standard_read_control
        pass
    def get_standard_write_dac(self): return self.standard_write_dac
    def set_standard_write_dac(self, standard_write_dac): self.standard_write_dac = standard_write_dac
    def validate_standard_write_dac(self, value):
        # validate type standard_write_dac
        pass
    def get_standard_write_owner(self): return self.standard_write_owner
    def set_standard_write_owner(self, standard_write_owner): self.standard_write_owner = standard_write_owner
    def validate_standard_write_owner(self, value):
        # validate type standard_write_owner
        pass
    def get_generic_read(self): return self.generic_read
    def set_generic_read(self, generic_read): self.generic_read = generic_read
    def validate_generic_read(self, value):
        # validate type generic_read
        pass
    def get_generic_write(self): return self.generic_write
    def set_generic_write(self, generic_write): self.generic_write = generic_write
    def validate_generic_write(self, value):
        # validate type generic_write
        pass
    def get_generic_execute(self): return self.generic_execute
    def set_generic_execute(self, generic_execute): self.generic_execute = generic_execute
    def validate_generic_execute(self, value):
        # validate type generic_execute
        pass
    def get_service_query_conf(self): return self.service_query_conf
    def set_service_query_conf(self, service_query_conf): self.service_query_conf = service_query_conf
    def validate_service_query_conf(self, value):
        # validate type service_query_conf
        pass
    def get_service_change_conf(self): return self.service_change_conf
    def set_service_change_conf(self, service_change_conf): self.service_change_conf = service_change_conf
    def validate_service_change_conf(self, value):
        # validate type service_change_conf
        pass
    def get_service_query_stat(self): return self.service_query_stat
    def set_service_query_stat(self, service_query_stat): self.service_query_stat = service_query_stat
    def validate_service_query_stat(self, value):
        # validate type service_query_stat
        pass
    def get_service_enum_dependents(self): return self.service_enum_dependents
    def set_service_enum_dependents(self, service_enum_dependents): self.service_enum_dependents = service_enum_dependents
    def validate_service_enum_dependents(self, value):
        # validate type service_enum_dependents
        pass
    def get_service_start(self): return self.service_start
    def set_service_start(self, service_start): self.service_start = service_start
    def validate_service_start(self, value):
        # validate type service_start
        pass
    def get_service_stop(self): return self.service_stop
    def set_service_stop(self, service_stop): self.service_stop = service_stop
    def validate_service_stop(self, value):
        # validate type service_stop
        pass
    def get_service_pause(self): return self.service_pause
    def set_service_pause(self, service_pause): self.service_pause = service_pause
    def validate_service_pause(self, value):
        # validate type service_pause
        pass
    def get_service_interrogate(self): return self.service_interrogate
    def set_service_interrogate(self, service_interrogate): self.service_interrogate = service_interrogate
    def validate_service_interrogate(self, value):
        # validate type service_interrogate
        pass
    def get_service_user_defined(self): return self.service_user_defined
    def set_service_user_defined(self, service_user_defined): self.service_user_defined = service_user_defined
    def validate_service_user_defined(self, value):
        # validate type service_user_defined
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='serviceeffectiverights_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='serviceeffectiverights_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="serviceeffectiverights_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='serviceeffectiverights_state'):
        super(serviceeffectiverights_state, self).exportAttributes(outfile, level, namespace_, name_='serviceeffectiverights_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='serviceeffectiverights_state'):
        super(serviceeffectiverights_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.service_name is not None:
            showIndent(outfile, level)
            outfile.write('<%sservice_name>%s</%sservice_name>\n' % (namespace_, self.format_string(quote_xml(self.service_name).encode(ExternalEncoding), input_name='service_name'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
        if self.standard_delete:
            self.standard_delete.export(outfile, level, namespace_, name_='standard_delete')
        if self.standard_read_control:
            self.standard_read_control.export(outfile, level, namespace_, name_='standard_read_control')
        if self.standard_write_dac:
            self.standard_write_dac.export(outfile, level, namespace_, name_='standard_write_dac')
        if self.standard_write_owner:
            self.standard_write_owner.export(outfile, level, namespace_, name_='standard_write_owner')
        if self.generic_read:
            self.generic_read.export(outfile, level, namespace_, name_='generic_read')
        if self.generic_write:
            self.generic_write.export(outfile, level, namespace_, name_='generic_write')
        if self.generic_execute:
            self.generic_execute.export(outfile, level, namespace_, name_='generic_execute')
        if self.service_query_conf:
            self.service_query_conf.export(outfile, level, namespace_, name_='service_query_conf')
        if self.service_change_conf:
            self.service_change_conf.export(outfile, level, namespace_, name_='service_change_conf')
        if self.service_query_stat:
            self.service_query_stat.export(outfile, level, namespace_, name_='service_query_stat')
        if self.service_enum_dependents:
            self.service_enum_dependents.export(outfile, level, namespace_, name_='service_enum_dependents')
        if self.service_start:
            self.service_start.export(outfile, level, namespace_, name_='service_start')
        if self.service_stop:
            self.service_stop.export(outfile, level, namespace_, name_='service_stop')
        if self.service_pause:
            self.service_pause.export(outfile, level, namespace_, name_='service_pause')
        if self.service_interrogate:
            self.service_interrogate.export(outfile, level, namespace_, name_='service_interrogate')
        if self.service_user_defined:
            self.service_user_defined.export(outfile, level, namespace_, name_='service_user_defined')
    def hasContent_(self):
        if (
            self.service_name is not None or
            self.trustee_sid is not None or
            self.standard_delete is not None or
            self.standard_read_control is not None or
            self.standard_write_dac is not None or
            self.standard_write_owner is not None or
            self.generic_read is not None or
            self.generic_write is not None or
            self.generic_execute is not None or
            self.service_query_conf is not None or
            self.service_change_conf is not None or
            self.service_query_stat is not None or
            self.service_enum_dependents is not None or
            self.service_start is not None or
            self.service_stop is not None or
            self.service_pause is not None or
            self.service_interrogate is not None or
            self.service_user_defined is not None or
            super(serviceeffectiverights_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='serviceeffectiverights_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(serviceeffectiverights_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(serviceeffectiverights_state, self).exportLiteralChildren(outfile, level, name_)
        if self.service_name is not None:
            showIndent(outfile, level)
            outfile.write('service_name=%s,\n' % quote_python(self.service_name).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
        if self.standard_delete is not None:
            showIndent(outfile, level)
            outfile.write('standard_delete=model_.EntityStateBoolType(\n')
            self.standard_delete.exportLiteral(outfile, level, name_='standard_delete')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_read_control is not None:
            showIndent(outfile, level)
            outfile.write('standard_read_control=model_.EntityStateBoolType(\n')
            self.standard_read_control.exportLiteral(outfile, level, name_='standard_read_control')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_dac is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_dac=model_.EntityStateBoolType(\n')
            self.standard_write_dac.exportLiteral(outfile, level, name_='standard_write_dac')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.standard_write_owner is not None:
            showIndent(outfile, level)
            outfile.write('standard_write_owner=model_.EntityStateBoolType(\n')
            self.standard_write_owner.exportLiteral(outfile, level, name_='standard_write_owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_read is not None:
            showIndent(outfile, level)
            outfile.write('generic_read=model_.EntityStateBoolType(\n')
            self.generic_read.exportLiteral(outfile, level, name_='generic_read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_write is not None:
            showIndent(outfile, level)
            outfile.write('generic_write=model_.EntityStateBoolType(\n')
            self.generic_write.exportLiteral(outfile, level, name_='generic_write')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.generic_execute is not None:
            showIndent(outfile, level)
            outfile.write('generic_execute=model_.EntityStateBoolType(\n')
            self.generic_execute.exportLiteral(outfile, level, name_='generic_execute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service_query_conf is not None:
            showIndent(outfile, level)
            outfile.write('service_query_conf=model_.EntityStateBoolType(\n')
            self.service_query_conf.exportLiteral(outfile, level, name_='service_query_conf')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service_change_conf is not None:
            showIndent(outfile, level)
            outfile.write('service_change_conf=model_.EntityStateBoolType(\n')
            self.service_change_conf.exportLiteral(outfile, level, name_='service_change_conf')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service_query_stat is not None:
            showIndent(outfile, level)
            outfile.write('service_query_stat=model_.EntityStateBoolType(\n')
            self.service_query_stat.exportLiteral(outfile, level, name_='service_query_stat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service_enum_dependents is not None:
            showIndent(outfile, level)
            outfile.write('service_enum_dependents=model_.EntityStateBoolType(\n')
            self.service_enum_dependents.exportLiteral(outfile, level, name_='service_enum_dependents')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service_start is not None:
            showIndent(outfile, level)
            outfile.write('service_start=model_.EntityStateBoolType(\n')
            self.service_start.exportLiteral(outfile, level, name_='service_start')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service_stop is not None:
            showIndent(outfile, level)
            outfile.write('service_stop=model_.EntityStateBoolType(\n')
            self.service_stop.exportLiteral(outfile, level, name_='service_stop')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service_pause is not None:
            showIndent(outfile, level)
            outfile.write('service_pause=model_.EntityStateBoolType(\n')
            self.service_pause.exportLiteral(outfile, level, name_='service_pause')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service_interrogate is not None:
            showIndent(outfile, level)
            outfile.write('service_interrogate=model_.EntityStateBoolType(\n')
            self.service_interrogate.exportLiteral(outfile, level, name_='service_interrogate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.service_user_defined is not None:
            showIndent(outfile, level)
            outfile.write('service_user_defined=model_.EntityStateBoolType(\n')
            self.service_user_defined.exportLiteral(outfile, level, name_='service_user_defined')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(serviceeffectiverights_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'service_name':
            service_name_ = child_.text
            self.service_name = service_name_
            self.validate_service_name(self.service_name)    # validate type service_name
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        elif nodeName_ == 'standard_delete': 
            obj_ = None
            self.set_standard_delete(obj_)
            self.validate_standard_delete(self.standard_delete)    # validate type standard_delete
        elif nodeName_ == 'standard_read_control': 
            obj_ = None
            self.set_standard_read_control(obj_)
            self.validate_standard_read_control(self.standard_read_control)    # validate type standard_read_control
        elif nodeName_ == 'standard_write_dac': 
            obj_ = None
            self.set_standard_write_dac(obj_)
            self.validate_standard_write_dac(self.standard_write_dac)    # validate type standard_write_dac
        elif nodeName_ == 'standard_write_owner': 
            obj_ = None
            self.set_standard_write_owner(obj_)
            self.validate_standard_write_owner(self.standard_write_owner)    # validate type standard_write_owner
        elif nodeName_ == 'generic_read': 
            obj_ = None
            self.set_generic_read(obj_)
            self.validate_generic_read(self.generic_read)    # validate type generic_read
        elif nodeName_ == 'generic_write': 
            obj_ = None
            self.set_generic_write(obj_)
            self.validate_generic_write(self.generic_write)    # validate type generic_write
        elif nodeName_ == 'generic_execute': 
            obj_ = None
            self.set_generic_execute(obj_)
            self.validate_generic_execute(self.generic_execute)    # validate type generic_execute
        elif nodeName_ == 'service_query_conf': 
            obj_ = None
            self.set_service_query_conf(obj_)
            self.validate_service_query_conf(self.service_query_conf)    # validate type service_query_conf
        elif nodeName_ == 'service_change_conf': 
            obj_ = None
            self.set_service_change_conf(obj_)
            self.validate_service_change_conf(self.service_change_conf)    # validate type service_change_conf
        elif nodeName_ == 'service_query_stat': 
            obj_ = None
            self.set_service_query_stat(obj_)
            self.validate_service_query_stat(self.service_query_stat)    # validate type service_query_stat
        elif nodeName_ == 'service_enum_dependents': 
            obj_ = None
            self.set_service_enum_dependents(obj_)
            self.validate_service_enum_dependents(self.service_enum_dependents)    # validate type service_enum_dependents
        elif nodeName_ == 'service_start': 
            obj_ = None
            self.set_service_start(obj_)
            self.validate_service_start(self.service_start)    # validate type service_start
        elif nodeName_ == 'service_stop': 
            obj_ = None
            self.set_service_stop(obj_)
            self.validate_service_stop(self.service_stop)    # validate type service_stop
        elif nodeName_ == 'service_pause': 
            obj_ = None
            self.set_service_pause(obj_)
            self.validate_service_pause(self.service_pause)    # validate type service_pause
        elif nodeName_ == 'service_interrogate': 
            obj_ = None
            self.set_service_interrogate(obj_)
            self.validate_service_interrogate(self.service_interrogate)    # validate type service_interrogate
        elif nodeName_ == 'service_user_defined': 
            obj_ = None
            self.set_service_user_defined(obj_)
            self.validate_service_user_defined(self.service_user_defined)    # validate type service_user_defined
        super(serviceeffectiverights_state, self).buildChildren(child_, nodeName_)
# end class serviceeffectiverights_state


class sharedresource_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(sharedresource_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if sharedresource_test.subclass:
            return sharedresource_test.subclass(*args_, **kwargs_)
        else:
            return sharedresource_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='sharedresource_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sharedresource_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="sharedresource_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='sharedresource_test'):
        super(sharedresource_test, self).exportAttributes(outfile, level, namespace_, name_='sharedresource_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='sharedresource_test'):
        super(sharedresource_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(sharedresource_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sharedresource_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(sharedresource_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sharedresource_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(sharedresource_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(sharedresource_test, self).buildChildren(child_, nodeName_)
# end class sharedresource_test


class sharedresource_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, netname=None):
        super(sharedresource_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.netname = netname
    def factory(*args_, **kwargs_):
        if sharedresource_object.subclass:
            return sharedresource_object.subclass(*args_, **kwargs_)
        else:
            return sharedresource_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_netname(self): return self.netname
    def set_netname(self, netname): self.netname = netname
    def validate_netname(self, value):
        # validate type netname
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='sharedresource_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sharedresource_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="sharedresource_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='sharedresource_object'):
        super(sharedresource_object, self).exportAttributes(outfile, level, namespace_, name_='sharedresource_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='sharedresource_object'):
        super(sharedresource_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set', )
        if self.netname is not None:
            showIndent(outfile, level)
            outfile.write('<%snetname>%s</%snetname>\n' % (namespace_, self.format_string(quote_xml(self.netname).encode(ExternalEncoding), input_name='netname'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.netname is not None or
            super(sharedresource_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sharedresource_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(sharedresource_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sharedresource_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.netname is not None:
            showIndent(outfile, level)
            outfile.write('netname=%s,\n' % quote_python(self.netname).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(sharedresource_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'netname':
            netname_ = child_.text
            self.netname = netname_
            self.validate_netname(self.netname)    # validate type netname
        super(sharedresource_object, self).buildChildren(child_, nodeName_)
# end class sharedresource_object


class sharedresource_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, netname=None, shared_type=None, max_uses=None, current_uses=None, local_path=None, access_read_permission=None, access_write_permission=None, access_create_permission=None, access_exec_permission=None, access_delete_permission=None, access_atrib_permission=None, access_perm_permission=None, access_all_permission=None):
        super(sharedresource_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.netname = netname
        self.shared_type = shared_type
        self.max_uses = max_uses
        self.current_uses = current_uses
        self.local_path = local_path
        self.access_read_permission = access_read_permission
        self.access_write_permission = access_write_permission
        self.access_create_permission = access_create_permission
        self.access_exec_permission = access_exec_permission
        self.access_delete_permission = access_delete_permission
        self.access_atrib_permission = access_atrib_permission
        self.access_perm_permission = access_perm_permission
        self.access_all_permission = access_all_permission
    def factory(*args_, **kwargs_):
        if sharedresource_state.subclass:
            return sharedresource_state.subclass(*args_, **kwargs_)
        else:
            return sharedresource_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_netname(self): return self.netname
    def set_netname(self, netname): self.netname = netname
    def validate_netname(self, value):
        # validate type netname
        pass
    def get_shared_type(self): return self.shared_type
    def set_shared_type(self, shared_type): self.shared_type = shared_type
    def get_max_uses(self): return self.max_uses
    def set_max_uses(self, max_uses): self.max_uses = max_uses
    def validate_max_uses(self, value):
        # validate type max_uses
        pass
    def get_current_uses(self): return self.current_uses
    def set_current_uses(self, current_uses): self.current_uses = current_uses
    def validate_current_uses(self, value):
        # validate type current_uses
        pass
    def get_local_path(self): return self.local_path
    def set_local_path(self, local_path): self.local_path = local_path
    def validate_local_path(self, value):
        # validate type local_path
        pass
    def get_access_read_permission(self): return self.access_read_permission
    def set_access_read_permission(self, access_read_permission): self.access_read_permission = access_read_permission
    def validate_access_read_permission(self, value):
        # validate type access_read_permission
        pass
    def get_access_write_permission(self): return self.access_write_permission
    def set_access_write_permission(self, access_write_permission): self.access_write_permission = access_write_permission
    def validate_access_write_permission(self, value):
        # validate type access_write_permission
        pass
    def get_access_create_permission(self): return self.access_create_permission
    def set_access_create_permission(self, access_create_permission): self.access_create_permission = access_create_permission
    def validate_access_create_permission(self, value):
        # validate type access_create_permission
        pass
    def get_access_exec_permission(self): return self.access_exec_permission
    def set_access_exec_permission(self, access_exec_permission): self.access_exec_permission = access_exec_permission
    def validate_access_exec_permission(self, value):
        # validate type access_exec_permission
        pass
    def get_access_delete_permission(self): return self.access_delete_permission
    def set_access_delete_permission(self, access_delete_permission): self.access_delete_permission = access_delete_permission
    def validate_access_delete_permission(self, value):
        # validate type access_delete_permission
        pass
    def get_access_atrib_permission(self): return self.access_atrib_permission
    def set_access_atrib_permission(self, access_atrib_permission): self.access_atrib_permission = access_atrib_permission
    def validate_access_atrib_permission(self, value):
        # validate type access_atrib_permission
        pass
    def get_access_perm_permission(self): return self.access_perm_permission
    def set_access_perm_permission(self, access_perm_permission): self.access_perm_permission = access_perm_permission
    def validate_access_perm_permission(self, value):
        # validate type access_perm_permission
        pass
    def get_access_all_permission(self): return self.access_all_permission
    def set_access_all_permission(self, access_all_permission): self.access_all_permission = access_all_permission
    def validate_access_all_permission(self, value):
        # validate type access_all_permission
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='sharedresource_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sharedresource_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="sharedresource_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='sharedresource_state'):
        super(sharedresource_state, self).exportAttributes(outfile, level, namespace_, name_='sharedresource_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='sharedresource_state'):
        super(sharedresource_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.netname is not None:
            showIndent(outfile, level)
            outfile.write('<%snetname>%s</%snetname>\n' % (namespace_, self.format_string(quote_xml(self.netname).encode(ExternalEncoding), input_name='netname'), namespace_))
        if self.shared_type:
            self.shared_type.export(outfile, level, namespace_, name_='shared_type')
        if self.max_uses:
            self.max_uses.export(outfile, level, namespace_, name_='max_uses')
        if self.current_uses:
            self.current_uses.export(outfile, level, namespace_, name_='current_uses')
        if self.local_path is not None:
            showIndent(outfile, level)
            outfile.write('<%slocal_path>%s</%slocal_path>\n' % (namespace_, self.format_string(quote_xml(self.local_path).encode(ExternalEncoding), input_name='local_path'), namespace_))
        if self.access_read_permission:
            self.access_read_permission.export(outfile, level, namespace_, name_='access_read_permission')
        if self.access_write_permission:
            self.access_write_permission.export(outfile, level, namespace_, name_='access_write_permission')
        if self.access_create_permission:
            self.access_create_permission.export(outfile, level, namespace_, name_='access_create_permission')
        if self.access_exec_permission:
            self.access_exec_permission.export(outfile, level, namespace_, name_='access_exec_permission')
        if self.access_delete_permission:
            self.access_delete_permission.export(outfile, level, namespace_, name_='access_delete_permission')
        if self.access_atrib_permission:
            self.access_atrib_permission.export(outfile, level, namespace_, name_='access_atrib_permission')
        if self.access_perm_permission:
            self.access_perm_permission.export(outfile, level, namespace_, name_='access_perm_permission')
        if self.access_all_permission:
            self.access_all_permission.export(outfile, level, namespace_, name_='access_all_permission')
    def hasContent_(self):
        if (
            self.netname is not None or
            self.shared_type is not None or
            self.max_uses is not None or
            self.current_uses is not None or
            self.local_path is not None or
            self.access_read_permission is not None or
            self.access_write_permission is not None or
            self.access_create_permission is not None or
            self.access_exec_permission is not None or
            self.access_delete_permission is not None or
            self.access_atrib_permission is not None or
            self.access_perm_permission is not None or
            self.access_all_permission is not None or
            super(sharedresource_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sharedresource_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(sharedresource_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sharedresource_state, self).exportLiteralChildren(outfile, level, name_)
        if self.netname is not None:
            showIndent(outfile, level)
            outfile.write('netname=%s,\n' % quote_python(self.netname).encode(ExternalEncoding))
        if self.shared_type is not None:
            showIndent(outfile, level)
            outfile.write('shared_type=model_.EntityStateSharedResourceTypeType(\n')
            self.shared_type.exportLiteral(outfile, level, name_='shared_type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.max_uses is not None:
            showIndent(outfile, level)
            outfile.write('max_uses=model_.EntityStateIntType(\n')
            self.max_uses.exportLiteral(outfile, level, name_='max_uses')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.current_uses is not None:
            showIndent(outfile, level)
            outfile.write('current_uses=model_.EntityStateIntType(\n')
            self.current_uses.exportLiteral(outfile, level, name_='current_uses')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.local_path is not None:
            showIndent(outfile, level)
            outfile.write('local_path=%s,\n' % quote_python(self.local_path).encode(ExternalEncoding))
        if self.access_read_permission is not None:
            showIndent(outfile, level)
            outfile.write('access_read_permission=model_.EntityStateBoolType(\n')
            self.access_read_permission.exportLiteral(outfile, level, name_='access_read_permission')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_write_permission is not None:
            showIndent(outfile, level)
            outfile.write('access_write_permission=model_.EntityStateBoolType(\n')
            self.access_write_permission.exportLiteral(outfile, level, name_='access_write_permission')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_create_permission is not None:
            showIndent(outfile, level)
            outfile.write('access_create_permission=model_.EntityStateBoolType(\n')
            self.access_create_permission.exportLiteral(outfile, level, name_='access_create_permission')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_exec_permission is not None:
            showIndent(outfile, level)
            outfile.write('access_exec_permission=model_.EntityStateBoolType(\n')
            self.access_exec_permission.exportLiteral(outfile, level, name_='access_exec_permission')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_delete_permission is not None:
            showIndent(outfile, level)
            outfile.write('access_delete_permission=model_.EntityStateBoolType(\n')
            self.access_delete_permission.exportLiteral(outfile, level, name_='access_delete_permission')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_atrib_permission is not None:
            showIndent(outfile, level)
            outfile.write('access_atrib_permission=model_.EntityStateBoolType(\n')
            self.access_atrib_permission.exportLiteral(outfile, level, name_='access_atrib_permission')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_perm_permission is not None:
            showIndent(outfile, level)
            outfile.write('access_perm_permission=model_.EntityStateBoolType(\n')
            self.access_perm_permission.exportLiteral(outfile, level, name_='access_perm_permission')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.access_all_permission is not None:
            showIndent(outfile, level)
            outfile.write('access_all_permission=model_.EntityStateBoolType(\n')
            self.access_all_permission.exportLiteral(outfile, level, name_='access_all_permission')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(sharedresource_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'netname':
            netname_ = child_.text
            self.netname = netname_
            self.validate_netname(self.netname)    # validate type netname
        elif nodeName_ == 'shared_type': 
            obj_ = EntityStateSharedResourceTypeType.factory()
            obj_.build(child_)
            self.set_shared_type(obj_)
        elif nodeName_ == 'max_uses': 
            obj_ = None
            self.set_max_uses(obj_)
            self.validate_max_uses(self.max_uses)    # validate type max_uses
        elif nodeName_ == 'current_uses': 
            obj_ = None
            self.set_current_uses(obj_)
            self.validate_current_uses(self.current_uses)    # validate type current_uses
        elif nodeName_ == 'local_path':
            local_path_ = child_.text
            self.local_path = local_path_
            self.validate_local_path(self.local_path)    # validate type local_path
        elif nodeName_ == 'access_read_permission': 
            obj_ = None
            self.set_access_read_permission(obj_)
            self.validate_access_read_permission(self.access_read_permission)    # validate type access_read_permission
        elif nodeName_ == 'access_write_permission': 
            obj_ = None
            self.set_access_write_permission(obj_)
            self.validate_access_write_permission(self.access_write_permission)    # validate type access_write_permission
        elif nodeName_ == 'access_create_permission': 
            obj_ = None
            self.set_access_create_permission(obj_)
            self.validate_access_create_permission(self.access_create_permission)    # validate type access_create_permission
        elif nodeName_ == 'access_exec_permission': 
            obj_ = None
            self.set_access_exec_permission(obj_)
            self.validate_access_exec_permission(self.access_exec_permission)    # validate type access_exec_permission
        elif nodeName_ == 'access_delete_permission': 
            obj_ = None
            self.set_access_delete_permission(obj_)
            self.validate_access_delete_permission(self.access_delete_permission)    # validate type access_delete_permission
        elif nodeName_ == 'access_atrib_permission': 
            obj_ = None
            self.set_access_atrib_permission(obj_)
            self.validate_access_atrib_permission(self.access_atrib_permission)    # validate type access_atrib_permission
        elif nodeName_ == 'access_perm_permission': 
            obj_ = None
            self.set_access_perm_permission(obj_)
            self.validate_access_perm_permission(self.access_perm_permission)    # validate type access_perm_permission
        elif nodeName_ == 'access_all_permission': 
            obj_ = None
            self.set_access_all_permission(obj_)
            self.validate_access_all_permission(self.access_all_permission)    # validate type access_all_permission
        super(sharedresource_state, self).buildChildren(child_, nodeName_)
# end class sharedresource_state


class sid_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(sid_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if sid_test.subclass:
            return sid_test.subclass(*args_, **kwargs_)
        else:
            return sid_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='sid_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sid_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="sid_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='sid_test'):
        super(sid_test, self).exportAttributes(outfile, level, namespace_, name_='sid_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='sid_test'):
        super(sid_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(sid_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sid_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(sid_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sid_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(sid_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(sid_test, self).buildChildren(child_, nodeName_)
# end class sid_test


class sid_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, trustee_name=None):
        super(sid_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.trustee_name = trustee_name
    def factory(*args_, **kwargs_):
        if sid_object.subclass:
            return sid_object.subclass(*args_, **kwargs_)
        else:
            return sid_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='sid_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sid_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="sid_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='sid_object'):
        super(sid_object, self).exportAttributes(outfile, level, namespace_, name_='sid_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='sid_object'):
        super(sid_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set', )
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.trustee_name is not None or
            super(sid_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sid_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(sid_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sid_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.SidBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(sid_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = SidBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        super(sid_object, self).buildChildren(child_, nodeName_)
# end class sid_object


class sid_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, trustee_name=None, trustee_sid=None, trustee_domain=None):
        super(sid_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.trustee_name = trustee_name
        self.trustee_sid = trustee_sid
        self.trustee_domain = trustee_domain
    def factory(*args_, **kwargs_):
        if sid_state.subclass:
            return sid_state.subclass(*args_, **kwargs_)
        else:
            return sid_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def get_trustee_domain(self): return self.trustee_domain
    def set_trustee_domain(self, trustee_domain): self.trustee_domain = trustee_domain
    def validate_trustee_domain(self, value):
        # validate type trustee_domain
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='sid_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sid_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="sid_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='sid_state'):
        super(sid_state, self).exportAttributes(outfile, level, namespace_, name_='sid_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='sid_state'):
        super(sid_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
        if self.trustee_domain is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_domain>%s</%strustee_domain>\n' % (namespace_, self.format_string(quote_xml(self.trustee_domain).encode(ExternalEncoding), input_name='trustee_domain'), namespace_))
    def hasContent_(self):
        if (
            self.trustee_name is not None or
            self.trustee_sid is not None or
            self.trustee_domain is not None or
            super(sid_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sid_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(sid_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sid_state, self).exportLiteralChildren(outfile, level, name_)
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
        if self.trustee_domain is not None:
            showIndent(outfile, level)
            outfile.write('trustee_domain=%s,\n' % quote_python(self.trustee_domain).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(sid_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        elif nodeName_ == 'trustee_domain':
            trustee_domain_ = child_.text
            self.trustee_domain = trustee_domain_
            self.validate_trustee_domain(self.trustee_domain)    # validate type trustee_domain
        super(sid_state, self).buildChildren(child_, nodeName_)
# end class sid_state


class SidBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, include_group=True, resolve_group=False, valueOf_=None):
        self.include_group = _cast(bool, include_group)
        self.resolve_group = _cast(bool, resolve_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SidBehaviors.subclass:
            return SidBehaviors.subclass(*args_, **kwargs_)
        else:
            return SidBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='SidBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SidBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SidBehaviors'):
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='SidBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SidBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class SidBehaviors


class sid_sid_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(sid_sid_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if sid_sid_test.subclass:
            return sid_sid_test.subclass(*args_, **kwargs_)
        else:
            return sid_sid_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='sid_sid_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sid_sid_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="sid_sid_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='sid_sid_test'):
        super(sid_sid_test, self).exportAttributes(outfile, level, namespace_, name_='sid_sid_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='sid_sid_test'):
        super(sid_sid_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(sid_sid_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sid_sid_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(sid_sid_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sid_sid_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(sid_sid_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(sid_sid_test, self).buildChildren(child_, nodeName_)
# end class sid_sid_test


class sid_sid_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, trustee_sid=None):
        super(sid_sid_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.trustee_sid = trustee_sid
    def factory(*args_, **kwargs_):
        if sid_sid_object.subclass:
            return sid_sid_object.subclass(*args_, **kwargs_)
        else:
            return sid_sid_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='sid_sid_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sid_sid_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="sid_sid_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='sid_sid_object'):
        super(sid_sid_object, self).exportAttributes(outfile, level, namespace_, name_='sid_sid_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='sid_sid_object'):
        super(sid_sid_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set', )
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.trustee_sid is not None or
            super(sid_sid_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sid_sid_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(sid_sid_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sid_sid_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.SidSidBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(sid_sid_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = SidSidBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        super(sid_sid_object, self).buildChildren(child_, nodeName_)
# end class sid_sid_object


class sid_sid_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, trustee_sid=None, trustee_name=None, trustee_domain=None):
        super(sid_sid_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.trustee_sid = trustee_sid
        self.trustee_name = trustee_name
        self.trustee_domain = trustee_domain
    def factory(*args_, **kwargs_):
        if sid_sid_state.subclass:
            return sid_sid_state.subclass(*args_, **kwargs_)
        else:
            return sid_sid_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_trustee_sid(self): return self.trustee_sid
    def set_trustee_sid(self, trustee_sid): self.trustee_sid = trustee_sid
    def validate_trustee_sid(self, value):
        # validate type trustee_sid
        pass
    def get_trustee_name(self): return self.trustee_name
    def set_trustee_name(self, trustee_name): self.trustee_name = trustee_name
    def validate_trustee_name(self, value):
        # validate type trustee_name
        pass
    def get_trustee_domain(self): return self.trustee_domain
    def set_trustee_domain(self, trustee_domain): self.trustee_domain = trustee_domain
    def validate_trustee_domain(self, value):
        # validate type trustee_domain
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='sid_sid_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='sid_sid_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="sid_sid_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='sid_sid_state'):
        super(sid_sid_state, self).exportAttributes(outfile, level, namespace_, name_='sid_sid_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='sid_sid_state'):
        super(sid_sid_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_sid>%s</%strustee_sid>\n' % (namespace_, self.format_string(quote_xml(self.trustee_sid).encode(ExternalEncoding), input_name='trustee_sid'), namespace_))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_name>%s</%strustee_name>\n' % (namespace_, self.format_string(quote_xml(self.trustee_name).encode(ExternalEncoding), input_name='trustee_name'), namespace_))
        if self.trustee_domain is not None:
            showIndent(outfile, level)
            outfile.write('<%strustee_domain>%s</%strustee_domain>\n' % (namespace_, self.format_string(quote_xml(self.trustee_domain).encode(ExternalEncoding), input_name='trustee_domain'), namespace_))
    def hasContent_(self):
        if (
            self.trustee_sid is not None or
            self.trustee_name is not None or
            self.trustee_domain is not None or
            super(sid_sid_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sid_sid_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(sid_sid_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(sid_sid_state, self).exportLiteralChildren(outfile, level, name_)
        if self.trustee_sid is not None:
            showIndent(outfile, level)
            outfile.write('trustee_sid=%s,\n' % quote_python(self.trustee_sid).encode(ExternalEncoding))
        if self.trustee_name is not None:
            showIndent(outfile, level)
            outfile.write('trustee_name=%s,\n' % quote_python(self.trustee_name).encode(ExternalEncoding))
        if self.trustee_domain is not None:
            showIndent(outfile, level)
            outfile.write('trustee_domain=%s,\n' % quote_python(self.trustee_domain).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(sid_sid_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'trustee_sid':
            trustee_sid_ = child_.text
            self.trustee_sid = trustee_sid_
            self.validate_trustee_sid(self.trustee_sid)    # validate type trustee_sid
        elif nodeName_ == 'trustee_name':
            trustee_name_ = child_.text
            self.trustee_name = trustee_name_
            self.validate_trustee_name(self.trustee_name)    # validate type trustee_name
        elif nodeName_ == 'trustee_domain':
            trustee_domain_ = child_.text
            self.trustee_domain = trustee_domain_
            self.validate_trustee_domain(self.trustee_domain)    # validate type trustee_domain
        super(sid_sid_state, self).buildChildren(child_, nodeName_)
# end class sid_sid_state


class SidSidBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, include_group=True, resolve_group=False, valueOf_=None):
        self.include_group = _cast(bool, include_group)
        self.resolve_group = _cast(bool, resolve_group)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SidSidBehaviors.subclass:
            return SidSidBehaviors.subclass(*args_, **kwargs_)
        else:
            return SidSidBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_include_group(self): return self.include_group
    def set_include_group(self, include_group): self.include_group = include_group
    def get_resolve_group(self): return self.resolve_group
    def set_resolve_group(self, resolve_group): self.resolve_group = resolve_group
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='SidSidBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='SidSidBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='SidSidBehaviors'):
        if self.include_group is not None:
            outfile.write(' include_group="%s"' % self.format_boolean(str_lower(str(self.include_group)), input_name='include_group'))
        if self.resolve_group is not None:
            outfile.write(' resolve_group="%s"' % self.format_boolean(str_lower(str(self.resolve_group)), input_name='resolve_group'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='SidSidBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SidSidBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.include_group is not None:
            showIndent(outfile, level)
            outfile.write('include_group = %s,\n' % (self.include_group,))
        if self.resolve_group is not None:
            showIndent(outfile, level)
            outfile.write('resolve_group = %s,\n' % (self.resolve_group,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('include_group')
        if value is not None:
            if value in ('true', '1'):
                self.include_group = True
            elif value in ('false', '0'):
                self.include_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = attrs.get('resolve_group')
        if value is not None:
            if value in ('true', '1'):
                self.resolve_group = True
            elif value in ('false', '0'):
                self.resolve_group = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class SidSidBehaviors


class uac_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(uac_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if uac_test.subclass:
            return uac_test.subclass(*args_, **kwargs_)
        else:
            return uac_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='uac_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='uac_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="uac_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='uac_test'):
        super(uac_test, self).exportAttributes(outfile, level, namespace_, name_='uac_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='uac_test'):
        super(uac_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(uac_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='uac_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(uac_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(uac_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(uac_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(uac_test, self).buildChildren(child_, nodeName_)
# end class uac_test


class uac_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None):
        super(uac_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        pass
    def factory(*args_, **kwargs_):
        if uac_object.subclass:
            return uac_object.subclass(*args_, **kwargs_)
        else:
            return uac_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='win-def:', name_='uac_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='uac_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="uac_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='uac_object'):
        super(uac_object, self).exportAttributes(outfile, level, namespace_, name_='uac_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='uac_object'):
        super(uac_object, self).exportChildren(outfile, level, namespace_, name_)
    def hasContent_(self):
        if (
            super(uac_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='uac_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(uac_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(uac_object, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(uac_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        super(uac_object, self).buildChildren(child_, nodeName_)
        pass
# end class uac_object


class uac_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, admin_approval_mode=None, elevation_prompt_admin=None, elevation_prompt_standard=None, detect_installations=None, elevate_signed_executables=None, elevate_uiaccess=None, run_admins_aam=None, secure_desktop=None, virtualize_write_failures=None):
        super(uac_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.admin_approval_mode = admin_approval_mode
        self.elevation_prompt_admin = elevation_prompt_admin
        self.elevation_prompt_standard = elevation_prompt_standard
        self.detect_installations = detect_installations
        self.elevate_signed_executables = elevate_signed_executables
        self.elevate_uiaccess = elevate_uiaccess
        self.run_admins_aam = run_admins_aam
        self.secure_desktop = secure_desktop
        self.virtualize_write_failures = virtualize_write_failures
    def factory(*args_, **kwargs_):
        if uac_state.subclass:
            return uac_state.subclass(*args_, **kwargs_)
        else:
            return uac_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_admin_approval_mode(self): return self.admin_approval_mode
    def set_admin_approval_mode(self, admin_approval_mode): self.admin_approval_mode = admin_approval_mode
    def validate_admin_approval_mode(self, value):
        # validate type admin_approval_mode
        pass
    def get_elevation_prompt_admin(self): return self.elevation_prompt_admin
    def set_elevation_prompt_admin(self, elevation_prompt_admin): self.elevation_prompt_admin = elevation_prompt_admin
    def validate_elevation_prompt_admin(self, value):
        # validate type elevation_prompt_admin
        pass
    def get_elevation_prompt_standard(self): return self.elevation_prompt_standard
    def set_elevation_prompt_standard(self, elevation_prompt_standard): self.elevation_prompt_standard = elevation_prompt_standard
    def validate_elevation_prompt_standard(self, value):
        # validate type elevation_prompt_standard
        pass
    def get_detect_installations(self): return self.detect_installations
    def set_detect_installations(self, detect_installations): self.detect_installations = detect_installations
    def validate_detect_installations(self, value):
        # validate type detect_installations
        pass
    def get_elevate_signed_executables(self): return self.elevate_signed_executables
    def set_elevate_signed_executables(self, elevate_signed_executables): self.elevate_signed_executables = elevate_signed_executables
    def validate_elevate_signed_executables(self, value):
        # validate type elevate_signed_executables
        pass
    def get_elevate_uiaccess(self): return self.elevate_uiaccess
    def set_elevate_uiaccess(self, elevate_uiaccess): self.elevate_uiaccess = elevate_uiaccess
    def validate_elevate_uiaccess(self, value):
        # validate type elevate_uiaccess
        pass
    def get_run_admins_aam(self): return self.run_admins_aam
    def set_run_admins_aam(self, run_admins_aam): self.run_admins_aam = run_admins_aam
    def validate_run_admins_aam(self, value):
        # validate type run_admins_aam
        pass
    def get_secure_desktop(self): return self.secure_desktop
    def set_secure_desktop(self, secure_desktop): self.secure_desktop = secure_desktop
    def validate_secure_desktop(self, value):
        # validate type secure_desktop
        pass
    def get_virtualize_write_failures(self): return self.virtualize_write_failures
    def set_virtualize_write_failures(self, virtualize_write_failures): self.virtualize_write_failures = virtualize_write_failures
    def validate_virtualize_write_failures(self, value):
        # validate type virtualize_write_failures
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='uac_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='uac_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="uac_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='uac_state'):
        super(uac_state, self).exportAttributes(outfile, level, namespace_, name_='uac_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='uac_state'):
        super(uac_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.admin_approval_mode:
            self.admin_approval_mode.export(outfile, level, namespace_, name_='admin_approval_mode')
        if self.elevation_prompt_admin is not None:
            showIndent(outfile, level)
            outfile.write('<%selevation_prompt_admin>%s</%selevation_prompt_admin>\n' % (namespace_, self.format_string(quote_xml(self.elevation_prompt_admin).encode(ExternalEncoding), input_name='elevation_prompt_admin'), namespace_))
        if self.elevation_prompt_standard is not None:
            showIndent(outfile, level)
            outfile.write('<%selevation_prompt_standard>%s</%selevation_prompt_standard>\n' % (namespace_, self.format_string(quote_xml(self.elevation_prompt_standard).encode(ExternalEncoding), input_name='elevation_prompt_standard'), namespace_))
        if self.detect_installations:
            self.detect_installations.export(outfile, level, namespace_, name_='detect_installations')
        if self.elevate_signed_executables:
            self.elevate_signed_executables.export(outfile, level, namespace_, name_='elevate_signed_executables')
        if self.elevate_uiaccess:
            self.elevate_uiaccess.export(outfile, level, namespace_, name_='elevate_uiaccess')
        if self.run_admins_aam:
            self.run_admins_aam.export(outfile, level, namespace_, name_='run_admins_aam')
        if self.secure_desktop:
            self.secure_desktop.export(outfile, level, namespace_, name_='secure_desktop')
        if self.virtualize_write_failures:
            self.virtualize_write_failures.export(outfile, level, namespace_, name_='virtualize_write_failures')
    def hasContent_(self):
        if (
            self.admin_approval_mode is not None or
            self.elevation_prompt_admin is not None or
            self.elevation_prompt_standard is not None or
            self.detect_installations is not None or
            self.elevate_signed_executables is not None or
            self.elevate_uiaccess is not None or
            self.run_admins_aam is not None or
            self.secure_desktop is not None or
            self.virtualize_write_failures is not None or
            super(uac_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='uac_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(uac_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(uac_state, self).exportLiteralChildren(outfile, level, name_)
        if self.admin_approval_mode is not None:
            showIndent(outfile, level)
            outfile.write('admin_approval_mode=model_.EntityStateBoolType(\n')
            self.admin_approval_mode.exportLiteral(outfile, level, name_='admin_approval_mode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.elevation_prompt_admin is not None:
            showIndent(outfile, level)
            outfile.write('elevation_prompt_admin=%s,\n' % quote_python(self.elevation_prompt_admin).encode(ExternalEncoding))
        if self.elevation_prompt_standard is not None:
            showIndent(outfile, level)
            outfile.write('elevation_prompt_standard=%s,\n' % quote_python(self.elevation_prompt_standard).encode(ExternalEncoding))
        if self.detect_installations is not None:
            showIndent(outfile, level)
            outfile.write('detect_installations=model_.EntityStateBoolType(\n')
            self.detect_installations.exportLiteral(outfile, level, name_='detect_installations')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.elevate_signed_executables is not None:
            showIndent(outfile, level)
            outfile.write('elevate_signed_executables=model_.EntityStateBoolType(\n')
            self.elevate_signed_executables.exportLiteral(outfile, level, name_='elevate_signed_executables')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.elevate_uiaccess is not None:
            showIndent(outfile, level)
            outfile.write('elevate_uiaccess=model_.EntityStateBoolType(\n')
            self.elevate_uiaccess.exportLiteral(outfile, level, name_='elevate_uiaccess')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.run_admins_aam is not None:
            showIndent(outfile, level)
            outfile.write('run_admins_aam=model_.EntityStateBoolType(\n')
            self.run_admins_aam.exportLiteral(outfile, level, name_='run_admins_aam')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secure_desktop is not None:
            showIndent(outfile, level)
            outfile.write('secure_desktop=model_.EntityStateBoolType(\n')
            self.secure_desktop.exportLiteral(outfile, level, name_='secure_desktop')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.virtualize_write_failures is not None:
            showIndent(outfile, level)
            outfile.write('virtualize_write_failures=model_.EntityStateBoolType(\n')
            self.virtualize_write_failures.exportLiteral(outfile, level, name_='virtualize_write_failures')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(uac_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'admin_approval_mode': 
            obj_ = None
            self.set_admin_approval_mode(obj_)
            self.validate_admin_approval_mode(self.admin_approval_mode)    # validate type admin_approval_mode
        elif nodeName_ == 'elevation_prompt_admin':
            elevation_prompt_admin_ = child_.text
            self.elevation_prompt_admin = elevation_prompt_admin_
            self.validate_elevation_prompt_admin(self.elevation_prompt_admin)    # validate type elevation_prompt_admin
        elif nodeName_ == 'elevation_prompt_standard':
            elevation_prompt_standard_ = child_.text
            self.elevation_prompt_standard = elevation_prompt_standard_
            self.validate_elevation_prompt_standard(self.elevation_prompt_standard)    # validate type elevation_prompt_standard
        elif nodeName_ == 'detect_installations': 
            obj_ = None
            self.set_detect_installations(obj_)
            self.validate_detect_installations(self.detect_installations)    # validate type detect_installations
        elif nodeName_ == 'elevate_signed_executables': 
            obj_ = None
            self.set_elevate_signed_executables(obj_)
            self.validate_elevate_signed_executables(self.elevate_signed_executables)    # validate type elevate_signed_executables
        elif nodeName_ == 'elevate_uiaccess': 
            obj_ = None
            self.set_elevate_uiaccess(obj_)
            self.validate_elevate_uiaccess(self.elevate_uiaccess)    # validate type elevate_uiaccess
        elif nodeName_ == 'run_admins_aam': 
            obj_ = None
            self.set_run_admins_aam(obj_)
            self.validate_run_admins_aam(self.run_admins_aam)    # validate type run_admins_aam
        elif nodeName_ == 'secure_desktop': 
            obj_ = None
            self.set_secure_desktop(obj_)
            self.validate_secure_desktop(self.secure_desktop)    # validate type secure_desktop
        elif nodeName_ == 'virtualize_write_failures': 
            obj_ = None
            self.set_virtualize_write_failures(obj_)
            self.validate_virtualize_write_failures(self.virtualize_write_failures)    # validate type virtualize_write_failures
        super(uac_state, self).buildChildren(child_, nodeName_)
# end class uac_state


class user_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(user_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if user_test.subclass:
            return user_test.subclass(*args_, **kwargs_)
        else:
            return user_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='user_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='user_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="user_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='user_test'):
        super(user_test, self).exportAttributes(outfile, level, namespace_, name_='user_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='user_test'):
        super(user_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(user_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='user_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(user_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(user_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(user_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(user_test, self).buildChildren(child_, nodeName_)
# end class user_test


class user_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, user=None):
        super(user_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.user = user
    def factory(*args_, **kwargs_):
        if user_object.subclass:
            return user_object.subclass(*args_, **kwargs_)
        else:
            return user_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def validate_user(self, value):
        # validate type user
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='user_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='user_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="user_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='user_object'):
        super(user_object, self).exportAttributes(outfile, level, namespace_, name_='user_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='user_object'):
        super(user_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('<%suser>%s</%suser>\n' % (namespace_, self.format_string(quote_xml(self.user).encode(ExternalEncoding), input_name='user'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.user is not None or
            super(user_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='user_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(user_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(user_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user=%s,\n' % quote_python(self.user).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(user_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'user':
            user_ = child_.text
            self.user = user_
            self.validate_user(self.user)    # validate type user
        super(user_object, self).buildChildren(child_, nodeName_)
# end class user_object


class user_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, user=None, enabled=None, group=None):
        super(user_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.user = user
        self.enabled = enabled
        self.group = group
    def factory(*args_, **kwargs_):
        if user_state.subclass:
            return user_state.subclass(*args_, **kwargs_)
        else:
            return user_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def validate_user(self, value):
        # validate type user
        pass
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def validate_enabled(self, value):
        # validate type enabled
        pass
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def validate_group(self, value):
        # validate type group
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='user_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='user_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="user_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='user_state'):
        super(user_state, self).exportAttributes(outfile, level, namespace_, name_='user_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='user_state'):
        super(user_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('<%suser>%s</%suser>\n' % (namespace_, self.format_string(quote_xml(self.user).encode(ExternalEncoding), input_name='user'), namespace_))
        if self.enabled:
            self.enabled.export(outfile, level, namespace_, name_='enabled')
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.format_string(quote_xml(self.group).encode(ExternalEncoding), input_name='group'), namespace_))
    def hasContent_(self):
        if (
            self.user is not None or
            self.enabled is not None or
            self.group is not None or
            super(user_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='user_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(user_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(user_state, self).exportLiteralChildren(outfile, level, name_)
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user=%s,\n' % quote_python(self.user).encode(ExternalEncoding))
        if self.enabled is not None:
            showIndent(outfile, level)
            outfile.write('enabled=model_.EntityStateBoolType(\n')
            self.enabled.exportLiteral(outfile, level, name_='enabled')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('group=%s,\n' % quote_python(self.group).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(user_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'user':
            user_ = child_.text
            self.user = user_
            self.validate_user(self.user)    # validate type user
        elif nodeName_ == 'enabled': 
            obj_ = None
            self.set_enabled(obj_)
            self.validate_enabled(self.enabled)    # validate type enabled
        elif nodeName_ == 'group':
            group_ = child_.text
            self.group = group_
            self.validate_group(self.group)    # validate type group
        super(user_state, self).buildChildren(child_, nodeName_)
# end class user_state


class user_sid55_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(user_sid55_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if user_sid55_test.subclass:
            return user_sid55_test.subclass(*args_, **kwargs_)
        else:
            return user_sid55_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='user_sid55_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='user_sid55_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="user_sid55_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='user_sid55_test'):
        super(user_sid55_test, self).exportAttributes(outfile, level, namespace_, name_='user_sid55_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='user_sid55_test'):
        super(user_sid55_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(user_sid55_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='user_sid55_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(user_sid55_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(user_sid55_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(user_sid55_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(user_sid55_test, self).buildChildren(child_, nodeName_)
# end class user_sid55_test


class user_sid55_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, user_sid=None):
        super(user_sid55_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.user_sid = user_sid
    def factory(*args_, **kwargs_):
        if user_sid55_object.subclass:
            return user_sid55_object.subclass(*args_, **kwargs_)
        else:
            return user_sid55_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_user_sid(self): return self.user_sid
    def set_user_sid(self, user_sid): self.user_sid = user_sid
    def validate_user_sid(self, value):
        # validate type user_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='user_sid55_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='user_sid55_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="user_sid55_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='user_sid55_object'):
        super(user_sid55_object, self).exportAttributes(outfile, level, namespace_, name_='user_sid55_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='user_sid55_object'):
        super(user_sid55_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.user_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%suser_sid>%s</%suser_sid>\n' % (namespace_, self.format_string(quote_xml(self.user_sid).encode(ExternalEncoding), input_name='user_sid'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.user_sid is not None or
            super(user_sid55_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='user_sid55_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(user_sid55_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(user_sid55_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.user_sid is not None:
            showIndent(outfile, level)
            outfile.write('user_sid=%s,\n' % quote_python(self.user_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(user_sid55_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'user_sid':
            user_sid_ = child_.text
            self.user_sid = user_sid_
            self.validate_user_sid(self.user_sid)    # validate type user_sid
        super(user_sid55_object, self).buildChildren(child_, nodeName_)
# end class user_sid55_object


class user_sid55_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, user_sid=None, enabled=None, group_sid=None):
        super(user_sid55_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.user_sid = user_sid
        self.enabled = enabled
        self.group_sid = group_sid
    def factory(*args_, **kwargs_):
        if user_sid55_state.subclass:
            return user_sid55_state.subclass(*args_, **kwargs_)
        else:
            return user_sid55_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_user_sid(self): return self.user_sid
    def set_user_sid(self, user_sid): self.user_sid = user_sid
    def validate_user_sid(self, value):
        # validate type user_sid
        pass
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def validate_enabled(self, value):
        # validate type enabled
        pass
    def get_group_sid(self): return self.group_sid
    def set_group_sid(self, group_sid): self.group_sid = group_sid
    def validate_group_sid(self, value):
        # validate type group_sid
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='user_sid55_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='user_sid55_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="user_sid55_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='user_sid55_state'):
        super(user_sid55_state, self).exportAttributes(outfile, level, namespace_, name_='user_sid55_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='user_sid55_state'):
        super(user_sid55_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.user_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%suser_sid>%s</%suser_sid>\n' % (namespace_, self.format_string(quote_xml(self.user_sid).encode(ExternalEncoding), input_name='user_sid'), namespace_))
        if self.enabled:
            self.enabled.export(outfile, level, namespace_, name_='enabled')
        if self.group_sid is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroup_sid>%s</%sgroup_sid>\n' % (namespace_, self.format_string(quote_xml(self.group_sid).encode(ExternalEncoding), input_name='group_sid'), namespace_))
    def hasContent_(self):
        if (
            self.user_sid is not None or
            self.enabled is not None or
            self.group_sid is not None or
            super(user_sid55_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='user_sid55_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(user_sid55_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(user_sid55_state, self).exportLiteralChildren(outfile, level, name_)
        if self.user_sid is not None:
            showIndent(outfile, level)
            outfile.write('user_sid=%s,\n' % quote_python(self.user_sid).encode(ExternalEncoding))
        if self.enabled is not None:
            showIndent(outfile, level)
            outfile.write('enabled=model_.EntityStateBoolType(\n')
            self.enabled.exportLiteral(outfile, level, name_='enabled')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.group_sid is not None:
            showIndent(outfile, level)
            outfile.write('group_sid=%s,\n' % quote_python(self.group_sid).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(user_sid55_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'user_sid':
            user_sid_ = child_.text
            self.user_sid = user_sid_
            self.validate_user_sid(self.user_sid)    # validate type user_sid
        elif nodeName_ == 'enabled': 
            obj_ = None
            self.set_enabled(obj_)
            self.validate_enabled(self.enabled)    # validate type enabled
        elif nodeName_ == 'group_sid':
            group_sid_ = child_.text
            self.group_sid = group_sid_
            self.validate_group_sid(self.group_sid)    # validate type group_sid
        super(user_sid55_state, self).buildChildren(child_, nodeName_)
# end class user_sid55_state


class user_sid_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(user_sid_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if user_sid_test.subclass:
            return user_sid_test.subclass(*args_, **kwargs_)
        else:
            return user_sid_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='user_sid_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='user_sid_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="user_sid_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='user_sid_test'):
        super(user_sid_test, self).exportAttributes(outfile, level, namespace_, name_='user_sid_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='user_sid_test'):
        super(user_sid_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(user_sid_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='user_sid_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(user_sid_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(user_sid_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(user_sid_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(user_sid_test, self).buildChildren(child_, nodeName_)
# end class user_sid_test


class user_sid_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, user=None):
        super(user_sid_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.user = user
    def factory(*args_, **kwargs_):
        if user_sid_object.subclass:
            return user_sid_object.subclass(*args_, **kwargs_)
        else:
            return user_sid_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def validate_user(self, value):
        # validate type user
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='user_sid_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='user_sid_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="user_sid_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='user_sid_object'):
        super(user_sid_object, self).exportAttributes(outfile, level, namespace_, name_='user_sid_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='user_sid_object'):
        super(user_sid_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('<%suser>%s</%suser>\n' % (namespace_, self.format_string(quote_xml(self.user).encode(ExternalEncoding), input_name='user'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.user is not None or
            super(user_sid_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='user_sid_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(user_sid_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(user_sid_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user=%s,\n' % quote_python(self.user).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(user_sid_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'user':
            user_ = child_.text
            self.user = user_
            self.validate_user(self.user)    # validate type user
        super(user_sid_object, self).buildChildren(child_, nodeName_)
# end class user_sid_object


class user_sid_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, user=None, enabled=None, group=None):
        super(user_sid_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.user = user
        self.enabled = enabled
        self.group = group
    def factory(*args_, **kwargs_):
        if user_sid_state.subclass:
            return user_sid_state.subclass(*args_, **kwargs_)
        else:
            return user_sid_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def validate_user(self, value):
        # validate type user
        pass
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def validate_enabled(self, value):
        # validate type enabled
        pass
    def get_group(self): return self.group
    def set_group(self, group): self.group = group
    def validate_group(self, value):
        # validate type group
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='user_sid_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='user_sid_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="user_sid_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='user_sid_state'):
        super(user_sid_state, self).exportAttributes(outfile, level, namespace_, name_='user_sid_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='user_sid_state'):
        super(user_sid_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('<%suser>%s</%suser>\n' % (namespace_, self.format_string(quote_xml(self.user).encode(ExternalEncoding), input_name='user'), namespace_))
        if self.enabled:
            self.enabled.export(outfile, level, namespace_, name_='enabled')
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('<%sgroup>%s</%sgroup>\n' % (namespace_, self.format_string(quote_xml(self.group).encode(ExternalEncoding), input_name='group'), namespace_))
    def hasContent_(self):
        if (
            self.user is not None or
            self.enabled is not None or
            self.group is not None or
            super(user_sid_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='user_sid_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(user_sid_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(user_sid_state, self).exportLiteralChildren(outfile, level, name_)
        if self.user is not None:
            showIndent(outfile, level)
            outfile.write('user=%s,\n' % quote_python(self.user).encode(ExternalEncoding))
        if self.enabled is not None:
            showIndent(outfile, level)
            outfile.write('enabled=model_.EntityStateBoolType(\n')
            self.enabled.exportLiteral(outfile, level, name_='enabled')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.group is not None:
            showIndent(outfile, level)
            outfile.write('group=%s,\n' % quote_python(self.group).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(user_sid_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'user':
            user_ = child_.text
            self.user = user_
            self.validate_user(self.user)    # validate type user
        elif nodeName_ == 'enabled': 
            obj_ = None
            self.set_enabled(obj_)
            self.validate_enabled(self.enabled)    # validate type enabled
        elif nodeName_ == 'group':
            group_ = child_.text
            self.group = group_
            self.validate_group(self.group)    # validate type group
        super(user_sid_state, self).buildChildren(child_, nodeName_)
# end class user_sid_state


class volume_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(volume_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if volume_test.subclass:
            return volume_test.subclass(*args_, **kwargs_)
        else:
            return volume_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='volume_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='volume_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="volume_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='volume_test'):
        super(volume_test, self).exportAttributes(outfile, level, namespace_, name_='volume_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='volume_test'):
        super(volume_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(volume_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='volume_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(volume_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(volume_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(volume_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(volume_test, self).buildChildren(child_, nodeName_)
# end class volume_test


class volume_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, rootpath=None):
        super(volume_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.rootpath = rootpath
    def factory(*args_, **kwargs_):
        if volume_object.subclass:
            return volume_object.subclass(*args_, **kwargs_)
        else:
            return volume_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_rootpath(self): return self.rootpath
    def set_rootpath(self, rootpath): self.rootpath = rootpath
    def validate_rootpath(self, value):
        # validate type rootpath
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='volume_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='volume_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="volume_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='volume_object'):
        super(volume_object, self).exportAttributes(outfile, level, namespace_, name_='volume_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='volume_object'):
        super(volume_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.rootpath is not None:
            showIndent(outfile, level)
            outfile.write('<%srootpath>%s</%srootpath>\n' % (namespace_, self.format_string(quote_xml(self.rootpath).encode(ExternalEncoding), input_name='rootpath'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.rootpath is not None or
            super(volume_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='volume_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(volume_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(volume_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rootpath is not None:
            showIndent(outfile, level)
            outfile.write('rootpath=%s,\n' % quote_python(self.rootpath).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(volume_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'rootpath':
            rootpath_ = child_.text
            self.rootpath = rootpath_
            self.validate_rootpath(self.rootpath)    # validate type rootpath
        super(volume_object, self).buildChildren(child_, nodeName_)
# end class volume_object


class volume_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, rootpath=None, file_system=None, name=None, volume_max_component_length=None, serial_number=None, file_case_sensitive_search=None, file_case_preserved_names=None, file_unicode_on_disk=None, file_persistent_acls=None, file_file_compression=None, file_volume_quotas=None, file_supports_sparse_files=None, file_supports_reparse_points=None, file_supports_remote_storage=None, file_volume_is_compressed=None, file_supports_object_ids=None, file_supports_encryption=None, file_named_streams=None, file_read_only_volume=None):
        super(volume_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.rootpath = rootpath
        self.file_system = file_system
        self.name = name
        self.volume_max_component_length = volume_max_component_length
        self.serial_number = serial_number
        self.file_case_sensitive_search = file_case_sensitive_search
        self.file_case_preserved_names = file_case_preserved_names
        self.file_unicode_on_disk = file_unicode_on_disk
        self.file_persistent_acls = file_persistent_acls
        self.file_file_compression = file_file_compression
        self.file_volume_quotas = file_volume_quotas
        self.file_supports_sparse_files = file_supports_sparse_files
        self.file_supports_reparse_points = file_supports_reparse_points
        self.file_supports_remote_storage = file_supports_remote_storage
        self.file_volume_is_compressed = file_volume_is_compressed
        self.file_supports_object_ids = file_supports_object_ids
        self.file_supports_encryption = file_supports_encryption
        self.file_named_streams = file_named_streams
        self.file_read_only_volume = file_read_only_volume
    def factory(*args_, **kwargs_):
        if volume_state.subclass:
            return volume_state.subclass(*args_, **kwargs_)
        else:
            return volume_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rootpath(self): return self.rootpath
    def set_rootpath(self, rootpath): self.rootpath = rootpath
    def validate_rootpath(self, value):
        # validate type rootpath
        pass
    def get_file_system(self): return self.file_system
    def set_file_system(self, file_system): self.file_system = file_system
    def validate_file_system(self, value):
        # validate type file_system
        pass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_name(self, value):
        # validate type name
        pass
    def get_volume_max_component_length(self): return self.volume_max_component_length
    def set_volume_max_component_length(self, volume_max_component_length): self.volume_max_component_length = volume_max_component_length
    def validate_volume_max_component_length(self, value):
        # validate type volume_max_component_length
        pass
    def get_serial_number(self): return self.serial_number
    def set_serial_number(self, serial_number): self.serial_number = serial_number
    def validate_serial_number(self, value):
        # validate type serial_number
        pass
    def get_file_case_sensitive_search(self): return self.file_case_sensitive_search
    def set_file_case_sensitive_search(self, file_case_sensitive_search): self.file_case_sensitive_search = file_case_sensitive_search
    def validate_file_case_sensitive_search(self, value):
        # validate type file_case_sensitive_search
        pass
    def get_file_case_preserved_names(self): return self.file_case_preserved_names
    def set_file_case_preserved_names(self, file_case_preserved_names): self.file_case_preserved_names = file_case_preserved_names
    def validate_file_case_preserved_names(self, value):
        # validate type file_case_preserved_names
        pass
    def get_file_unicode_on_disk(self): return self.file_unicode_on_disk
    def set_file_unicode_on_disk(self, file_unicode_on_disk): self.file_unicode_on_disk = file_unicode_on_disk
    def validate_file_unicode_on_disk(self, value):
        # validate type file_unicode_on_disk
        pass
    def get_file_persistent_acls(self): return self.file_persistent_acls
    def set_file_persistent_acls(self, file_persistent_acls): self.file_persistent_acls = file_persistent_acls
    def validate_file_persistent_acls(self, value):
        # validate type file_persistent_acls
        pass
    def get_file_file_compression(self): return self.file_file_compression
    def set_file_file_compression(self, file_file_compression): self.file_file_compression = file_file_compression
    def validate_file_file_compression(self, value):
        # validate type file_file_compression
        pass
    def get_file_volume_quotas(self): return self.file_volume_quotas
    def set_file_volume_quotas(self, file_volume_quotas): self.file_volume_quotas = file_volume_quotas
    def validate_file_volume_quotas(self, value):
        # validate type file_volume_quotas
        pass
    def get_file_supports_sparse_files(self): return self.file_supports_sparse_files
    def set_file_supports_sparse_files(self, file_supports_sparse_files): self.file_supports_sparse_files = file_supports_sparse_files
    def validate_file_supports_sparse_files(self, value):
        # validate type file_supports_sparse_files
        pass
    def get_file_supports_reparse_points(self): return self.file_supports_reparse_points
    def set_file_supports_reparse_points(self, file_supports_reparse_points): self.file_supports_reparse_points = file_supports_reparse_points
    def validate_file_supports_reparse_points(self, value):
        # validate type file_supports_reparse_points
        pass
    def get_file_supports_remote_storage(self): return self.file_supports_remote_storage
    def set_file_supports_remote_storage(self, file_supports_remote_storage): self.file_supports_remote_storage = file_supports_remote_storage
    def validate_file_supports_remote_storage(self, value):
        # validate type file_supports_remote_storage
        pass
    def get_file_volume_is_compressed(self): return self.file_volume_is_compressed
    def set_file_volume_is_compressed(self, file_volume_is_compressed): self.file_volume_is_compressed = file_volume_is_compressed
    def validate_file_volume_is_compressed(self, value):
        # validate type file_volume_is_compressed
        pass
    def get_file_supports_object_ids(self): return self.file_supports_object_ids
    def set_file_supports_object_ids(self, file_supports_object_ids): self.file_supports_object_ids = file_supports_object_ids
    def validate_file_supports_object_ids(self, value):
        # validate type file_supports_object_ids
        pass
    def get_file_supports_encryption(self): return self.file_supports_encryption
    def set_file_supports_encryption(self, file_supports_encryption): self.file_supports_encryption = file_supports_encryption
    def validate_file_supports_encryption(self, value):
        # validate type file_supports_encryption
        pass
    def get_file_named_streams(self): return self.file_named_streams
    def set_file_named_streams(self, file_named_streams): self.file_named_streams = file_named_streams
    def validate_file_named_streams(self, value):
        # validate type file_named_streams
        pass
    def get_file_read_only_volume(self): return self.file_read_only_volume
    def set_file_read_only_volume(self, file_read_only_volume): self.file_read_only_volume = file_read_only_volume
    def validate_file_read_only_volume(self, value):
        # validate type file_read_only_volume
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='volume_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='volume_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="volume_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='volume_state'):
        super(volume_state, self).exportAttributes(outfile, level, namespace_, name_='volume_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='volume_state'):
        super(volume_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.rootpath is not None:
            showIndent(outfile, level)
            outfile.write('<%srootpath>%s</%srootpath>\n' % (namespace_, self.format_string(quote_xml(self.rootpath).encode(ExternalEncoding), input_name='rootpath'), namespace_))
        if self.file_system is not None:
            showIndent(outfile, level)
            outfile.write('<%sfile_system>%s</%sfile_system>\n' % (namespace_, self.format_string(quote_xml(self.file_system).encode(ExternalEncoding), input_name='file_system'), namespace_))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.volume_max_component_length:
            self.volume_max_component_length.export(outfile, level, namespace_, name_='volume_max_component_length')
        if self.serial_number:
            self.serial_number.export(outfile, level, namespace_, name_='serial_number')
        if self.file_case_sensitive_search:
            self.file_case_sensitive_search.export(outfile, level, namespace_, name_='file_case_sensitive_search')
        if self.file_case_preserved_names:
            self.file_case_preserved_names.export(outfile, level, namespace_, name_='file_case_preserved_names')
        if self.file_unicode_on_disk:
            self.file_unicode_on_disk.export(outfile, level, namespace_, name_='file_unicode_on_disk')
        if self.file_persistent_acls:
            self.file_persistent_acls.export(outfile, level, namespace_, name_='file_persistent_acls')
        if self.file_file_compression:
            self.file_file_compression.export(outfile, level, namespace_, name_='file_file_compression')
        if self.file_volume_quotas:
            self.file_volume_quotas.export(outfile, level, namespace_, name_='file_volume_quotas')
        if self.file_supports_sparse_files:
            self.file_supports_sparse_files.export(outfile, level, namespace_, name_='file_supports_sparse_files')
        if self.file_supports_reparse_points:
            self.file_supports_reparse_points.export(outfile, level, namespace_, name_='file_supports_reparse_points')
        if self.file_supports_remote_storage:
            self.file_supports_remote_storage.export(outfile, level, namespace_, name_='file_supports_remote_storage')
        if self.file_volume_is_compressed:
            self.file_volume_is_compressed.export(outfile, level, namespace_, name_='file_volume_is_compressed')
        if self.file_supports_object_ids:
            self.file_supports_object_ids.export(outfile, level, namespace_, name_='file_supports_object_ids')
        if self.file_supports_encryption:
            self.file_supports_encryption.export(outfile, level, namespace_, name_='file_supports_encryption')
        if self.file_named_streams:
            self.file_named_streams.export(outfile, level, namespace_, name_='file_named_streams')
        if self.file_read_only_volume:
            self.file_read_only_volume.export(outfile, level, namespace_, name_='file_read_only_volume')
    def hasContent_(self):
        if (
            self.rootpath is not None or
            self.file_system is not None or
            self.name is not None or
            self.volume_max_component_length is not None or
            self.serial_number is not None or
            self.file_case_sensitive_search is not None or
            self.file_case_preserved_names is not None or
            self.file_unicode_on_disk is not None or
            self.file_persistent_acls is not None or
            self.file_file_compression is not None or
            self.file_volume_quotas is not None or
            self.file_supports_sparse_files is not None or
            self.file_supports_reparse_points is not None or
            self.file_supports_remote_storage is not None or
            self.file_volume_is_compressed is not None or
            self.file_supports_object_ids is not None or
            self.file_supports_encryption is not None or
            self.file_named_streams is not None or
            self.file_read_only_volume is not None or
            super(volume_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='volume_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(volume_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(volume_state, self).exportLiteralChildren(outfile, level, name_)
        if self.rootpath is not None:
            showIndent(outfile, level)
            outfile.write('rootpath=%s,\n' % quote_python(self.rootpath).encode(ExternalEncoding))
        if self.file_system is not None:
            showIndent(outfile, level)
            outfile.write('file_system=%s,\n' % quote_python(self.file_system).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.volume_max_component_length is not None:
            showIndent(outfile, level)
            outfile.write('volume_max_component_length=model_.EntityStateIntType(\n')
            self.volume_max_component_length.exportLiteral(outfile, level, name_='volume_max_component_length')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serial_number is not None:
            showIndent(outfile, level)
            outfile.write('serial_number=model_.EntityStateIntType(\n')
            self.serial_number.exportLiteral(outfile, level, name_='serial_number')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_case_sensitive_search is not None:
            showIndent(outfile, level)
            outfile.write('file_case_sensitive_search=model_.EntityStateBoolType(\n')
            self.file_case_sensitive_search.exportLiteral(outfile, level, name_='file_case_sensitive_search')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_case_preserved_names is not None:
            showIndent(outfile, level)
            outfile.write('file_case_preserved_names=model_.EntityStateBoolType(\n')
            self.file_case_preserved_names.exportLiteral(outfile, level, name_='file_case_preserved_names')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_unicode_on_disk is not None:
            showIndent(outfile, level)
            outfile.write('file_unicode_on_disk=model_.EntityStateBoolType(\n')
            self.file_unicode_on_disk.exportLiteral(outfile, level, name_='file_unicode_on_disk')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_persistent_acls is not None:
            showIndent(outfile, level)
            outfile.write('file_persistent_acls=model_.EntityStateBoolType(\n')
            self.file_persistent_acls.exportLiteral(outfile, level, name_='file_persistent_acls')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_file_compression is not None:
            showIndent(outfile, level)
            outfile.write('file_file_compression=model_.EntityStateBoolType(\n')
            self.file_file_compression.exportLiteral(outfile, level, name_='file_file_compression')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_volume_quotas is not None:
            showIndent(outfile, level)
            outfile.write('file_volume_quotas=model_.EntityStateBoolType(\n')
            self.file_volume_quotas.exportLiteral(outfile, level, name_='file_volume_quotas')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_supports_sparse_files is not None:
            showIndent(outfile, level)
            outfile.write('file_supports_sparse_files=model_.EntityStateBoolType(\n')
            self.file_supports_sparse_files.exportLiteral(outfile, level, name_='file_supports_sparse_files')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_supports_reparse_points is not None:
            showIndent(outfile, level)
            outfile.write('file_supports_reparse_points=model_.EntityStateBoolType(\n')
            self.file_supports_reparse_points.exportLiteral(outfile, level, name_='file_supports_reparse_points')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_supports_remote_storage is not None:
            showIndent(outfile, level)
            outfile.write('file_supports_remote_storage=model_.EntityStateBoolType(\n')
            self.file_supports_remote_storage.exportLiteral(outfile, level, name_='file_supports_remote_storage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_volume_is_compressed is not None:
            showIndent(outfile, level)
            outfile.write('file_volume_is_compressed=model_.EntityStateBoolType(\n')
            self.file_volume_is_compressed.exportLiteral(outfile, level, name_='file_volume_is_compressed')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_supports_object_ids is not None:
            showIndent(outfile, level)
            outfile.write('file_supports_object_ids=model_.EntityStateBoolType(\n')
            self.file_supports_object_ids.exportLiteral(outfile, level, name_='file_supports_object_ids')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_supports_encryption is not None:
            showIndent(outfile, level)
            outfile.write('file_supports_encryption=model_.EntityStateBoolType(\n')
            self.file_supports_encryption.exportLiteral(outfile, level, name_='file_supports_encryption')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_named_streams is not None:
            showIndent(outfile, level)
            outfile.write('file_named_streams=model_.EntityStateBoolType(\n')
            self.file_named_streams.exportLiteral(outfile, level, name_='file_named_streams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.file_read_only_volume is not None:
            showIndent(outfile, level)
            outfile.write('file_read_only_volume=model_.EntityStateBoolType(\n')
            self.file_read_only_volume.exportLiteral(outfile, level, name_='file_read_only_volume')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(volume_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'rootpath':
            rootpath_ = child_.text
            self.rootpath = rootpath_
            self.validate_rootpath(self.rootpath)    # validate type rootpath
        elif nodeName_ == 'file_system':
            file_system_ = child_.text
            self.file_system = file_system_
            self.validate_file_system(self.file_system)    # validate type file_system
        elif nodeName_ == 'name':
            name_ = child_.text
            self.name = name_
            self.validate_name(self.name)    # validate type name
        elif nodeName_ == 'volume_max_component_length': 
            obj_ = None
            self.set_volume_max_component_length(obj_)
            self.validate_volume_max_component_length(self.volume_max_component_length)    # validate type volume_max_component_length
        elif nodeName_ == 'serial_number': 
            obj_ = None
            self.set_serial_number(obj_)
            self.validate_serial_number(self.serial_number)    # validate type serial_number
        elif nodeName_ == 'file_case_sensitive_search': 
            obj_ = None
            self.set_file_case_sensitive_search(obj_)
            self.validate_file_case_sensitive_search(self.file_case_sensitive_search)    # validate type file_case_sensitive_search
        elif nodeName_ == 'file_case_preserved_names': 
            obj_ = None
            self.set_file_case_preserved_names(obj_)
            self.validate_file_case_preserved_names(self.file_case_preserved_names)    # validate type file_case_preserved_names
        elif nodeName_ == 'file_unicode_on_disk': 
            obj_ = None
            self.set_file_unicode_on_disk(obj_)
            self.validate_file_unicode_on_disk(self.file_unicode_on_disk)    # validate type file_unicode_on_disk
        elif nodeName_ == 'file_persistent_acls': 
            obj_ = None
            self.set_file_persistent_acls(obj_)
            self.validate_file_persistent_acls(self.file_persistent_acls)    # validate type file_persistent_acls
        elif nodeName_ == 'file_file_compression': 
            obj_ = None
            self.set_file_file_compression(obj_)
            self.validate_file_file_compression(self.file_file_compression)    # validate type file_file_compression
        elif nodeName_ == 'file_volume_quotas': 
            obj_ = None
            self.set_file_volume_quotas(obj_)
            self.validate_file_volume_quotas(self.file_volume_quotas)    # validate type file_volume_quotas
        elif nodeName_ == 'file_supports_sparse_files': 
            obj_ = None
            self.set_file_supports_sparse_files(obj_)
            self.validate_file_supports_sparse_files(self.file_supports_sparse_files)    # validate type file_supports_sparse_files
        elif nodeName_ == 'file_supports_reparse_points': 
            obj_ = None
            self.set_file_supports_reparse_points(obj_)
            self.validate_file_supports_reparse_points(self.file_supports_reparse_points)    # validate type file_supports_reparse_points
        elif nodeName_ == 'file_supports_remote_storage': 
            obj_ = None
            self.set_file_supports_remote_storage(obj_)
            self.validate_file_supports_remote_storage(self.file_supports_remote_storage)    # validate type file_supports_remote_storage
        elif nodeName_ == 'file_volume_is_compressed': 
            obj_ = None
            self.set_file_volume_is_compressed(obj_)
            self.validate_file_volume_is_compressed(self.file_volume_is_compressed)    # validate type file_volume_is_compressed
        elif nodeName_ == 'file_supports_object_ids': 
            obj_ = None
            self.set_file_supports_object_ids(obj_)
            self.validate_file_supports_object_ids(self.file_supports_object_ids)    # validate type file_supports_object_ids
        elif nodeName_ == 'file_supports_encryption': 
            obj_ = None
            self.set_file_supports_encryption(obj_)
            self.validate_file_supports_encryption(self.file_supports_encryption)    # validate type file_supports_encryption
        elif nodeName_ == 'file_named_streams': 
            obj_ = None
            self.set_file_named_streams(obj_)
            self.validate_file_named_streams(self.file_named_streams)    # validate type file_named_streams
        elif nodeName_ == 'file_read_only_volume': 
            obj_ = None
            self.set_file_read_only_volume(obj_)
            self.validate_file_read_only_volume(self.file_read_only_volume)    # validate type file_read_only_volume
        super(volume_state, self).buildChildren(child_, nodeName_)
# end class volume_state


class wmi_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(wmi_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if wmi_test.subclass:
            return wmi_test.subclass(*args_, **kwargs_)
        else:
            return wmi_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='wmi_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wmi_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="wmi_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='wmi_test'):
        super(wmi_test, self).exportAttributes(outfile, level, namespace_, name_='wmi_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='wmi_test'):
        super(wmi_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(wmi_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wmi_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(wmi_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(wmi_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(wmi_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(wmi_test, self).buildChildren(child_, nodeName_)
# end class wmi_test


class wmi_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, namespace=None, wql=None):
        super(wmi_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.namespace = namespace
        self.wql = wql
    def factory(*args_, **kwargs_):
        if wmi_object.subclass:
            return wmi_object.subclass(*args_, **kwargs_)
        else:
            return wmi_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def validate_namespace(self, value):
        # validate type namespace
        pass
    def get_wql(self): return self.wql
    def set_wql(self, wql): self.wql = wql
    def validate_wql(self, value):
        # validate type wql
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='wmi_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wmi_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="wmi_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='wmi_object'):
        super(wmi_object, self).exportAttributes(outfile, level, namespace_, name_='wmi_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='wmi_object'):
        super(wmi_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.namespace is not None:
            showIndent(outfile, level)
            outfile.write('<%snamespace>%s</%snamespace>\n' % (namespace_, self.format_string(quote_xml(self.namespace).encode(ExternalEncoding), input_name='namespace'), namespace_))
        if self.wql is not None:
            showIndent(outfile, level)
            outfile.write('<%swql>%s</%swql>\n' % (namespace_, self.format_string(quote_xml(self.wql).encode(ExternalEncoding), input_name='wql'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.namespace is not None or
            self.wql is not None or
            super(wmi_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wmi_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(wmi_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(wmi_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.namespace is not None:
            showIndent(outfile, level)
            outfile.write('namespace=%s,\n' % quote_python(self.namespace).encode(ExternalEncoding))
        if self.wql is not None:
            showIndent(outfile, level)
            outfile.write('wql=%s,\n' % quote_python(self.wql).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(wmi_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'namespace':
            namespace_ = child_.text
            self.namespace = namespace_
            self.validate_namespace(self.namespace)    # validate type namespace
        elif nodeName_ == 'wql':
            wql_ = child_.text
            self.wql = wql_
            self.validate_wql(self.wql)    # validate type wql
        super(wmi_object, self).buildChildren(child_, nodeName_)
# end class wmi_object


class wmi_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, namespace=None, wql=None, result=None):
        super(wmi_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.namespace = namespace
        self.wql = wql
        self.result = result
    def factory(*args_, **kwargs_):
        if wmi_state.subclass:
            return wmi_state.subclass(*args_, **kwargs_)
        else:
            return wmi_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def validate_namespace(self, value):
        # validate type namespace
        pass
    def get_wql(self): return self.wql
    def set_wql(self, wql): self.wql = wql
    def validate_wql(self, value):
        # validate type wql
        pass
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def validate_result(self, value):
        # validate type result
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='wmi_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wmi_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="wmi_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='wmi_state'):
        super(wmi_state, self).exportAttributes(outfile, level, namespace_, name_='wmi_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='wmi_state'):
        super(wmi_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.namespace is not None:
            showIndent(outfile, level)
            outfile.write('<%snamespace>%s</%snamespace>\n' % (namespace_, self.format_string(quote_xml(self.namespace).encode(ExternalEncoding), input_name='namespace'), namespace_))
        if self.wql is not None:
            showIndent(outfile, level)
            outfile.write('<%swql>%s</%swql>\n' % (namespace_, self.format_string(quote_xml(self.wql).encode(ExternalEncoding), input_name='wql'), namespace_))
        if self.result is not None:
            showIndent(outfile, level)
            outfile.write('<%sresult>%s</%sresult>\n' % (namespace_, self.format_string(quote_xml(self.result).encode(ExternalEncoding), input_name='result'), namespace_))
    def hasContent_(self):
        if (
            self.namespace is not None or
            self.wql is not None or
            self.result is not None or
            super(wmi_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wmi_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(wmi_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(wmi_state, self).exportLiteralChildren(outfile, level, name_)
        if self.namespace is not None:
            showIndent(outfile, level)
            outfile.write('namespace=%s,\n' % quote_python(self.namespace).encode(ExternalEncoding))
        if self.wql is not None:
            showIndent(outfile, level)
            outfile.write('wql=%s,\n' % quote_python(self.wql).encode(ExternalEncoding))
        if self.result is not None:
            showIndent(outfile, level)
            outfile.write('result=%s,\n' % quote_python(self.result).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(wmi_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'namespace':
            namespace_ = child_.text
            self.namespace = namespace_
            self.validate_namespace(self.namespace)    # validate type namespace
        elif nodeName_ == 'wql':
            wql_ = child_.text
            self.wql = wql_
            self.validate_wql(self.wql)    # validate type wql
        elif nodeName_ == 'result':
            result_ = child_.text
            self.result = result_
            self.validate_result(self.result)    # validate type result
        super(wmi_state, self).buildChildren(child_, nodeName_)
# end class wmi_state


class wmi57_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(wmi57_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if wmi57_test.subclass:
            return wmi57_test.subclass(*args_, **kwargs_)
        else:
            return wmi57_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='wmi57_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wmi57_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="wmi57_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='wmi57_test'):
        super(wmi57_test, self).exportAttributes(outfile, level, namespace_, name_='wmi57_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='wmi57_test'):
        super(wmi57_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(wmi57_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wmi57_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(wmi57_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(wmi57_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(wmi57_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(wmi57_test, self).buildChildren(child_, nodeName_)
# end class wmi57_test


class wmi57_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, namespace=None, wql=None):
        super(wmi57_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.namespace = namespace
        self.wql = wql
    def factory(*args_, **kwargs_):
        if wmi57_object.subclass:
            return wmi57_object.subclass(*args_, **kwargs_)
        else:
            return wmi57_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def validate_namespace(self, value):
        # validate type namespace
        pass
    def get_wql(self): return self.wql
    def set_wql(self, wql): self.wql = wql
    def validate_wql(self, value):
        # validate type wql
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='wmi57_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wmi57_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="wmi57_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='wmi57_object'):
        super(wmi57_object, self).exportAttributes(outfile, level, namespace_, name_='wmi57_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='wmi57_object'):
        super(wmi57_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.namespace is not None:
            showIndent(outfile, level)
            outfile.write('<%snamespace>%s</%snamespace>\n' % (namespace_, self.format_string(quote_xml(self.namespace).encode(ExternalEncoding), input_name='namespace'), namespace_))
        if self.wql is not None:
            showIndent(outfile, level)
            outfile.write('<%swql>%s</%swql>\n' % (namespace_, self.format_string(quote_xml(self.wql).encode(ExternalEncoding), input_name='wql'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.namespace is not None or
            self.wql is not None or
            super(wmi57_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wmi57_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(wmi57_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(wmi57_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.namespace is not None:
            showIndent(outfile, level)
            outfile.write('namespace=%s,\n' % quote_python(self.namespace).encode(ExternalEncoding))
        if self.wql is not None:
            showIndent(outfile, level)
            outfile.write('wql=%s,\n' % quote_python(self.wql).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(wmi57_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'namespace':
            namespace_ = child_.text
            self.namespace = namespace_
            self.validate_namespace(self.namespace)    # validate type namespace
        elif nodeName_ == 'wql':
            wql_ = child_.text
            self.wql = wql_
            self.validate_wql(self.wql)    # validate type wql
        super(wmi57_object, self).buildChildren(child_, nodeName_)
# end class wmi57_object


class wmi57_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, namespace=None, wql=None, result=None):
        super(wmi57_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.namespace = namespace
        self.wql = wql
        self.result = result
    def factory(*args_, **kwargs_):
        if wmi57_state.subclass:
            return wmi57_state.subclass(*args_, **kwargs_)
        else:
            return wmi57_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def validate_namespace(self, value):
        # validate type namespace
        pass
    def get_wql(self): return self.wql
    def set_wql(self, wql): self.wql = wql
    def validate_wql(self, value):
        # validate type wql
        pass
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def export(self, outfile, level, namespace_='win-def:', name_='wmi57_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wmi57_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="wmi57_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='wmi57_state'):
        super(wmi57_state, self).exportAttributes(outfile, level, namespace_, name_='wmi57_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='wmi57_state'):
        super(wmi57_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.namespace is not None:
            showIndent(outfile, level)
            outfile.write('<%snamespace>%s</%snamespace>\n' % (namespace_, self.format_string(quote_xml(self.namespace).encode(ExternalEncoding), input_name='namespace'), namespace_))
        if self.wql is not None:
            showIndent(outfile, level)
            outfile.write('<%swql>%s</%swql>\n' % (namespace_, self.format_string(quote_xml(self.wql).encode(ExternalEncoding), input_name='wql'), namespace_))
        if self.result:
            self.result.export(outfile, level, namespace_, name_='result')
    def hasContent_(self):
        if (
            self.namespace is not None or
            self.wql is not None or
            self.result is not None or
            super(wmi57_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wmi57_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(wmi57_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(wmi57_state, self).exportLiteralChildren(outfile, level, name_)
        if self.namespace is not None:
            showIndent(outfile, level)
            outfile.write('namespace=%s,\n' % quote_python(self.namespace).encode(ExternalEncoding))
        if self.wql is not None:
            showIndent(outfile, level)
            outfile.write('wql=%s,\n' % quote_python(self.wql).encode(ExternalEncoding))
        if self.result is not None:
            showIndent(outfile, level)
            outfile.write('result=model_.EntityStateRecordType(\n')
            self.result.exportLiteral(outfile, level, name_='result')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(wmi57_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'namespace':
            namespace_ = child_.text
            self.namespace = namespace_
            self.validate_namespace(self.namespace)    # validate type namespace
        elif nodeName_ == 'wql':
            wql_ = child_.text
            self.wql = wql_
            self.validate_wql(self.wql)    # validate type wql
        elif nodeName_ == 'result': 
            obj_ = EntityStateRecordType.factory()
            obj_.build(child_)
            self.set_result(obj_)
        super(wmi57_state, self).buildChildren(child_, nodeName_)
# end class wmi57_state


class wuaupdatesearcher_test(TestType):
    subclass = None
    superclass = TestType
    def __init__(self, comment=None, state_operator='AND', deprecated=None, check=None, version=None, id=None, check_existence='at_least_one_exists', Signature=None, notes=None, object=None, state=None):
        super(wuaupdatesearcher_test, self).__init__(comment, state_operator, deprecated, check, version, id, check_existence, Signature, notes, )
        self.object = object
        if state is None:
            self.state = []
        else:
            self.state = state
    def factory(*args_, **kwargs_):
        if wuaupdatesearcher_test.subclass:
            return wuaupdatesearcher_test.subclass(*args_, **kwargs_)
        else:
            return wuaupdatesearcher_test(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def add_state(self, value): self.state.append(value)
    def insert_state(self, index, value): self.state[index] = value
    def export(self, outfile, level, namespace_='win-def:', name_='wuaupdatesearcher_test', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wuaupdatesearcher_test')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="wuaupdatesearcher_test"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='wuaupdatesearcher_test'):
        super(wuaupdatesearcher_test, self).exportAttributes(outfile, level, namespace_, name_='wuaupdatesearcher_test')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='wuaupdatesearcher_test'):
        super(wuaupdatesearcher_test, self).exportChildren(outfile, level, namespace_, name_)
        if self.object:
            self.object.export(outfile, level, namespace_, name_='object', )
        for state_ in self.state:
            state_.export(outfile, level, namespace_, name_='state')
    def hasContent_(self):
        if (
            self.object is not None or
            self.state or
            super(wuaupdatesearcher_test, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wuaupdatesearcher_test'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(wuaupdatesearcher_test, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(wuaupdatesearcher_test, self).exportLiteralChildren(outfile, level, name_)
        if self.object is not None:
            showIndent(outfile, level)
            outfile.write('object=model_.ObjectRefType(\n')
            self.object.exportLiteral(outfile, level, name_='object')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('state=[\n')
        level += 1
        for state_ in self.state:
            showIndent(outfile, level)
            outfile.write('model_.StateRefType(\n')
            state_.exportLiteral(outfile, level, name_='StateRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(wuaupdatesearcher_test, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'object': 
            obj_ = ObjectRefType.factory()
            obj_.build(child_)
            self.set_object(obj_)
        elif nodeName_ == 'state': 
            obj_ = StateRefType.factory()
            obj_.build(child_)
            self.state.append(obj_)
        super(wuaupdatesearcher_test, self).buildChildren(child_, nodeName_)
# end class wuaupdatesearcher_test


class wuaupdatesearcher_object(ObjectType):
    subclass = None
    superclass = ObjectType
    def __init__(self, comment=None, deprecated=None, version=None, id=None, Signature=None, notes=None, set=None, behaviors=None, search_criteria=None):
        super(wuaupdatesearcher_object, self).__init__(comment, deprecated, version, id, Signature, notes, )
        self.set = set
        self.behaviors = behaviors
        self.search_criteria = search_criteria
    def factory(*args_, **kwargs_):
        if wuaupdatesearcher_object.subclass:
            return wuaupdatesearcher_object.subclass(*args_, **kwargs_)
        else:
            return wuaupdatesearcher_object(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_set(self): return self.set
    def set_set(self, set): self.set = set
    def get_behaviors(self): return self.behaviors
    def set_behaviors(self, behaviors): self.behaviors = behaviors
    def get_search_criteria(self): return self.search_criteria
    def set_search_criteria(self, search_criteria): self.search_criteria = search_criteria
    def validate_search_criteria(self, value):
        # validate type search_criteria
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='wuaupdatesearcher_object', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wuaupdatesearcher_object')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="wuaupdatesearcher_object"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='wuaupdatesearcher_object'):
        super(wuaupdatesearcher_object, self).exportAttributes(outfile, level, namespace_, name_='wuaupdatesearcher_object')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='wuaupdatesearcher_object'):
        super(wuaupdatesearcher_object, self).exportChildren(outfile, level, namespace_, name_)
        if self.set:
            self.set.export(outfile, level, namespace_, name_='set')
        if self.behaviors:
            self.behaviors.export(outfile, level, namespace_, name_='behaviors')
        if self.search_criteria is not None:
            showIndent(outfile, level)
            outfile.write('<%ssearch_criteria>%s</%ssearch_criteria>\n' % (namespace_, self.format_string(quote_xml(self.search_criteria).encode(ExternalEncoding), input_name='search_criteria'), namespace_))
    def hasContent_(self):
        if (
            self.set is not None or
            self.behaviors is not None or
            self.search_criteria is not None or
            super(wuaupdatesearcher_object, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wuaupdatesearcher_object'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(wuaupdatesearcher_object, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(wuaupdatesearcher_object, self).exportLiteralChildren(outfile, level, name_)
        if self.set is not None:
            showIndent(outfile, level)
            outfile.write('set=model_.set(\n')
            self.set.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.behaviors is not None:
            showIndent(outfile, level)
            outfile.write('behaviors=model_.WuaUpdateSearcherBehaviors(\n')
            self.behaviors.exportLiteral(outfile, level, name_='behaviors')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.search_criteria is not None:
            showIndent(outfile, level)
            outfile.write('search_criteria=%s,\n' % quote_python(self.search_criteria).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(wuaupdatesearcher_object, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'set': 
            obj_ = set.factory()
            obj_.build(child_)
            self.set_set(obj_)
        elif nodeName_ == 'behaviors': 
            obj_ = WuaUpdateSearcherBehaviors.factory()
            obj_.build(child_)
            self.set_behaviors(obj_)
        elif nodeName_ == 'search_criteria':
            search_criteria_ = child_.text
            self.search_criteria = search_criteria_
            self.validate_search_criteria(self.search_criteria)    # validate type search_criteria
        super(wuaupdatesearcher_object, self).buildChildren(child_, nodeName_)
# end class wuaupdatesearcher_object


class wuaupdatesearcher_state(StateType):
    subclass = None
    superclass = StateType
    def __init__(self, operator='AND', comment=None, version=None, id=None, deprecated=None, Signature=None, notes=None, search_criteria=None, update_id=None):
        super(wuaupdatesearcher_state, self).__init__(operator, comment, version, id, deprecated, Signature, notes, )
        self.search_criteria = search_criteria
        self.update_id = update_id
    def factory(*args_, **kwargs_):
        if wuaupdatesearcher_state.subclass:
            return wuaupdatesearcher_state.subclass(*args_, **kwargs_)
        else:
            return wuaupdatesearcher_state(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_search_criteria(self): return self.search_criteria
    def set_search_criteria(self, search_criteria): self.search_criteria = search_criteria
    def validate_search_criteria(self, value):
        # validate type search_criteria
        pass
    def get_update_id(self): return self.update_id
    def set_update_id(self, update_id): self.update_id = update_id
    def validate_update_id(self, value):
        # validate type update_id
        pass
    def export(self, outfile, level, namespace_='win-def:', name_='wuaupdatesearcher_state', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='wuaupdatesearcher_state')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="wuaupdatesearcher_state"')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='wuaupdatesearcher_state'):
        super(wuaupdatesearcher_state, self).exportAttributes(outfile, level, namespace_, name_='wuaupdatesearcher_state')
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='wuaupdatesearcher_state'):
        super(wuaupdatesearcher_state, self).exportChildren(outfile, level, namespace_, name_)
        if self.search_criteria is not None:
            showIndent(outfile, level)
            outfile.write('<%ssearch_criteria>%s</%ssearch_criteria>\n' % (namespace_, self.format_string(quote_xml(self.search_criteria).encode(ExternalEncoding), input_name='search_criteria'), namespace_))
        if self.update_id is not None:
            showIndent(outfile, level)
            outfile.write('<%supdate_id>%s</%supdate_id>\n' % (namespace_, self.format_string(quote_xml(self.update_id).encode(ExternalEncoding), input_name='update_id'), namespace_))
    def hasContent_(self):
        if (
            self.search_criteria is not None or
            self.update_id is not None or
            super(wuaupdatesearcher_state, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='wuaupdatesearcher_state'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        super(wuaupdatesearcher_state, self).exportLiteralAttributes(outfile, level, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(wuaupdatesearcher_state, self).exportLiteralChildren(outfile, level, name_)
        if self.search_criteria is not None:
            showIndent(outfile, level)
            outfile.write('search_criteria=%s,\n' % quote_python(self.search_criteria).encode(ExternalEncoding))
        if self.update_id is not None:
            showIndent(outfile, level)
            outfile.write('update_id=%s,\n' % quote_python(self.update_id).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        super(wuaupdatesearcher_state, self).buildAttributes(node, attrs)
    def buildChildren(self, child_, nodeName_):
        if nodeName_ == 'search_criteria':
            search_criteria_ = child_.text
            self.search_criteria = search_criteria_
            self.validate_search_criteria(self.search_criteria)    # validate type search_criteria
        elif nodeName_ == 'update_id':
            update_id_ = child_.text
            self.update_id = update_id_
            self.validate_update_id(self.update_id)    # validate type update_id
        super(wuaupdatesearcher_state, self).buildChildren(child_, nodeName_)
# end class wuaupdatesearcher_state


class WuaUpdateSearcherBehaviors(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, include_superseded_updates=True, valueOf_=None):
        self.include_superseded_updates = _cast(bool, include_superseded_updates)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if WuaUpdateSearcherBehaviors.subclass:
            return WuaUpdateSearcherBehaviors.subclass(*args_, **kwargs_)
        else:
            return WuaUpdateSearcherBehaviors(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_include_superseded_updates(self): return self.include_superseded_updates
    def set_include_superseded_updates(self, include_superseded_updates): self.include_superseded_updates = include_superseded_updates
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='WuaUpdateSearcherBehaviors', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='WuaUpdateSearcherBehaviors')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.valueOf_)
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='WuaUpdateSearcherBehaviors'):
        if self.include_superseded_updates is not None:
            outfile.write(' include_superseded_updates="%s"' % self.format_boolean(str_lower(str(self.include_superseded_updates)), input_name='include_superseded_updates'))
    def exportChildren(self, outfile, level, namespace_='win-def:', name_='WuaUpdateSearcherBehaviors'):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='WuaUpdateSearcherBehaviors'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.include_superseded_updates is not None:
            showIndent(outfile, level)
            outfile.write('include_superseded_updates = %s,\n' % (self.include_superseded_updates,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        value = attrs.get('include_superseded_updates')
        if value is not None:
            if value in ('true', '1'):
                self.include_superseded_updates = True
            elif value in ('false', '0'):
                self.include_superseded_updates = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, nodeName_):
        pass
# end class WuaUpdateSearcherBehaviors


class EntityStateAddrTypeType(GeneratedsSuper):
    subclass = None
    superclass = EntityStateStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateAddrTypeType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateAddrTypeType.subclass:
            return EntityStateAddrTypeType.subclass(*args_, **kwargs_)
        else:
            return EntityStateAddrTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateAddrTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateAddrTypeType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateAddrTypeType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateAddrTypeType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateAddrTypeType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateAddrTypeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateAddrTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityStateAddrTypeType


class EntityStateAdstypeType(GeneratedsSuper):
    subclass = None
    superclass = EntityStateStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateAdstypeType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateAdstypeType.subclass:
            return EntityStateAdstypeType.subclass(*args_, **kwargs_)
        else:
            return EntityStateAdstypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateAdstypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateAdstypeType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateAdstypeType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateAdstypeType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateAdstypeType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateAdstypeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateAdstypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityStateAdstypeType


class EntityStateAuditType(GeneratedsSuper):
    subclass = None
    superclass = EntityStateStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateAuditType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateAuditType.subclass:
            return EntityStateAuditType.subclass(*args_, **kwargs_)
        else:
            return EntityStateAuditType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateAuditType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateAuditType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateAuditType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateAuditType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateAuditType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateAuditType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateAuditType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityStateAuditType


class EntityStateInterfaceTypeType(GeneratedsSuper):
    subclass = None
    superclass = EntityStateStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateInterfaceTypeType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateInterfaceTypeType.subclass:
            return EntityStateInterfaceTypeType.subclass(*args_, **kwargs_)
        else:
            return EntityStateInterfaceTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateInterfaceTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateInterfaceTypeType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateInterfaceTypeType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateInterfaceTypeType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateInterfaceTypeType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateInterfaceTypeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateInterfaceTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityStateInterfaceTypeType


class EntityStateFileTypeType(GeneratedsSuper):
    subclass = None
    superclass = EntityStateStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateFileTypeType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateFileTypeType.subclass:
            return EntityStateFileTypeType.subclass(*args_, **kwargs_)
        else:
            return EntityStateFileTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateFileTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateFileTypeType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateFileTypeType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateFileTypeType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateFileTypeType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateFileTypeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateFileTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityStateFileTypeType


class EntityObjectNamingContextType(GeneratedsSuper):
    subclass = None
    superclass = EntityObjectStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityObjectNamingContextType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectNamingContextType.subclass:
            return EntityObjectNamingContextType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectNamingContextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityObjectNamingContextType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityObjectNamingContextType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityObjectNamingContextType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityObjectNamingContextType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityObjectNamingContextType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectNamingContextType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityObjectNamingContextType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityObjectNamingContextType


class EntityStateNamingContextType(GeneratedsSuper):
    subclass = None
    superclass = EntityStateStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateNamingContextType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateNamingContextType.subclass:
            return EntityStateNamingContextType.subclass(*args_, **kwargs_)
        else:
            return EntityStateNamingContextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateNamingContextType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateNamingContextType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateNamingContextType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateNamingContextType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateNamingContextType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateNamingContextType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateNamingContextType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityStateNamingContextType


class EntityObjectProtocolType(GeneratedsSuper):
    subclass = None
    superclass = EntityObjectStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityObjectProtocolType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectProtocolType.subclass:
            return EntityObjectProtocolType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectProtocolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityObjectProtocolType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityObjectProtocolType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityObjectProtocolType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityObjectProtocolType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityObjectProtocolType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectProtocolType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityObjectProtocolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityObjectProtocolType


class EntityStateProtocolType(GeneratedsSuper):
    subclass = None
    superclass = EntityStateStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateProtocolType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateProtocolType.subclass:
            return EntityStateProtocolType.subclass(*args_, **kwargs_)
        else:
            return EntityStateProtocolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateProtocolType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateProtocolType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateProtocolType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateProtocolType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateProtocolType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateProtocolType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateProtocolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityStateProtocolType


class EntityObjectRegistryHiveType(GeneratedsSuper):
    subclass = None
    superclass = EntityObjectStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityObjectRegistryHiveType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityObjectRegistryHiveType.subclass:
            return EntityObjectRegistryHiveType.subclass(*args_, **kwargs_)
        else:
            return EntityObjectRegistryHiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityObjectRegistryHiveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityObjectRegistryHiveType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityObjectRegistryHiveType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityObjectRegistryHiveType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityObjectRegistryHiveType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityObjectRegistryHiveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityObjectRegistryHiveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityObjectRegistryHiveType


class EntityStateRegistryHiveType(GeneratedsSuper):
    subclass = None
    superclass = EntityStateStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateRegistryHiveType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateRegistryHiveType.subclass:
            return EntityStateRegistryHiveType.subclass(*args_, **kwargs_)
        else:
            return EntityStateRegistryHiveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateRegistryHiveType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateRegistryHiveType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateRegistryHiveType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateRegistryHiveType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateRegistryHiveType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateRegistryHiveType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateRegistryHiveType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityStateRegistryHiveType


class EntityStateRegistryTypeType(GeneratedsSuper):
    subclass = None
    superclass = EntityStateStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateRegistryTypeType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateRegistryTypeType.subclass:
            return EntityStateRegistryTypeType.subclass(*args_, **kwargs_)
        else:
            return EntityStateRegistryTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateRegistryTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateRegistryTypeType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateRegistryTypeType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateRegistryTypeType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateRegistryTypeType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateRegistryTypeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateRegistryTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityStateRegistryTypeType


class EntityStateSharedResourceTypeType(GeneratedsSuper):
    subclass = None
    superclass = EntityStateStringType
    def __init__(self, datatype='string', operation='equals', mask=False, var_ref=None, entity_check='all', var_check='all', valueOf_=None, mixedclass_=None, content_=None):
        super(EntityStateSharedResourceTypeType, self).__init__(valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if EntityStateSharedResourceTypeType.subclass:
            return EntityStateSharedResourceTypeType.subclass(*args_, **kwargs_)
        else:
            return EntityStateSharedResourceTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='win-def:', name_='EntityStateSharedResourceTypeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='EntityStateSharedResourceTypeType')
        outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
        outfile.write(' xsi:type="EntityStateSharedResourceTypeType"')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, namespace_='win-def:', name_='EntityStateSharedResourceTypeType'):
        pass
    #def exportChildren(self, outfile, level, namespace_='win-def:', name_='EntityStateSharedResourceTypeType'):
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(EntityStateSharedResourceTypeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntityStateSharedResourceTypeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node):
        self.buildAttributes(node, node.attrib)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, nodeName_)
    def buildAttributes(self, node, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class EntityStateSharedResourceTypeType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="deprecated_info",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from oval57 import *\n\n')
    sys.stdout.write('import oval57 as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

